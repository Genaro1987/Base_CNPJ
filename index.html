<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GF2 ‚Ä¢ Sistema de Pesquisa de Empresas</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <style>
    /* Garante que o mapa tenha altura vis√≠vel e fique acima de outros elementos se necess√°rio */
    #mapa-real { z-index: 1; }
    .custom-pin { display: flex; align-items: center; justify-content: center; }
  </style>
  <style>
    :root {
      --gf2-red: #b02232;
      --gf2-red-dark: #8a1826;
      --gf2-red-soft: #f7e7ea;
      --gf2-neutral: #f3f4f8;
      --gf2-border: #e0e4ed;
      --gf2-text: #222c3d;
      --gf2-muted: #5b6470;
      --gf2-white: #ffffff;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 1cm;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background-color: var(--gf2-neutral);
      color: var(--gf2-text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      background: var(--gf2-white);
      color: var(--gf2-red);
      padding: 1.5rem 2rem 0.75rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
      box-shadow: 0 4px 18px rgba(176, 34, 50, 0.12);
    }

    header .brand {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    header .brand .logo {
      width: 60px;
      height: 60px;
      border-radius: 12px;
      background: var(--gf2-red-soft);
      color: var(--gf2-red);
      font-weight: 700;
      display: grid;
      place-items: center;
      font-size: 1.5rem;
      box-shadow: inset 0 0 0 2px var(--gf2-red);
    }

    header .brand h1 {
      margin: 0;
      font-size: 1.5rem;
      line-height: 1.25;
    }

    header .subtitle {
      font-size: 0.9rem;
      opacity: 0.85;
    }

    main {
      flex: 1;
      padding: 2.5rem 0 3rem;
      display: flex;
      flex-direction: column;
      gap: 2rem;
      width: 100%;
      margin: 0;
    }

    .card {
      background: var(--gf2-white);
      border-radius: 16px;
      padding: 2rem 2.5rem;
      box-shadow: 0 12px 28px rgba(17, 24, 39, 0.08);
      border: 1px solid var(--gf2-border);
    }

    .card-header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: wrap;
      margin-bottom: 1rem;
    }

    .card-header-row h2 {
      margin-bottom: 0;
    }

    .tabs-wrapper {
      width: 100%;
      border-top: 1px solid var(--gf2-border);
      margin-top: 1.5rem;
      padding-top: 0.75rem;
    }

    .tabs {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .tab {
      border: none;
      background: var(--gf2-red-soft);
      color: var(--gf2-red);
      padding: 0.75rem 1.75rem;
      border-radius: 999px;
      font-weight: 600;
      font-size: 0.85rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      cursor: pointer;
      transition: background 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
    }

    .tab[disabled],
    .tab[aria-disabled="true"] {
      opacity: 0.45;
      cursor: not-allowed;
      pointer-events: none;
      box-shadow: none;
    }

    .tab.active {
      background: var(--gf2-red);
      color: var(--gf2-white);
      box-shadow: 0 10px 24px rgba(176, 34, 50, 0.25);
    }

    h2 {
      margin-top: 0;
      margin-bottom: 1.5rem;
      font-size: 1.4rem;
      color: var(--gf2-red-dark);
    }

    form {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .field-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1.5rem;
    }

    label {
      font-weight: 600;
      display: block;
      margin-bottom: 0.5rem;
      color: var(--gf2-muted);
      text-transform: uppercase;
      font-size: 0.8rem;
      letter-spacing: 0.05em;
    }

    select,
    input[type="text"],
    textarea,
    .multiselect-input {
      width: 100%;
      padding: 0.75rem 1rem;
      border-radius: 12px;
      border: 1px solid var(--gf2-border);
      font-size: 0.95rem;
      background: var(--gf2-neutral);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    select:focus,
    input[type="text"]:focus,
    textarea:focus,
    .multiselect-input:focus {
      outline: none;
      border-color: var(--gf2-red);
      box-shadow: 0 0 0 3px rgba(193, 18, 31, 0.2);
    }

    select:disabled,
    input[type="text"]:disabled,
    textarea:disabled,
    .multiselect-input:disabled {
      background: var(--gf2-neutral);
      color: var(--gf2-muted);
      cursor: not-allowed;
    }

    textarea {
      min-height: 210px;
      resize: vertical;
      line-height: 1.5;
    }

    .file-input-group {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.75rem;
    }

    .file-input-group input[type="file"] {
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--gf2-border);
      background: var(--gf2-white);
      color: var(--gf2-muted);
      padding: 0.4rem 0.6rem;
      font-size: 0.95rem;
      cursor: pointer;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .file-input-group input[type="file"]:focus-visible {
      outline: none;
      border-color: var(--gf2-red);
      box-shadow: 0 0 0 3px rgba(193, 18, 31, 0.2);
    }

    .file-input-group input[type="file"]::file-selector-button,
    .file-input-group input[type="file"]::-webkit-file-upload-button {
      background: var(--gf2-white);
      border: 1px solid var(--gf2-red);
      color: var(--gf2-red);
      border-radius: 999px;
      padding: 0.45rem 1.5rem;
      margin-right: 1rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }

    .file-input-group input[type="file"]::file-selector-button:hover,
    .file-input-group input[type="file"]::-webkit-file-upload-button:hover {
      background: var(--gf2-red-soft);
      box-shadow: 0 6px 18px rgba(176, 34, 50, 0.16);
    }

    .file-input-group input[type="file"]::file-selector-button:active,
    .file-input-group input[type="file"]::-webkit-file-upload-button:active {
      background: var(--gf2-red);
      color: var(--gf2-white);
    }

    .helper-text {
      font-size: 0.8rem;
      color: var(--gf2-muted);
      margin-top: 0.25rem;
    }

    .btn-chip {
      border: 1px solid var(--gf2-border);
      background: var(--gf2-white);
      color: var(--gf2-red-dark);
      border-radius: 999px;
      padding: 0.35rem 0.85rem;
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      transition: background 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
    }

    .btn-chip:hover {
      background: var(--gf2-red-soft);
      color: var(--gf2-red);
      box-shadow: 0 6px 18px rgba(176, 34, 50, 0.12);
    }

    .btn-chip:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      box-shadow: none;
    }

    .selection-toolbar {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin: 0.5rem 0;
    }

    .cnpj-list-wrapper {
      margin-top: 0.5rem;
      border: 1px solid var(--gf2-border);
      border-radius: 12px;
      padding: 0.5rem 0.75rem;
      background: #f8fafc;
      max-height: 180px;
      overflow-y: auto;
      font-size: 0.85rem;
      line-height: 1.4;
      color: #1f2937;
      max-width: 420px;
    }

    .cnpj-list-wrapper.empty {
      color: var(--gf2-muted);
    }

    .cnpj-list-wrapper ul {
      margin: 0;
      padding-left: 1.25rem;
      list-style: disc;
      list-style-position: inside;
      display: grid;
      gap: 0.25rem;
    }

    .cnpj-list-wrapper li {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .cnpj-list-wrapper li span.cnpj-identificador {
      display: inline-flex;
      align-items: baseline;
      gap: 0.35rem;
      font-variant-numeric: tabular-nums;
    }

    .cnpj-list-wrapper .cnpj-action {
      border: none;
      background: transparent;
      color: var(--gf2-red-dark);
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      cursor: pointer;
      padding: 0.15rem 0.25rem;
    }

    .cnpj-list-wrapper .cnpj-action:hover,
    .cnpj-list-wrapper .cnpj-action:focus {
      color: var(--gf2-red);
      text-decoration: underline;
      outline: none;
    }

    .cnpj-list-wrapper .cnpj-removed-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      margin-top: 0.75rem;
      font-size: 0.8rem;
      color: var(--gf2-muted);
    }

    .cnpj-list-wrapper .cnpj-removed-list {
      margin: 0.5rem 0 0;
      padding-left: 1.25rem;
      list-style: circle;
      list-style-position: inside;
      display: grid;
      gap: 0.25rem;
    }

    .tag-list {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: -0.5rem;
    }

    .tag {
      background: rgba(193, 18, 31, 0.12);
      color: var(--gf2-red);
      border-radius: 999px;
      padding: 0.4rem 0.85rem;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.85rem;
      font-weight: 500;
    }

    .tag button {
      all: unset;
      cursor: pointer;
      background: var(--gf2-red);
      color: var(--gf2-white);
      width: 18px;
      height: 18px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      font-size: 0.65rem;
    }

    .multiselect {
      position: relative;
    }

    .multiselect.open .multiselect-input:not(:disabled) {
      border-color: var(--gf2-red);
      box-shadow: 0 0 0 3px rgba(193, 18, 31, 0.2);
    }

    .suggestions {
      position: absolute;
      top: calc(100% + 0.35rem);
      left: 0;
      right: 0;
      background: var(--gf2-white);
      border: 1px solid var(--gf2-border);
      border-radius: 12px;
      max-height: 260px;
      overflow-y: auto;
      box-shadow: 0 15px 30px rgba(31, 41, 51, 0.15);
      z-index: 20;
    }

    .suggestion-item {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      padding: 0.75rem 1rem;
      cursor: pointer;
      border: none;
      background: transparent;
      font-size: 0.95rem;
      text-align: left;
      color: inherit;
      border-bottom: 1px solid rgba(226, 232, 240, 0.6);
    }

    .suggestion-item:last-child {
      border-bottom: none;
    }

    .suggestion-item:hover,
    .suggestion-item:focus {
      background: rgba(176, 34, 50, 0.08);
      outline: none;
    }

    .suggestion-item.selected {
      background: rgba(176, 34, 50, 0.15);
      color: var(--gf2-red-dark);
      font-weight: 600;
    }

    .suggestion-item .suggestion-meta {
      font-size: 0.8rem;
      color: var(--gf2-muted);
      white-space: nowrap;
    }

    .checkbox-group {
      display: flex;
      flex-wrap: wrap;
      flex-direction: row;
      gap: 0.75rem 1.5rem;
    }

    .checkbox-group label {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.95rem;
      text-transform: none;
      letter-spacing: normal;
      color: var(--gf2-text);
      font-weight: 500;
    }

    .municipios-checkboxes {
      border: 1px solid var(--gf2-border);
      border-radius: 12px;
      padding: 1rem;
      background: var(--gf2-white);
      max-height: 260px;
      overflow-y: auto;
      width: 100%;
    }

    .municipios-checkboxes.empty {
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-style: dashed;
      background: rgba(176, 34, 50, 0.04);
      color: var(--gf2-muted);
      padding: 1.25rem;
    }

    .municipios-checkboxes.empty .helper-text {
      margin: 0;
    }

    .checkbox-meta {
      font-size: 0.8rem;
      color: var(--gf2-muted);
    }

    input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--gf2-red);
    }

    .actions {
      display: flex;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .actions-left {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .actions-right {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      align-items: center;
    }

    body.modal-open {
      overflow: hidden;
    }

    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(17, 24, 39, 0.45);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      z-index: 999;
    }

    .modal-overlay.open {
      display: flex;
    }

    .modal {
      background: var(--gf2-white);
      border-radius: 16px;
      box-shadow: 0 24px 48px rgba(17, 24, 39, 0.25);
      max-width: min(1120px, 96vw);
      width: 100%;
      max-height: calc(100vh - 4rem);
      display: flex;
      flex-direction: column;
      border: 1px solid var(--gf2-border);
      overflow: hidden;
    }

    .modal-header,
    .modal-footer {
      padding: 1.25rem 1.75rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    .modal-header h3 {
      margin: 0;
      font-size: 1.25rem;
      color: var(--gf2-red-dark);
    }

    .modal-close {
      background: transparent;
      border: none;
      font-size: 1.5rem;
      line-height: 1;
      padding: 0.25rem 0.5rem;
      cursor: pointer;
      color: var(--gf2-muted);
    }

    .modal-close:hover {
      color: var(--gf2-red);
    }

    .modal-body {
      padding: 0 1.75rem 1.75rem;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      flex: 1 1 auto;
      min-height: 0;
    }

    .modal-status {
      margin: 0;
      font-size: 0.95rem;
      color: var(--gf2-muted);
    }

    .modal-status.error {
      color: var(--gf2-red);
    }

    .modal-description {
      margin: 0;
      font-size: 0.95rem;
      color: var(--gf2-muted);
    }

    .modal-table-wrapper {
      border: 1px solid var(--gf2-border);
      border-radius: 12px;
      background: var(--gf2-white);
      max-height: min(72vh, 640px);
      overflow-y: auto;
      overflow-x: hidden;
    }

    .modal-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }

    .modal-table th,
    .modal-table td {
      padding: 0.75rem 1rem;
      text-align: left;
      border-bottom: 1px solid var(--gf2-border);
      vertical-align: top;
    }

    .modal-table th {
      background: var(--gf2-neutral);
      font-weight: 600;
      color: var(--gf2-muted);
      text-transform: uppercase;
      font-size: 0.75rem;
      letter-spacing: 0.05em;
    }

    .modal-table thead th {
      position: sticky;
      top: 0;
      z-index: 2;
      box-shadow: 0 2px 0 rgba(17, 24, 39, 0.06);
    }

    .modal-table tbody tr:nth-child(even) {
      background: rgba(240, 242, 248, 0.4);
    }

    .modal-table select {
      width: 100%;
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      border: 1px solid var(--gf2-border);
      background: var(--gf2-white);
      font-size: 0.9rem;
    }

    .modal-table select:disabled {
      background: var(--gf2-neutral);
      color: var(--gf2-muted);
      cursor: not-allowed;
    }

    .modal-table .codigo-cell {
      font-family: 'Inter', system-ui, sans-serif;
      font-weight: 600;
      letter-spacing: 0.02em;
      color: var(--gf2-text);
    }

    .modal-empty td {
      text-align: center;
      color: var(--gf2-muted);
      font-size: 0.95rem;
      padding: 1.5rem;
    }

    .modal-footer {
      justify-content: flex-end;
      border-top: 1px solid var(--gf2-border);
      background: var(--gf2-neutral);
    }

    .count-chip {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 2rem;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      background: var(--gf2-red-soft);
      color: var(--gf2-red-dark);
      font-size: 0.75rem;
      font-weight: 600;
    }

    .list-select {
      background-color: var(--gf2-neutral);
    }

    .suggestion-empty {
      padding: 0.75rem 1rem;
      color: var(--gf2-muted);
      font-size: 0.9rem;
    }

    button {
      border: none;
      border-radius: 12px;
      padding: 0.85rem 1.5rem;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    .btn-primary {
      background: var(--gf2-red);
      color: var(--gf2-white);
      box-shadow: 0 12px 24px rgba(176, 34, 50, 0.25);
    }

    .btn-primary:hover {
      background: var(--gf2-red-dark);
      transform: translateY(-1px);
    }

    .btn-outline {
      background: transparent;
      color: var(--gf2-red);
      border: 2px solid var(--gf2-red);
    }

    .btn-outline:hover {
      background: var(--gf2-red-soft);
    }

    .btn-ghost {
      background: transparent;
      color: var(--gf2-muted);
      border: 2px dashed var(--gf2-border);
    }

    .btn-ghost:hover {
      color: var(--gf2-red);
      border-color: var(--gf2-red);
    }

    .btn-ghost[disabled],
    .btn-outline[disabled],
    .btn-primary[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .table-wrapper {
      overflow: auto;
      border-radius: 16px;
      border: 1px solid var(--gf2-border);
      box-shadow: 0 15px 32px rgba(17, 24, 39, 0.08);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 960px;
    }

    thead {
      background: var(--gf2-red-soft);
      color: var(--gf2-red-dark);
    }

    th, td {
      padding: 0.95rem 1rem;
      border-bottom: 1px solid rgba(226, 232, 240, 0.6);
      font-size: 0.9rem;
    }

    thead th {
      text-align: center;
    }

    tbody td {
      text-align: left;
    }

    .table-importacao thead th,
    .table-importacao tbody td {
      text-align: center;
    }

    .table-importacao tbody td {
      vertical-align: middle;
    }

    .value-meta {
      display: block;
      font-size: 0.75rem;
      color: var(--gf2-muted);
      margin-top: 0.25rem;
      letter-spacing: 0.02em;
    }

    .status-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.35rem 0.9rem;
      border-radius: 999px;
      font-weight: 600;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: rgba(0, 0, 0, 0.06);
    }

    .status-pill.atendido {
      background: rgba(12, 159, 104, 0.12);
      color: #0c9f68;
    }

    .status-pill.nao-atendido {
      background: rgba(193, 18, 31, 0.16);
      color: var(--gf2-red-dark);
    }

    th:nth-child(1),
    td:nth-child(1) {
      min-width: 160px;
    }

    th:nth-child(2),
    td:nth-child(2) {
      min-width: 200px;
      max-width: 260px;
    }

    th:nth-child(7),
    td:nth-child(7) {
      min-width: 180px;
      max-width: 220px;
      word-break: break-word;
    }

    th:nth-child(8),
    td:nth-child(8) {
      min-width: 140px;
      text-align: center;
    }

    th:nth-child(9),
    td:nth-child(9) {
      min-width: 220px;
      word-break: break-word;
    }

    th:nth-child(10),
    td:nth-child(10) {
      min-width: 260px;
      word-break: break-word;
    }

    tbody tr:nth-child(odd) {
      background: rgba(176, 34, 50, 0.04);
    }

    tbody tr:hover {
      background: rgba(176, 34, 50, 0.12);
    }

    .empty-state {
      padding: 2rem;
      text-align: center;
      color: var(--gf2-muted);
      font-weight: 500;
    }

    .status-message {
      color: var(--gf2-muted);
      font-size: 0.95rem;
      margin-bottom: 1rem;
    }

    .status-count {
      font-weight: 600;
      color: var(--gf2-red-dark);
      font-size: 1rem;
      margin-bottom: 0.5rem;
    }

    .actions-right .status-count {
      margin-bottom: 0;
    }

    .tab-panel {
      display: none;
    }

    .tab-panel.active {
      display: block;
    }

    @media (max-width: 768px) {
      header {
        padding: 1.25rem 1.5rem;
      }

      main {
        padding: 1.5rem;
      }

      .card {
        padding: 1.5rem;
      }

      .actions {
        flex-direction: column;
        align-items: stretch;
      }
    }

    /* Estilos para Drag and Drop */
    .sortable-ghost {
      opacity: 0.4;
      background: #e0f2fe !important;
    }

    .sortable-drag {
      cursor: move;
    }

    #rota-corpo tr {
      cursor: move;
      transition: background 0.2s;
    }

    #rota-corpo tr:hover {
      background: #f8fafc;
    }
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <div class="logo">GF2</div>
      <div>
        <h1>Sistema de Pesquisa de Empresas</h1>
        <div class="subtitle">Desenvolvido por GF2</div>
      </div>
    </div>
<div class="tabs-wrapper">
  <nav class="tabs" role="tablist" aria-label="Navega√ß√£o de abas">
    <button
      class="tab active"
      role="tab"
      aria-selected="true"
      aria-controls="tab-pesquisa"
      id="tab-btn-pesquisa"
      data-tab="pesquisa"
    >
      Lista CNPJ
    </button>

    <button
      class="tab"
      role="tab"
      aria-selected="false"
      aria-controls="tab-cobertura"
      id="tab-btn-cobertura"
      data-tab="cobertura"
      disabled
      aria-disabled="true"
    >
      Cobertura CNPJs
    </button>

    <!-- Mapa oculto, mas mantendo a l√≥gica no DOM -->
    <button
      class="tab"
      role="tab"
      aria-selected="false"
      aria-controls="tab-mapa"
      id="tab-btn-mapa"
      data-tab="mapa"
      hidden
      style="display:none"
      aria-hidden="true"
      disabled
      aria-disabled="true"
      title="Processe a Cobertura CNPJs primeiro."
    >
      Mapa de Cobertura
    </button>

    <button
      class="tab"
      role="tab"
      aria-selected="false"
      aria-controls="tab-rota"
      id="tab-btn-rota"
      data-tab="rota"
      disabled
      aria-disabled="true"
      title="Carregue dados primeiro"
    >
      Rota de Vendas
    </button>

    <button
      class="tab"
      role="tab"
      aria-selected="false"
      aria-controls="tab-estatistica"
      data-tab="estatistica"
      id="tab-btn-estatistica"
      aria-disabled="true"
      disabled
    >
      Estat√≠stica
    </button>

    <button
      class="tab"
      role="tab"
      aria-selected="false"
      aria-controls="tab-divida"
      id="tab-btn-divida"
      data-tab="divida"
    >
      D√≠vida Ativa
    </button>

    <button
      class="tab"
      role="tab"
      aria-selected="false"
      aria-controls="tab-analises"
      id="tab-btn-analises"
      data-tab="analises"
    >
      Analisar Inativos
    </button>
  </nav>
</div>

  </header>

  <main>
    <section class="tab-panel active" id="tab-pesquisa" role="tabpanel" aria-labelledby="tab-btn-pesquisa">
      <section class="card" aria-labelledby="filtros-titulo">
        <div class="card-header-row">
          <h2 id="filtros-titulo">Filtros de Pesquisa</h2>
          <button type="button" class="btn-outline" id="atualizar-opcoes-btn">Atualizar listas</button>
        </div>
        <form id="filtros-form">
          <div class="field-row">
            <div>
              <label for="uf-select">UF *</label>
              <select id="uf-select" required>
                <option value="">Selecione uma UF</option>
              </select>
              <p class="helper-text">Selecione apenas uma unidade federativa.</p>
            </div>
            <div>
              <label for="municipios-input">Munic√≠pios</label>
              <div class="multiselect">
                <input id="municipios-input" type="text" class="multiselect-input" placeholder="Clique para escolher munic√≠pios" autocomplete="off" disabled>
                <div id="municipios-suggestions" class="suggestions" role="listbox" aria-multiselectable="true" hidden></div>
              </div>
              <p class="helper-text" id="municipios-feedback">Selecione uma UF para listar munic√≠pios.</p>
            </div>
          </div>

          <div class="tag-list" id="municipios-tags" aria-live="polite"></div>

          <div class="field-row">
            <div class="multiselect">
              <label for="cnae-input">CNAE (opcional)</label>
              <input id="cnae-input" type="text" class="multiselect-input" placeholder="Pesquise por c√≥digo ou descri√ß√£o do CNAE" autocomplete="off">
              <div id="cnae-suggestions" class="suggestions" role="listbox" aria-multiselectable="true" hidden></div>
              <p class="helper-text" id="cnae-feedback">Considere CNAE prim√°rio e secund√°rio. Use Enter para atualizar a lista.</p>
            </div>
          </div>
	  
          <div class="field-row">
            <div>
              <label for="filtro-setor">Grande Setor</label>
              <select id="filtro-setor">
                <option value="">Todos os Setores</option>
                </select>
            </div>
            <div>
              <label for="filtro-segmento">Segmento</label>
              <select id="filtro-segmento" disabled>
                <option value="">Selecione um Setor primeiro</option>
              </select>
            </div>
          </div>


          <div class="tag-list" id="cnae-tags" aria-live="polite"></div>

          <div class="field-row">
            <div>
              <label>Portes de empresa</label>
              <div class="checkbox-group" id="porte-checkboxes">
                <label><input type="checkbox" value="01"> 01 ¬∑ Micro Empresa (ME)</label>
                <label><input type="checkbox" value="03"> 03 ¬∑ Empresa de Pequeno Porte (EPP)</label>
                <label><input type="checkbox" value="05"> 05 ¬∑ Demais Empresas</label>
              </div>
            </div>
            <div>
              <label>Situa√ß√£o cadastral</label>
              <div class="checkbox-group" id="situacao-checkboxes">
                <span class="helper-text">Carregando op√ß√µes‚Ä¶</span>
              </div>
            </div>
          </div>

          <div class="actions">
            <button type="button" class="btn-ghost" id="cancelar-btn" disabled>Cancelar pesquisa</button>
            <div class="actions-right">
              <button type="button" class="btn-outline" id="limpar-btn">Limpar filtros</button>
              <button type="submit" class="btn-primary">Pesquisar empresas</button>
            </div>
          </div>
        </form>
      </section>

      <section class="card" aria-labelledby="resultados-titulo">
        <div class="card-header-row">
          <h2 id="resultados-titulo">Resultados</h2>
          <button type="button" class="btn-outline" id="exportar-btn" disabled>Exportar para Excel (CSV)</button>
        </div>
        <p id="status-count" class="status-count" aria-live="polite">Nenhum CNPJ encontrado at√© o momento.</p>
        <p id="status" class="status-message">Utilize os filtros acima para iniciar uma pesquisa.</p>
        <div class="table-wrapper">
          <table aria-describedby="resultados-titulo">
            <thead>
              <tr>
                <th>CNPJ completo</th>
                <th>Raz√£o social</th>
                <th>Endere√ßo completo</th>
                <th>CEP</th>
                <th>Telefone 01 com DDD</th>
                <th>Telefone 02 com DDD</th>
                <th>E-mail</th>
                <th>CNAE (apenas c√≥digo)</th>
                <th>Situa√ß√£o cadastral</th>
                <th>Motivo da situa√ß√£o cadastral</th>
              </tr>
            </thead>
            <tbody id="resultados-corpo">
              <tr class="empty-state">
                <td colspan="10">Utilize os filtros acima para iniciar uma pesquisa.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
    </section>



<section
  class="tab-panel"
  id="tab-estatistica"
  role="tabpanel"
  aria-labelledby="tab-btn-estatistica"
>
  <section class="card">
    <div class="card-header-row">
      <h2>Estat√≠sticas por Munic√≠pio (IBGE + Base CNPJ)</h2>
    </div>

    <p class="status-message" id="estatistica-status">
      Realize uma pesquisa na aba "Lista CNPJ" para habilitar esta vis√£o.
    </p>

    <div class="field-row">
      <div>
        <label>Contexto da an√°lise</label>
        <p class="helper-text" id="estatistica-contexto">‚Äî</p>
      </div>
      <div>
        <label for="estatistica-ano-select">Ano IBGE</label>
        <select id="estatistica-ano-select">
          <option value="">Ano mais recente dispon√≠vel</option>
        </select>
        <p class="helper-text">
          Fonte: IBGE / SIDRA ‚Äì Popula√ß√£o municipal (tabela 6579).
        </p>
      </div>
    </div>

    <p class="status-count" id="estatistica-resumo"></p>

    <div class="table-wrapper" style="max-height: 480px; overflow-y: auto;">
      <table>
        <thead>
          <tr>
            <th>Munic√≠pio</th>
            <th>UF</th>
            <th>Popula√ß√£o IBGE</th>
            <th>Qtd. Empresas (filtro atual)</th>
            <th>Empresas / 10 mil hab.</th>
          </tr>
        </thead>
        <tbody id="estatistica-corpo">
          <tr class="empty-state">
            <td colspan="5">
              Realize uma pesquisa na aba "Lista CNPJ" para carregar as estat√≠sticas.
            </td>
          </tr>
        </tbody>
      </table>
    </div>
  </section>
</section>



<section class="tab-panel" id="tab-divida" role="tabpanel" aria-labelledby="tab-btn-divida">
      <section class="card">
        <div class="card-header-row">
          <h2>Consulta de D√≠vida Ativa (PGFN)</h2>
        </div>

        <form id="divida-form">
          <div class="field-row">
            <div>
              <label for="divida-arquivo">Op√ß√£o A: Importar Arquivo CSV</label>
              <div class="file-input-group">
                <input type="file" id="divida-arquivo" accept=".csv,text/csv">
                <p class="helper-text">Selecione um arquivo contendo a coluna de CNPJs para verifica√ß√£o em lote.</p>
                <p class="helper-text" id="divida-arquivo-feedback"></p>
              </div>
            </div>
          </div>
          
          <div class="actions">
            <button type="button" class="btn-ghost" id="divida-limpar-btn">Limpar Dados</button>
            
            <div class="actions-right" style="display: flex; gap: 1rem; align-items: center;">
              <span id="divida-resumo-origem" class="status-count" style="font-size: 0.85rem; opacity: 0.8;"></span>
              
              <button type="button" class="btn-primary" id="divida-analisar-arquivo-btn" disabled>
                Analisar Arquivo Importado
              </button>

              <span style="color: #ccc;">|</span>

              <button type="button" class="btn-outline" id="divida-analisar-pesquisa-btn" disabled title="Realize uma pesquisa na aba Lista CNPJ primeiro">
                Usar Resultado da Pesquisa
              </button>
            </div>
          </div>
        </form>
      </section>

      <br>

      <section class="card">
        <div class="card-header-row">
          <h2 id="divida-titulo-resultado">Resultados da An√°lise</h2>
          <button type="button" class="btn-outline" id="divida-exportar-btn" disabled>Exportar Relat√≥rio (CSV)</button>
        </div>
        
        <p id="divida-status" class="status-message">Selecione uma fonte de dados acima (Arquivo ou Pesquisa) para iniciar.</p>
        
        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th>C√≥digo Externo</th> 
                <th>CNPJ</th>
                <th>Raz√£o Social</th> 
                <th>Situa√ß√£o D√≠vida (PGFN)</th>
                <th>Valor Total (R$)</th>
              </tr>
            </thead>
            <tbody id="divida-corpo">
              <tr class="empty-state"><td colspan="5">Aguardando comando...</td></tr>
            </tbody>
          </table>
        </div>
      </section>
    </section>

    <section class="tab-panel" id="tab-analises" role="tabpanel" aria-labelledby="tab-btn-analises">
      <section class="card" aria-labelledby="importacao-titulo">
        <div class="card-header-row">
          <h2 id="importacao-titulo">Analisar CNPJs inativos (d√≠vida ativa)</h2>
        </div>
        <form id="importacao-form">
          <div class="field-row">
            <div>
              <label for="importacao-arquivo">Arquivo CSV</label>
              <div class="file-input-group">
                <input type="file" id="importacao-arquivo" accept=".csv,text/csv">
                <p class="helper-text">Organize o arquivo com a coluna A para o c√≥digo do cliente, a coluna B para o CNPJ e, opcionalmente, as colunas C (UF) e D (Munic√≠pio).</p>
                <p class="helper-text" id="importacao-arquivo-feedback"></p>
              </div>
            </div>
          </div>
<div class="field-row">
  <div class="field-group">
    <label>Mapeamento de colunas do arquivo</label>
    <div class="field-row">
      <div>
        <label for="importacao-coluna-codigo">Coluna c√≥digo cliente</label>
        <input
          type="number"
          id="importacao-coluna-codigo"
          min="1"
          step="1"
          value="1"
          class="small-input"
        />
      </div>
      <div>
        <label for="importacao-coluna-cnpj">Coluna CNPJ/CPF</label>
        <input
          type="number"
          id="importacao-coluna-cnpj"
          min="1"
          step="1"
          value="2"
          class="small-input"
        />
      </div>
      <div>
        <label for="importacao-coluna-uf">Coluna UF</label>
        <input
          type="number"
          id="importacao-coluna-uf"
          min="1"
          step="1"
          value="3"
          class="small-input"
        />
      </div>
      <div>
        <label for="importacao-coluna-municipio">Coluna Munic√≠pio</label>
        <input
          type="number"
          id="importacao-coluna-municipio"
          min="1"
          step="1"
          value="4"
          class="small-input"
        />
      </div>
    </div>
    <p class="helper-text">
      Use n√∫meros de coluna (1 = primeira coluna do CSV). Se deixar em branco,
      o sistema usa o layout padr√£o.
    </p>
  </div>
</div>



          <div class="field-row">
            <div>
              <label for="importacao-uf-select">UF para an√°lise</label>
              <select id="importacao-uf-select" disabled>
                <option value="">Selecione uma UF reconhecida</option>
              </select>
              <p class="helper-text" id="importacao-uf-feedback">Carregue um arquivo para listar as UFs dispon√≠veis.</p>
            </div>
          </div>
          <div class="field-row">
            <div>
              <label for="importacao-uf-lista">CNPJs reconhecidos na UF selecionada</label>
              <div id="importacao-uf-lista" class="cnpj-list-wrapper empty" aria-live="polite">
                <span class="helper-text">Selecione uma UF acima para visualizar os CNPJs do arquivo.</span>
              </div>
            </div>
          </div>
          <div class="field-row">
            <div>
              <label for="importacao-municipios-lista">Munic√≠pios inclu√≠dos na an√°lise</label>
              <div class="selection-toolbar" id="importacao-municipios-acoes" hidden>
                <button type="button" class="btn-chip" id="importacao-municipios-selecionar-todos">Selecionar todos</button>
                <button type="button" class="btn-chip" id="importacao-municipios-selecionar-nenhum">Selecionar nenhum</button>
              </div>
              <div id="importacao-municipios-lista" class="checkbox-group municipios-checkboxes empty" role="group" aria-live="polite">
                <span class="helper-text">Carregue um arquivo para listar os munic√≠pios reconhecidos.</span>
              </div>
              <p class="helper-text" id="importacao-municipios-feedback">Carregue um arquivo para listar os munic√≠pios reconhecidos.</p>
            </div>
          </div>
          <div class="actions">
            <button type="button" class="btn-ghost" id="importacao-limpar-btn">Limpar entradas</button>
            <div class="actions-right">
              <button type="button" class="btn-outline" id="importacao-conciliar-municipios-btn" disabled>Conciliar munic√≠pios</button>
              <div id="importacao-resumo" class="status-count" aria-live="polite">Nenhum CNPJ informado.</div>
              <button type="submit" class="btn-primary">Analisar lista</button>
            </div>
          </div>
        </form>
      </section>

      <section class="card" aria-labelledby="importacao-resultados-titulo">
        <div class="card-header-row">
          <h2 id="importacao-resultados-titulo">Resultados da an√°lise</h2>
          <button type="button" class="btn-outline" id="importacao-exportar-btn" disabled>Exportar an√°lise (CSV)</button>
        </div>
        <p id="importacao-status" class="status-message" aria-live="polite">Carregue um arquivo para iniciar.</p>
        <p id="importacao-count" class="status-count">Nenhum resultado dispon√≠vel.</p>
        <div class="table-wrapper">
          <table aria-describedby="importacao-resultados-titulo" class="table-importacao">
            <thead>
              <tr>
                <th>C√≥digo externo</th>
                <th>CNPJ completo</th>
                <th>Raz√£o social</th>
                <th>√ìrg√£o</th>
                <th>Tipo situa√ß√£o inscri√ß√£o</th>
                <th>Situa√ß√£o inscri√ß√£o</th>
                <th>Receita principal</th>
                <th>Valor consolidado</th>
              </tr>
            </thead>
            <tbody id="importacao-corpo">
              <tr class="empty-state">
                <td colspan="8">Nenhum resultado dispon√≠vel.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <div id="importacao-municipios-modal" class="modal-overlay" hidden>
        <div class="modal" role="dialog" aria-modal="true" aria-labelledby="importacao-municipios-modal-titulo">
          <div class="modal-header">
            <h3 id="importacao-municipios-modal-titulo">Conciliar munic√≠pios</h3>
            <button type="button" class="modal-close" id="importacao-municipios-modal-fechar" aria-label="Fechar concilia√ß√£o de munic√≠pios">√ó</button>
          </div>
          <div class="modal-body">
            <p class="modal-description">Ajuste os munic√≠pios do arquivo para corresponder √†s op√ß√µes oficiais da base.</p>
            <p class="modal-status" id="importacao-municipios-modal-status"></p>
            <div class="modal-table-wrapper">
              <table class="modal-table" aria-describedby="importacao-municipios-modal-titulo">
                <thead>
                  <tr>
                    <th>UF</th>
                    <th>Munic√≠pio no arquivo</th>
                    <th>Quantidade</th>
                    <th>C√≥digo IBGE sugerido</th>
                    <th>Munic√≠pio oficial</th>
                  </tr>
                </thead>
                <tbody id="importacao-municipios-modal-corpo">
                  <tr class="modal-empty"><td colspan="5">Nenhum munic√≠pio dispon√≠vel para concilia√ß√£o.</td></tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn-ghost" id="importacao-municipios-modal-cancelar">Cancelar</button>
            <button type="button" class="btn-primary" id="importacao-municipios-modal-salvar">Aplicar concilia√ß√µes</button>
          </div>
        </div>
      </div>
    </section>

    <section class="tab-panel" id="tab-cobertura" role="tabpanel" aria-labelledby="tab-btn-cobertura">
      <section class="card" aria-labelledby="cobertura-form-titulo">
        <div class="card-header-row">
          <h2 id="cobertura-form-titulo">Cobertura de CNPJs</h2>
        </div>
        <form id="cobertura-form">
          <div class="field-row">
            <div>
              <label for="cobertura-arquivo">Arquivo CSV</label>
              <div class="file-input-group">
                <input type="file" id="cobertura-arquivo" accept=".csv,text/csv">
                <p class="helper-text">Colunas esperadas: C√≥digo externo, CNPJ, UF (opcional) e Munic√≠pio (opcional).</p>
                <p class="helper-text" id="cobertura-arquivo-feedback"></p>
              </div>
            </div>
          </div>

          <div class="actions">
            <div class="actions-left">
              <button type="button" class="btn-ghost" id="cobertura-limpar-btn">Limpar arquivo</button>
            </div>
            <div class="actions-right">
              <div id="cobertura-resumo" class="status-count" aria-live="polite">Nenhum CNPJ informado.</div>
              <button type="submit" class="btn-primary">Gerar cobertura</button>
            </div>
          </div>
        </form>
      </section>

      <section class="card" aria-labelledby="cobertura-resultados-titulo">
        <div class="card-header-row">
          <h2 id="cobertura-resultados-titulo">Resultados da cobertura</h2>
          <button type="button" class="btn-outline" id="cobertura-exportar-btn" disabled>Exportar cobertura (CSV)</button>
        </div>
        <p id="cobertura-status" class="status-message" aria-live="polite">Carregue um arquivo para iniciar a compara√ß√£o.</p>
        <p id="cobertura-count" class="status-count">Nenhum resultado dispon√≠vel.</p>
        <div class="table-wrapper">
          <table aria-describedby="cobertura-resultados-titulo">
            <thead>
              <tr>
                <th>Status</th>
                <th>CNPJ completo</th>
                <th>Raz√£o social</th>
                <th>Endere√ßo completo</th>
                <th>CEP</th>
                <th>Telefone 01 com DDD</th>
                <th>Telefone 02 com DDD</th>
                <th>E-mail</th>
                <th>CNAE (apenas c√≥digo)</th>
                <th>Situa√ß√£o cadastral</th>
                <th>Motivo da situa√ß√£o cadastral</th>
              </tr>
            </thead>
            <tbody id="cobertura-corpo">
              <tr class="empty-state">
                <td colspan="11">Nenhum resultado dispon√≠vel.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
    </section>

<section class="tab-panel" id="tab-rota" role="tabpanel" aria-labelledby="tab-btn-rota">
  <section class="card">
    <div class="card-header-row">
      <div>
        <h2 style="margin-bottom: 0.5rem;">Planejador de Rota e Log√≠stica</h2>
        <p class="helper-text" style="margin-top: 0; margin-bottom: 1rem; color: #5b6470;">
            Defina a ordem de visita. O sistema gera a rota: Cidade > Bairro (Prioridade) > Endere√ßo.
        </p>
      </div>
      
      <div style="display:flex; gap:10px; align-items:center;">
        <button type="button" class="btn-outline" id="rota-export-btn" title="Baixar planejamento atual (.json)" disabled>üì• Exportar Planejamento</button>
        <button type="button" class="btn-outline" onclick="document.getElementById('rota-import-file').click()" title="Carregar planejamento (.json)">üì§ Importar Planejamento</button>
        <input type="file" id="rota-import-file" accept=".json" style="display:none">
      </div>
    </div>

    <div style="background: #f8fafc; padding: 1rem; border-radius: 12px; border: 1px solid #e0e4ed; margin-bottom: 1.5rem;">
        <h4 style="margin-top:0; color: #b02232; font-size: 0.95rem;">1. Fonte de Dados</h4>
        
        <div style="display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 10px;">
            <label style="cursor: pointer; display: flex; align-items: center; gap: 8px; font-weight: 600;">
                <input type="radio" name="rota-fonte" value="pesquisa" checked>
                Usar Resultado da Pesquisa (Lista CNPJ)
            </label>
            <label style="cursor: pointer; display: flex; align-items: center; gap: 8px; font-weight: 600;">
                <input type="radio" name="rota-fonte" value="cobertura">
                Usar Resultado da Cobertura (Comparativo)
            </label>
        </div>

        <div id="rota-filtros-cobertura" style="display: none; padding-left: 28px; gap: 20px;">
            <label style="cursor: pointer; display: flex; align-items: center; gap: 6px;">
                <input type="checkbox" id="rota-check-atendidos" checked> Incluir Clientes (Atendidos)
            </label>
            <label style="cursor: pointer; display: flex; align-items: center; gap: 6px;">
                <input type="checkbox" id="rota-check-nao-atendidos" checked> Incluir Prospects (N√£o Atendidos)
            </label>
        </div>

        <p class="helper-text" id="rota-fonte-feedback" style="margin-top: 8px;">Selecione uma fonte acima.</p>
    </div>

    <div class="field-row">
        <div>
            <label for="rota-select-cidade">2. Selecionar Cidades (com Prioridade)</label>
            <select id="rota-select-cidade">
                <option value="">Carregue dados primeiro...</option>
            </select>
            <div id="rota-tags-cidades" class="tag-list" style="margin-top: 0.5rem; min-height: 38px; border: 1px dashed #e0e4ed; border-radius: 8px; padding: 5px;">
                <small style="color: #94a3b8; font-style: italic;">Arraste para reorganizar prioridade</small>
            </div>
        </div>

        <div>
            <label for="rota-select-bairro">3. Priorizar Bairros (Sequ√™ncia)</label>
            <select id="rota-select-bairro" disabled>
                <option value="">Selecione cidades primeiro...</option>
            </select>
            <div id="rota-tags-bairros" class="tag-list" style="margin-top: 0.5rem; min-height: 38px; border: 1px dashed #e0e4ed; border-radius: 8px; padding: 5px;">
                <small style="color: #94a3b8; font-style: italic;">Arraste para reorganizar prioridade</small>
            </div>
        </div>
    </div>

    <div style="margin-top: 1.5rem; border-top: 1px solid #eee; padding-top: 1rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
        <div style="display:flex; gap:10px; align-items:center; flex: 1; flex-wrap: wrap;">
             <!-- Provedor fixo: Google Maps -->
             <input type="hidden" id="rota-provedor-select" value="google">
             <input type="text" id="rota-origem" placeholder="Ponto de Partida (Opcional)" style="flex: 1; max-width: 250px;">
             <!-- Configura√ß√£o de tamanho das rotas -->
            <div style="display:flex; flex-direction:column; min-width: 160px;">
              <label for="rota-limite-clientes"
                     style="font-size: 0.75rem; font-weight: 600; letter-spacing: 0.06em; white-space: nowrap; color:#475569;">
                CLIENTES POR ROTA
              </label>
              <input
                type="number"
                id="rota-limite-clientes"
                min="1"
                max="100"
                value="10"
                style="padding: 0.35rem 0.5rem; border-radius: 8px; border: 1px solid #cbd5e1; font-size: 0.85rem; max-width: 80px;"
                title="Define o n√∫mero m√°ximo de clientes por rota gerada automaticamente"
              >
            </div>
             <button type="button" class="btn-primary" id="rota-gerar-btn" style="padding: 0.85rem 2rem; font-size: 1rem;">
                üìç Validar Endere√ßos
             </button>
        </div>

        <div style="text-align: right;">
            <span id="rota-contador" class="status-count">0 na rota</span>
        </div>
    </div>

    <!-- Filtro por Rota -->
    <div style="margin-top: 1rem; padding: 1rem; background: #f8fafc; border-radius: 8px; display: flex; align-items: center; gap: 10px;">
        <label for="rota-filtro-select" style="font-weight: 600; color: #475569;">Filtrar por Rota:</label>
        <select id="rota-filtro-select" style="padding: 0.5rem; border-radius: 6px; border: 1px solid #cbd5e1; min-width: 200px;">
            <option value="">Todas as Rotas</option>
        </select>
        <span id="rota-filtro-contador" style="color: #64748b; font-size: 0.9rem;"></span>
    </div>

    <div id="rota-links-container" class="selection-toolbar" style="margin: 1rem 0; width: 100%;"></div>

    <div class="table-wrapper" style="max-height: 500px; overflow-y: auto;">
      <table id="tabela-rota">
        <thead>
          <tr>
            <th style="width: 140px;">Rota</th>
            <th style="width: 60px;">Ordem</th>
            <th>Raz√£o Social</th>
            <th>Endere√ßo</th>
            <th>Bairro</th>
            <th>Cidade</th>
            <th style="width: 80px; text-align: center;">Status</th>
            <th style="width: 100px; text-align: center;">A√ß√µes</th>
          </tr>
        </thead>
        <tbody id="rota-corpo">
          <tr class="empty-state"><td colspan="8">Aguardando configura√ß√£o...</td></tr>
        </tbody>
      </table>
    </div>

    <div style="margin-top: 10px; display: flex; gap: 15px; font-size: 0.8rem; color: #666;">
        <div style="display: flex; align-items: center; gap: 5px;">
            <span style="color: #22c55e; font-weight: bold;">‚úî</span>
            <span>Endere√ßo Validado no Google Maps</span>
        </div>
        <div style="display: flex; align-items: center; gap: 5px;">
            <span style="color: #ef4444; font-weight: bold;">‚úñ</span>
            <span>Endere√ßo n√£o encontrado (exclu√≠do da rota)</span>
        </div>
    </div>
  </section>
</section>

  </main>

  <div id="cobertura-municipios-modal" class="modal-overlay" hidden>
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="cobertura-municipios-modal-titulo">
      <div class="modal-header">
        <h3 id="cobertura-municipios-modal-titulo">Validar munic√≠pios</h3>
        <button type="button" class="modal-close" id="cobertura-municipios-modal-fechar" aria-label="Fechar janela de valida√ß√£o">√ó</button>
      </div>
      <div class="modal-body">
        <p id="cobertura-municipios-modal-status" class="modal-status">Revise os munic√≠pios encontrados no arquivo e alinhe com a base antes de comparar.</p>
        <div class="modal-table-wrapper" aria-live="polite">
          <table class="modal-table">
            <thead>
              <tr>
                <th scope="col">UF</th>
                <th scope="col">Munic√≠pio no arquivo</th>
                <th scope="col">Munic√≠pio na base</th>
                <th scope="col">C√≥digo IBGE</th>
                <th scope="col">Registros</th>
              </tr>
            </thead>
            <tbody id="cobertura-municipios-modal-corpo">
              <tr class="modal-empty">
                <td colspan="5">Nenhum munic√≠pio dispon√≠vel para valida√ß√£o.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn-ghost" id="cobertura-municipios-modal-cancelar">Cancelar</button>
        <button type="button" class="btn-primary" id="cobertura-municipios-modal-salvar">Aplicar mapeamento</button>
      </div>
    </div>
  </div>

  <!-- Modal para visualizar o Mapa da Rota -->
  <div id="rota-mapa-modal" class="modal-overlay" hidden>
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="rota-mapa-modal-titulo" style="max-width: 900px;">
      <div class="modal-header">
        <h3 id="rota-mapa-modal-titulo">üó∫Ô∏è Mapa da Rota</h3>
        <button type="button" class="modal-close" id="rota-mapa-modal-fechar" aria-label="Fechar">√ó</button>
      </div>
      <div class="modal-body">
        <p id="rota-mapa-resumo" class="helper-text" style="margin-bottom: 0.75rem;">
          Visualize a sequ√™ncia dos clientes desta rota diretamente no mapa.
        </p>
        <div
          id="rota-mapa"
          style="
            width: 100%;
            height: 500px;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid #e2e8f0;
          "
        ></div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn-ghost" id="rota-mapa-modal-cancelar">Fechar</button>
      </div>
    </div>
  </div>

  <!-- Modal para Criar Nova Rota -->
  <div id="rota-nova-modal" class="modal-overlay" hidden>
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="rota-nova-modal-titulo" style="max-width: 500px;">
      <div class="modal-header">
        <h3 id="rota-nova-modal-titulo">‚ûï Criar Nova Rota</h3>
        <button type="button" class="modal-close" id="rota-nova-modal-fechar" aria-label="Fechar">√ó</button>
      </div>
      <div class="modal-body">
        <label for="rota-nova-nome" style="display:block; margin-bottom:0.5rem; font-weight:600; color:var(--gf2-muted); text-transform:uppercase; font-size:0.8rem; letter-spacing:0.05em;">Nome da Rota</label>
        <input type="text" id="rota-nova-nome" placeholder="Digite o nome da rota (ex: CENTRO, ZONA SUL)" style="width:100%; padding:0.75rem 1rem; border-radius:12px; border:1px solid var(--gf2-border); font-size:0.95rem; background:var(--gf2-neutral);">
        <p class="helper-text" style="margin-top:0.5rem; font-size:0.8rem; color:var(--gf2-muted);">O nome ser√° convertido para mai√∫sculas automaticamente.</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn-ghost" id="rota-nova-modal-cancelar">Cancelar</button>
        <button type="button" class="btn-primary" id="rota-nova-modal-confirmar">Criar Rota</button>
      </div>
    </div>
  </div>

  <script>
const UF_LIST = [
      { sigla: 'AC', nome: 'Acre' },
      { sigla: 'AL', nome: 'Alagoas' },
      { sigla: 'AP', nome: 'Amap√°' },
      { sigla: 'AM', nome: 'Amazonas' },
      { sigla: 'BA', nome: 'Bahia' },
      { sigla: 'CE', nome: 'Cear√°' },
      { sigla: 'DF', nome: 'Distrito Federal' },
      { sigla: 'ES', nome: 'Esp√≠rito Santo' },
      { sigla: 'GO', nome: 'Goi√°s' },
      { sigla: 'MA', nome: 'Maranh√£o' },
      { sigla: 'MT', nome: 'Mato Grosso' },
      { sigla: 'MS', nome: 'Mato Grosso do Sul' },
      { sigla: 'MG', nome: 'Minas Gerais' },
      { sigla: 'PA', nome: 'Par√°' },
      { sigla: 'PB', nome: 'Para√≠ba' },
      { sigla: 'PR', nome: 'Paran√°' },
      { sigla: 'PE', nome: 'Pernambuco' },
      { sigla: 'PI', nome: 'Piau√≠' },
      { sigla: 'RJ', nome: 'Rio de Janeiro' },
      { sigla: 'RN', nome: 'Rio Grande do Norte' },
      { sigla: 'RS', nome: 'Rio Grande do Sul' },
      { sigla: 'RO', nome: 'Rond√¥nia' },
      { sigla: 'RR', nome: 'Roraima' },
      { sigla: 'SC', nome: 'Santa Catarina' },
      { sigla: 'SP', nome: 'S√£o Paulo' },
      { sigla: 'SE', nome: 'Sergipe' },
      { sigla: 'TO', nome: 'Tocantins' }
    ];

    // [FRONTEND-GF2] - Mapeamento Global de UF (Corre√ß√£o de Escopo)
    // Cria um √≠ndice para converter nomes (ex: "S√£o Paulo") em siglas (ex: "SP")
    // √Årea: Auxiliar / Dados Est√°ticos
    const UF_MAP_NOME_PARA_SIGLA = new Map(
      UF_LIST.map(({ sigla, nome }) => [
        nome
          .normalize('NFD')
          .replace(/[\u0300-\u036f]/g, '') // Remove acentos
          .toUpperCase(),                  // Padroniza para mai√∫sculas
        sigla
      ])
    );

    const API_BASE_URL = (() => {
      const configurado = typeof window !== 'undefined' && typeof window.API_BASE_URL === 'string'
        ? window.API_BASE_URL.trim()
        : '';
      if (configurado) {
        return configurado.replace(/\/+$/, '');
      }

      const { protocol, hostname, port } = window.location;
      if (protocol === 'file:') {
        return 'http://localhost:3000';
      }

      if ((hostname === 'localhost' || hostname === '127.0.0.1' || hostname === '::1') && port && port !== '3000') {
        return `${protocol}//${hostname}:3000`;
      }

      const portaNormalizada = port ? `:${port}` : '';
      return `${protocol}//${hostname}${portaNormalizada}`;
    })();

    // =====================================================
    // SISTEMA DE MODAIS E NOTIFICA√á√ïES PERSONALIZADAS
    // =====================================================

    // Fun√ß√£o para exibir alertas personalizados (substitui window.alert)
    function mostrarAlerta(mensagem, titulo = '‚ö†Ô∏è Aviso') {
      return new Promise((resolve) => {
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'modal-overlay';
        modalOverlay.style.display = 'flex';
        modalOverlay.style.position = 'fixed';
        modalOverlay.style.top = '0';
        modalOverlay.style.left = '0';
        modalOverlay.style.width = '100%';
        modalOverlay.style.height = '100%';
        modalOverlay.style.backgroundColor = 'rgba(0,0,0,0.5)';
        modalOverlay.style.zIndex = '9999';
        modalOverlay.style.alignItems = 'center';
        modalOverlay.style.justifyContent = 'center';

        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.style.background = '#fff';
        modal.style.borderRadius = '16px';
        modal.style.padding = '2rem';
        modal.style.maxWidth = '500px';
        modal.style.width = '90%';
        modal.style.boxShadow = '0 10px 40px rgba(0,0,0,0.3)';

        const modalHeader = document.createElement('div');
        modalHeader.style.marginBottom = '1.5rem';
        modalHeader.innerHTML = `<h3 style="margin:0; color: var(--gf2-red); font-size: 1.25rem;">${titulo}</h3>`;

        const modalBody = document.createElement('div');
        modalBody.style.marginBottom = '1.5rem';
        modalBody.style.whiteSpace = 'pre-wrap';
        modalBody.style.lineHeight = '1.6';
        modalBody.textContent = mensagem;

        const modalFooter = document.createElement('div');
        modalFooter.style.display = 'flex';
        modalFooter.style.justifyContent = 'flex-end';
        modalFooter.style.gap = '0.5rem';

        const btnOk = document.createElement('button');
        btnOk.textContent = 'OK';
        btnOk.className = 'btn-primary';
        btnOk.style.padding = '0.5rem 1.5rem';
        btnOk.style.background = 'var(--gf2-red)';
        btnOk.style.color = '#fff';
        btnOk.style.border = 'none';
        btnOk.style.borderRadius = '8px';
        btnOk.style.cursor = 'pointer';
        btnOk.style.fontWeight = '600';

        btnOk.onclick = () => {
          document.body.removeChild(modalOverlay);
          resolve(true);
        };

        modalFooter.appendChild(btnOk);
        modal.appendChild(modalHeader);
        modal.appendChild(modalBody);
        modal.appendChild(modalFooter);
        modalOverlay.appendChild(modal);
        document.body.appendChild(modalOverlay);

        // Foco no bot√£o OK
        setTimeout(() => btnOk.focus(), 100);
      });
    }

    // Fun√ß√£o para exibir confirma√ß√µes personalizadas (substitui window.confirm)
    function mostrarConfirmacao(mensagem, titulo = '‚ùì Confirma√ß√£o') {
      return new Promise((resolve) => {
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'modal-overlay';
        modalOverlay.style.display = 'flex';
        modalOverlay.style.position = 'fixed';
        modalOverlay.style.top = '0';
        modalOverlay.style.left = '0';
        modalOverlay.style.width = '100%';
        modalOverlay.style.height = '100%';
        modalOverlay.style.backgroundColor = 'rgba(0,0,0,0.5)';
        modalOverlay.style.zIndex = '9999';
        modalOverlay.style.alignItems = 'center';
        modalOverlay.style.justifyContent = 'center';

        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.style.background = '#fff';
        modal.style.borderRadius = '16px';
        modal.style.padding = '2rem';
        modal.style.maxWidth = '500px';
        modal.style.width = '90%';
        modal.style.boxShadow = '0 10px 40px rgba(0,0,0,0.3)';

        const modalHeader = document.createElement('div');
        modalHeader.style.marginBottom = '1.5rem';
        modalHeader.innerHTML = `<h3 style="margin:0; color: var(--gf2-red); font-size: 1.25rem;">${titulo}</h3>`;

        const modalBody = document.createElement('div');
        modalBody.style.marginBottom = '1.5rem';
        modalBody.style.whiteSpace = 'pre-wrap';
        modalBody.style.lineHeight = '1.6';
        modalBody.textContent = mensagem;

        const modalFooter = document.createElement('div');
        modalFooter.style.display = 'flex';
        modalFooter.style.justifyContent = 'flex-end';
        modalFooter.style.gap = '0.5rem';

        const btnCancelar = document.createElement('button');
        btnCancelar.textContent = 'Cancelar';
        btnCancelar.className = 'btn-ghost';
        btnCancelar.style.padding = '0.5rem 1.5rem';
        btnCancelar.style.background = 'transparent';
        btnCancelar.style.color = 'var(--gf2-muted)';
        btnCancelar.style.border = '1px solid var(--gf2-border)';
        btnCancelar.style.borderRadius = '8px';
        btnCancelar.style.cursor = 'pointer';
        btnCancelar.style.fontWeight = '600';

        btnCancelar.onclick = () => {
          document.body.removeChild(modalOverlay);
          resolve(false);
        };

        const btnConfirmar = document.createElement('button');
        btnConfirmar.textContent = 'Confirmar';
        btnConfirmar.className = 'btn-primary';
        btnConfirmar.style.padding = '0.5rem 1.5rem';
        btnConfirmar.style.background = 'var(--gf2-red)';
        btnConfirmar.style.color = '#fff';
        btnConfirmar.style.border = 'none';
        btnConfirmar.style.borderRadius = '8px';
        btnConfirmar.style.cursor = 'pointer';
        btnConfirmar.style.fontWeight = '600';

        btnConfirmar.onclick = () => {
          document.body.removeChild(modalOverlay);
          resolve(true);
        };

        modalFooter.appendChild(btnCancelar);
        modalFooter.appendChild(btnConfirmar);
        modal.appendChild(modalHeader);
        modal.appendChild(modalBody);
        modal.appendChild(modalFooter);
        modalOverlay.appendChild(modal);
        document.body.appendChild(modalOverlay);

        // Foco no bot√£o confirmar
        setTimeout(() => btnConfirmar.focus(), 100);
      });
    }

    function adicionarParametro(url, chave, valor) {
      if (valor === undefined || valor === null) {
        return;
      }

      if (Array.isArray(valor)) {
        valor.forEach(item => adicionarParametro(url, chave, item));
        return;
      }

      url.searchParams.append(chave, valor);
    }

    function aplicarParametros(url, parametros) {
      if (!parametros) {
        return;
      }

      if (parametros instanceof URLSearchParams) {
        parametros.forEach((valor, chave) => {
          url.searchParams.append(chave, valor);
        });
        return;
      }

      if (parametros instanceof Map) {
        parametros.forEach((valor, chave) => {
          adicionarParametro(url, chave, valor);
        });
        return;
      }

      if (Array.isArray(parametros)) {
        parametros.forEach(entrada => {
          if (Array.isArray(entrada) && entrada.length >= 2) {
            adicionarParametro(url, entrada[0], entrada[1]);
          }
        });
        return;
      }

      if (typeof parametros === 'object') {
        Object.entries(parametros).forEach(([chave, valor]) => {
          adicionarParametro(url, chave, valor);
        });
      }
    }

    function construirUrlApi(caminho, parametros) {
      const base = API_BASE_URL.endsWith('/') ? API_BASE_URL : `${API_BASE_URL}/`;
      const caminhoNormalizado = String(caminho || '').replace(/^\/+/, '');
      const url = new URL(caminhoNormalizado, base);
      aplicarParametros(url, parametros);
      return url;
    }

    function apiFetch(caminho, { parametros, ...opcoes } = {}) {
      const url = construirUrlApi(caminho, parametros);
      return fetch(url.toString(), opcoes);
    }

    const ufSelect = document.getElementById('uf-select');
    const municipiosInput = document.getElementById('municipios-input');
    const municipiosSuggestions = document.getElementById('municipios-suggestions');
    const municipiosTags = document.getElementById('municipios-tags');
    const municipiosFeedback = document.getElementById('municipios-feedback');
    const municipiosMultiselect = municipiosInput.closest('.multiselect');
    const cnaeInput = document.getElementById('cnae-input');
    const cnaeSuggestions = document.getElementById('cnae-suggestions');
    const cnaeTags = document.getElementById('cnae-tags');
    const cnaeFeedback = document.getElementById('cnae-feedback');
    const cnaeMultiselect = cnaeInput.closest('.multiselect');
    const porteCheckboxes = document.getElementById('porte-checkboxes');
    const situacaoCheckboxes = document.getElementById('situacao-checkboxes');
    const filtrosForm = document.getElementById('filtros-form');
    const limparBtn = document.getElementById('limpar-btn');
    const atualizarOpcoesBtn = document.getElementById('atualizar-opcoes-btn');
    const cancelarBtn = document.getElementById('cancelar-btn');
    const exportarBtn = document.getElementById('exportar-btn');
    const statusMessage = document.getElementById('status');
    const statusCount = document.getElementById('status-count');
    const resultadosCorpo = document.getElementById('resultados-corpo');
    const tabButtons = document.querySelectorAll('.tab[role="tab"]');
    const tabPanels = document.querySelectorAll('.tab-panel');
    const tabCoberturaBtn = document.getElementById('tab-btn-cobertura');
    const tabPesquisaBtn = document.getElementById('tab-btn-pesquisa');
    const importacaoForm = document.getElementById('importacao-form');
    const importacaoArquivoInput = document.getElementById('importacao-arquivo');
    const importacaoArquivoFeedback = document.getElementById('importacao-arquivo-feedback');
    const importacaoLimparBtn = document.getElementById('importacao-limpar-btn');
    const importacaoResumo = document.getElementById('importacao-resumo');
    const importacaoStatus = document.getElementById('importacao-status');
    const importacaoCount = document.getElementById('importacao-count');
    const importacaoCorpo = document.getElementById('importacao-corpo');
    const importacaoExportarBtn = document.getElementById('importacao-exportar-btn');
    const importacaoConciliarMunicipiosBtn = document.getElementById('importacao-conciliar-municipios-btn');
    const importacaoUfSelect = document.getElementById('importacao-uf-select');
    const importacaoUfFeedback = document.getElementById('importacao-uf-feedback');
    const importacaoUfLista = document.getElementById('importacao-uf-lista');
    const importacaoMunicipiosLista = document.getElementById('importacao-municipios-lista');
    const importacaoMunicipiosFeedback = document.getElementById('importacao-municipios-feedback');
    const importacaoMunicipiosAcoes = document.getElementById('importacao-municipios-acoes');
    const importacaoMunicipiosSelecionarTodosBtn = document.getElementById('importacao-municipios-selecionar-todos');
    const importacaoMunicipiosSelecionarNenhumBtn = document.getElementById('importacao-municipios-selecionar-nenhum');
    const importacaoSubmitBtn = importacaoForm ? importacaoForm.querySelector('button[type="submit"]') : null;
    const importacaoMunicipiosModal = document.getElementById('importacao-municipios-modal');
    const importacaoMunicipiosModalCorpo = document.getElementById('importacao-municipios-modal-corpo');
    const importacaoMunicipiosModalStatus = document.getElementById('importacao-municipios-modal-status');
    const importacaoMunicipiosModalSalvar = document.getElementById('importacao-municipios-modal-salvar');
    const importacaoMunicipiosModalCancelar = document.getElementById('importacao-municipios-modal-cancelar');
    const importacaoMunicipiosModalFechar = document.getElementById('importacao-municipios-modal-fechar');
    const coberturaForm = document.getElementById('cobertura-form');
    const coberturaArquivoInput = document.getElementById('cobertura-arquivo');
    const coberturaArquivoFeedback = document.getElementById('cobertura-arquivo-feedback');
    const coberturaUfSelect = document.getElementById('cobertura-uf-select');
    const coberturaMunicipiosInput = document.getElementById('cobertura-municipios-input');
    const coberturaMunicipiosSuggestions = document.getElementById('cobertura-municipios-suggestions');
    const coberturaMunicipiosTags = document.getElementById('cobertura-municipios-tags');
    const coberturaMunicipiosFeedback = document.getElementById('cobertura-municipios-feedback');
    const coberturaCnaeInput = document.getElementById('cobertura-cnae-input');
    const coberturaCnaeSuggestions = document.getElementById('cobertura-cnae-suggestions');
    const coberturaCnaeTags = document.getElementById('cobertura-cnae-tags');
    const coberturaCnaeFeedback = document.getElementById('cobertura-cnae-feedback');
    const coberturaMunicipiosMultiselect = coberturaMunicipiosInput ? coberturaMunicipiosInput.closest('.multiselect') : null;
    const coberturaCnaeMultiselect = coberturaCnaeInput ? coberturaCnaeInput.closest('.multiselect') : null;
    const coberturaResumo = document.getElementById('cobertura-resumo');
    const coberturaStatus = document.getElementById('cobertura-status');
    const coberturaCount = document.getElementById('cobertura-count');
    const coberturaCorpo = document.getElementById('cobertura-corpo');
    const coberturaExportarBtn = document.getElementById('cobertura-exportar-btn');
    const coberturaLimparBtn = document.getElementById('cobertura-limpar-btn');
    const coberturaSubmitBtn = coberturaForm ? coberturaForm.querySelector('button[type="submit"]') : null;
    const coberturaValidarMunicipiosBtn = document.getElementById('cobertura-validar-municipios-btn');
    const coberturaMunicipiosModal = document.getElementById('cobertura-municipios-modal');
    const coberturaMunicipiosModalCorpo = document.getElementById('cobertura-municipios-modal-corpo');
    const coberturaMunicipiosModalStatus = document.getElementById('cobertura-municipios-modal-status');
    const coberturaMunicipiosModalSalvar = document.getElementById('cobertura-municipios-modal-salvar');
    const coberturaMunicipiosModalCancelar = document.getElementById('cobertura-municipios-modal-cancelar');
    const coberturaMunicipiosModalFechar = document.getElementById('cobertura-municipios-modal-fechar');
    const setorSelect = document.getElementById('filtro-setor');
    const segmentoSelect = document.getElementById('filtro-segmento');
    const tabRotaBtn = document.getElementById('tab-btn-rota');
    const rotaGerarBtn = document.getElementById('rota-gerar-btn');
    const rotaLimiteClientesInput = document.getElementById('rota-limite-clientes');
    const rotaFiltroCidade = document.getElementById('rota-filtro-cidade');
    const rotaFiltroBairro = document.getElementById('rota-filtro-bairro');
    const rotaBairrosTags = document.getElementById('rota-bairros-tags'); // [NOVO]
    const rotaCorpo = document.getElementById('rota-corpo');
    const rotaContador = document.getElementById('rota-contador');
    const rotaToggleBtn = document.getElementById('rota-selecionar-todos');
const rotaFeedbackFonte = document.getElementById('rota-fonte-feedback');
const rotaSaveBtn = document.getElementById('rota-save-btn');
const rotaExportBtn = document.getElementById('rota-export-btn');
const rotaImportFile = document.getElementById('rota-import-file');
const rotaSavedSelect = document.getElementById('rota-saved-select');
const rotaLinksContainer = document.getElementById('rota-links-container');
const rotaBtnImportar = document.getElementById('rota-btn-importar-trigger'); // Novo ID para o bot√£o visual
const rotaInputsFonte = document.getElementsByName('rota-fonte');
const rotaFiltrosCoberturaDiv = document.getElementById('rota-filtros-cobertura');
const rotaSelectCidade = document.getElementById('rota-select-cidade');
const rotaTagsCidades = document.getElementById('rota-tags-cidades');
const rotaSelectBairro = document.getElementById('rota-select-bairro');
const rotaTagsBairros = document.getElementById('rota-tags-bairros');
const rotaCheckAtendidos = document.getElementById('rota-check-atendidos');
const rotaCheckNaoAtendidos = document.getElementById('rota-check-nao-atendidos');
    const rotaMapaModal = document.getElementById('rota-mapa-modal');
    const rotaMapaModalFechar = document.getElementById('rota-mapa-modal-fechar');
    const rotaMapaModalCancelar = document.getElementById('rota-mapa-modal-cancelar');
    const rotaMapaTitulo = document.getElementById('rota-mapa-modal-titulo');
    const rotaMapaResumo = document.getElementById('rota-mapa-resumo');


    let estadoRota = {
    dadosOriginais: [],     // Dados crus da fonte selecionada
    cidadesPrioridade: [],  // Array ordenado de cidades (ordem = prioridade)
    bairrosPrioridade: [],  // Array ordenado de bairros (ordem = prioridade)
    cidadesSelecionadas: new Set(), // Cidades selecionadas para filtro
    bairrosSelecionados: new Set(), // Bairros selecionados para filtro
    clientesFiltrados: [],  // Resultado ap√≥s filtros
    clientesSelecionadosIds: new Set(), // CNPJs marcados no checkbox
    rotasGeradas: [],       // Array de rotas geradas [{id, clientes: []}]
    rotasSalvas: {}         // Objeto para persist√™ncia { "Nome Rota": {estado} }
};
    let cacheCategoriasMercado = {};
    let selectedMunicipios = new Map();
    let selectedCnaes = new Map();
    let cnaeDebounce;
    let ultimoResultado = [];
    let rotaMapaInstancia = null;
    let rotaMapaCamada = null;

    function fecharRotaMapaModal() {
        if (!rotaMapaModal) return;
        rotaMapaModal.hidden = true;
    }

    if (rotaMapaModalFechar) {
        rotaMapaModalFechar.addEventListener('click', fecharRotaMapaModal);
    }
    if (rotaMapaModalCancelar) {
        rotaMapaModalCancelar.addEventListener('click', fecharRotaMapaModal);
    }
    if (rotaMapaModal) {
        rotaMapaModal.addEventListener('click', (evt) => {
            if (evt.target === rotaMapaModal) {
                fecharRotaMapaModal();
            }
        });
    }

    // Vari√°veis da aba Estat√≠stica
    const tabEstatisticaBtn = document.getElementById('tab-btn-estatistica');
    const estatisticaStatus = document.getElementById('estatistica-status');
    const estatisticaCorpo = document.getElementById('estatistica-corpo');
    const estatisticaResumo = document.getElementById('estatistica-resumo');
    const estatisticaAnoSelect = document.getElementById('estatistica-ano-select');
    const estatisticaContexto = document.getElementById('estatistica-contexto');
    let estatisticaUfAtual = null;
    const estatisticaCacheIbge = new Map();
    let currentFetchController = null;
    let municipiosCache = [];
    let cnaeCache = [];
    let ultimoCnaeTermo = null;
    let csvRegistros = [];
    let importacaoMunicipiosDePara = new Map();
    let importacaoMunicipiosDisponiveis = new Map();
    let importacaoMunicipiosSelecionadosPorUf = new Map();
    let importacaoMunicipiosSelecaoManual = new Set();
    let importacaoUfDisponiveis = new Map();
    let importacaoUfSelecionada = '';
    let importacaoCnpjsRemovidosPorUf = new Map();
    let ultimoImportacaoResultado = [];
    let coberturaRegistros = [];
    let coberturaMunicipiosSelecionados = new Map();
    let coberturaMunicipiosCache = [];
    let coberturaCnaeSelecionados = new Map();
    let coberturaCnaeCache = [];
    let coberturaUltimoCnaeTermo = null;
    let ultimoCoberturaResultado = [];
    let coberturaCnaeDebounce;
    let coberturaMunicipiosDePara = new Map();
    let coberturaResumoAtual = { lista: [], invalidos: [] };
    const MUNICIPIOS_CACHE_GLOBAL = new Map();
    const CNAE_CACHE_GLOBAL = new Map();
    const MUNICIPIOS_HELPER_BASE = 'Clique para adicionar um ou mais munic√≠pios da UF escolhida.';
    const CNAE_HELPER_BASE = 'Considere CNAE prim√°rio e secund√°rio. Use Enter para atualizar a lista.';
    const MUNICIPIOS_SUGESTOES_LIMITE = Infinity;
    const CNAE_SUGESTOES_LIMITE = 200;
    const formatadorNumero = new Intl.NumberFormat('pt-BR');
    const formatadorMoeda = new Intl.NumberFormat('pt-BR', {
      style: 'currency',
      currency: 'BRL'
    });
    const formatadorCapital = new Intl.NumberFormat('pt-BR', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    });
    function atualizarMunicipiosFeedback(mensagem) {
      if (mensagem) {
        municipiosFeedback.textContent = mensagem;
        return;
      }

      if (!ufSelect.value) {
        municipiosFeedback.textContent = 'Selecione uma UF para listar munic√≠pios.';
        return;
      }

      if (!municipiosCache.length) {
        municipiosFeedback.textContent = 'Nenhum munic√≠pio dispon√≠vel para a UF selecionada.';
        return;
      }

      if (selectedMunicipios.size === 0) {
        municipiosFeedback.textContent = MUNICIPIOS_HELPER_BASE;
        return;
      }

      const plural = selectedMunicipios.size === 1 ? '' : 's';
      municipiosFeedback.textContent = `${selectedMunicipios.size} munic√≠pio${plural} selecionado${plural}.`;
    }

    function atualizarCnaeFeedback(mensagem) {
      if (mensagem) {
        cnaeFeedback.textContent = mensagem;
        return;
      }

      if (selectedCnaes.size === 0) {
        cnaeFeedback.textContent = CNAE_HELPER_BASE;
        return;
      }

      const plural = selectedCnaes.size === 1 ? '' : 's';
      cnaeFeedback.textContent = `${selectedCnaes.size} CNAE${plural} selecionado${plural}.`;
    }

    function atualizarStatusCount(total) {
      if (total === 'loading') {
        statusCount.textContent = 'Processando pesquisa‚Ä¶';
        return;
      }

      if (typeof total !== 'number') {
        statusCount.textContent = 'Nenhum CNPJ encontrado at√© o momento.';
        return;
      }

      const plural = total === 1 ? '' : 's';
      statusCount.textContent = `${formatadorNumero.format(total)} CNPJ${plural} encontrado${plural}.`;
    }

    function normalizarTexto(texto) {
      return String(texto || '').normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
    }

    function normalizarCodigo(valor) {
      if (valor === null || valor === undefined) return '';
      return String(valor).trim();
    }

    function extrairCodigoExterno(item) {
      if (!item || typeof item !== 'object') return '';
      const candidatos = [
        item.codigo_externo,
        item.codigo,
        item.cod,
        item.id
      ];
      for (const valor of candidatos) {
        if (valor === null || valor === undefined) {
          continue;
        }
        const texto = String(valor).trim();
        if (texto) {
          return texto;
        }
      }
      return '';
    }

    function ajustarCnpjDigitos(digitos) {
      if (!digitos) return '';

      let resultado = digitos;

      while (resultado.length > 14 && resultado.startsWith('0')) {
        resultado = resultado.slice(1);
      }

      while (resultado.length > 14 && resultado.endsWith('0')) {
        resultado = resultado.slice(0, -1);
      }

      if (!resultado || resultado.length > 14) {
        return '';
      }

      return resultado.padStart(14, '0');
    }

    function normalizarCnpj(valor) {
      if (valor === null || valor === undefined) return null;
      const apenasNumeros = String(valor).replace(/\D+/g, '');
      if (!apenasNumeros) return null;
      const ajustado = ajustarCnpjDigitos(apenasNumeros);
      return ajustado || null;
    }

function normalizarUf(valor) {
  if (!valor) return '';
  let texto = String(valor).trim().toUpperCase();

  // Se j√° for sigla de 2 letras, OK
  if (/^[A-Z]{2}$/.test(texto)) return texto;

  // Tenta mapear nome completo de estado ‚Üí sigla
  const textoSemAcento = texto
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '');
  const sigla = UF_MAP_NOME_PARA_SIGLA.get(textoSemAcento);
  return sigla || '';
}

    function gerarChaveMunicipioDePara(uf, municipio) {
      const ufNormalizada = normalizarUf(uf) || '';
      const municipioNormalizado = normalizarTexto(municipio);
      return `${ufNormalizada || 'ALL'}|${municipioNormalizado}`;
    }

    function gerarChaveMunicipioImportacao(uf, municipio) {
      const ufNormalizada = normalizarUf(uf) || '';
      const municipioNormalizado = normalizarTexto(municipio);
      return `${ufNormalizada}|${municipioNormalizado || '__sem_municipio__'}`;
    }

    function limparMunicipioInformado(valor) {
      if (valor === null || valor === undefined) return '';
      return String(valor).trim();
    }

    function dividirLinhaPorDelimitador(linha, delimitador) {
      const valores = [];
      let atual = '';
      let dentroDeAspas = false;

      for (let i = 0; i < linha.length; i++) {
        const caractere = linha[i];

        if (caractere === '"') {
          if (dentroDeAspas && linha[i + 1] === '"') {
            atual += '"';
            i += 1;
          } else {
            dentroDeAspas = !dentroDeAspas;
          }
          continue;
        }

        if (caractere === delimitador && !dentroDeAspas) {
          valores.push(atual.trim());
          atual = '';
        } else {
          atual += caractere;
        }
      }

      valores.push(atual.trim());
      return valores.map(valor => valor.replace(/^"|"$/g, '').replace(/""/g, '"'));
    }

   function extrairItensDoCsv(conteudo) {
  if (!conteudo) return [];

  const linhas = conteudo
    .split(/\r?\n/)
    .map(linha => linha.trim())
    .filter(Boolean);

  if (!linhas.length) return [];

  const delimitadores = [';', ',', '\t'];
  let delimitador = delimitadores.find(del => linhas.some(linha => linha.includes(del))) || ';';

  const cabecalhoOriginal = dividirLinhaPorDelimitador(linhas[0], delimitador);
  const cabecalhoNormalizado = cabecalhoOriginal.map(valor =>
    normalizarTexto(valor).replace(/[^a-z0-9]/g, '')
  );

  // Detecta se a primeira linha parece um cabe√ßalho (ex.: cont√©m "cnpj")
  const possuiCabecalho = cabecalhoNormalizado.some(valor => valor.includes('cnpj'));
  const inicioDados = possuiCabecalho ? 1 : 0;

  // ===== NOVO: l√™ mapeamento manual de colunas (1,2,3,4 etc) =====
  const colunaInputCodigo = document.getElementById('importacao-coluna-codigo');
  const colunaInputCnpj = document.getElementById('importacao-coluna-cnpj');
  const colunaInputUf = document.getElementById('importacao-coluna-uf');
  const colunaInputMunicipio = document.getElementById('importacao-coluna-municipio');

  const parseIndice = (input, fallback) => {
    if (!input || !input.value) return fallback;
    const n = parseInt(input.value, 10);
    return Number.isFinite(n) && n >= 1 ? n - 1 : fallback; // converte 1-baseado ‚Üí 0-baseado
  };

  const overrideCodigo = parseIndice(colunaInputCodigo, null);
  const overrideCnpj = parseIndice(colunaInputCnpj, null);
  const overrideUf = parseIndice(colunaInputUf, null);
  const overrideMunicipio = parseIndice(colunaInputMunicipio, null);
  // ===============================================================

  const localizarIndice = (alternativas, padraoFallback) => {
    // Se n√£o tem cabe√ßalho, usa fallback (vai bater com o layout padr√£o A,B,C,D)
    if (!possuiCabecalho) return padraoFallback;
    for (const alternativa of alternativas) {
      const indice = cabecalhoNormalizado.findIndex(
        valor => valor === alternativa || valor.includes(alternativa)
      );
      if (indice >= 0) {
        return indice;
      }
    }
    return -1;
  };

  const indiceCodigo = (() => {
    if (overrideCodigo !== null) return overrideCodigo;
    const indice = localizarIndice(
      ['codigoexterno', 'codigo', 'cod', 'id', 'codigoarquivo', 'codigoempresa'],
      0
    );
    if (indice >= 0) return indice;
    return localizarIndice(['cliente', 'numero'], 0);
  })();

  const indiceCnpj = (() => {
    if (overrideCnpj !== null) return overrideCnpj;
    const indice = localizarIndice(
      ['cnpj', 'cnpjbase', 'cnpjcompleto', 'doc', 'documento', 'cnpjcliente'],
      1
    );
    if (indice >= 0) return indice;
    return 1; // fallback padr√£o para arquivos sem cabe√ßalho
  })();

  const indiceUf = (() => {
    if (overrideUf !== null) return overrideUf;
    const indice = localizarIndice(
      ['uf', 'estado', 'ufcidade', 'ufarquivo', 'ufcliente'],
      2
    );
    if (indice >= 0) return indice;
    return 2;
  })();

  const indiceMunicipio = (() => {
    if (overrideMunicipio !== null) return overrideMunicipio;
    const indice = localizarIndice(
      ['municipio', 'municipios', 'cidade', 'mun', 'municipioarquivo', 'municipioibge'],
      3
    );
    if (indice >= 0) return indice;
    return 3;
  })();

  const registros = [];

  for (let indice = inicioDados; indice < linhas.length; indice++) {
    const valores = dividirLinhaPorDelimitador(linhas[indice], delimitador);
    if (!valores.length) continue;

    const codigo =
      indiceCodigo >= 0 && indiceCodigo < valores.length ? valores[indiceCodigo] ?? '' : '';
    const cnpj =
      indiceCnpj >= 0 && indiceCnpj < valores.length
        ? valores[indiceCnpj] ?? valores[0] ?? ''
        : valores[0] ?? '';
    const uf =
      indiceUf >= 0 && indiceUf < valores.length ? valores[indiceUf] ?? '' : '';
    const municipio =
      indiceMunicipio >= 0 && indiceMunicipio < valores.length
        ? valores[indiceMunicipio] ?? ''
        : '';

    registros.push({
      codigo_externo: codigo.trim(),
      cnpj: cnpj.trim(),
      uf: uf.trim(),
      municipio: municipio.trim(),
      municipio_original: municipio.trim(),
      linha: indice + 1,
      origem: 'csv'
    });
  }

  return registros;
}


   // [FRONTEND-GF2] - Fun√ß√£o de Inicializa√ß√£o de UI
    function popularUFs() {
      UF_LIST.forEach(({ sigla, nome }) => {
        // REMOVED: The const UF_MAP_NOME_PARA_SIGLA... block was deleted from here.
        
        const option = document.createElement('option');
        option.value = sigla;
        option.textContent = `${sigla} ¬∑ ${nome}`;
        ufSelect.append(option);

        if (coberturaUfSelect) {
          const coberturaOption = document.createElement('option');
          coberturaOption.value = sigla;
          coberturaOption.textContent = `${sigla} ¬∑ ${nome}`;
          coberturaUfSelect.append(coberturaOption);
        }
      });
    }

    async function carregarSituacoes({ manterSelecao = false } = {}) {
      const selecionadasAntes = manterSelecao
        ? coletarValoresCheckbox(situacaoCheckboxes).map(valor => String(valor))
        : [];

      situacaoCheckboxes.innerHTML = '<span class="helper-text">Carregando op√ß√µes‚Ä¶</span>';

      try {
        const response = await apiFetch('/situacoes-cadastrais', {
          parametros: { _: Date.now() },
          cache: 'no-store'
        });
        if (!response.ok) throw new Error('Erro ao carregar situa√ß√µes');
        const dados = await response.json();
        if (!Array.isArray(dados) || dados.length === 0) {
          situacaoCheckboxes.innerHTML = '<span class="helper-text">Nenhuma situa√ß√£o cadastral dispon√≠vel.</span>';
          return false;
        }

        situacaoCheckboxes.innerHTML = '';
        dados.forEach(({ codigo, descricao }) => {
          const label = document.createElement('label');
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.value = codigo;
          if (manterSelecao && selecionadasAntes.includes(String(codigo))) {
            checkbox.checked = true;
          }
          label.append(checkbox, `${codigo} ¬∑ ${descricao}`);
          situacaoCheckboxes.append(label);
        });
        return true;
      } catch (error) {
        situacaoCheckboxes.innerHTML = '<span class="helper-text">N√£o foi poss√≠vel carregar as situa√ß√µes cadastrais.</span>';
        console.error(error);
        return false;
      }
    }

    function atualizarMunicipiosTags() {
      municipiosTags.innerHTML = '';

      if (selectedMunicipios.size === 0) {
        atualizarMunicipiosFeedback();
        renderMunicipiosSugestoes();
        return;
      }

      for (const [codigo, descricao] of selectedMunicipios.entries()) {
        const tag = document.createElement('span');
        tag.className = 'tag';
        tag.textContent = descricao;

        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.setAttribute('aria-label', `Remover munic√≠pio ${descricao}`);
        removeBtn.textContent = '√ó';
        removeBtn.addEventListener('click', () => {
          selectedMunicipios.delete(codigo);
          atualizarMunicipiosTags();
          renderMunicipiosSugestoes();
        });

        tag.append(removeBtn);
        municipiosTags.append(tag);
      }

      atualizarMunicipiosFeedback();
      renderMunicipiosSugestoes();
    }

    function renderMunicipiosSugestoes() {
      const aberto = municipiosMultiselect.classList.contains('open');

      if (!municipiosCache.length) {
        if (aberto) {
          municipiosSuggestions.innerHTML = '<div class="suggestion-empty">Nenhum munic√≠pio dispon√≠vel.</div>';
          municipiosSuggestions.hidden = false;
        }
        return;
      }

      const termo = normalizarTexto(municipiosInput.value.trim());
      const filtrados = municipiosCache.filter(({ descricao, codigo }) => {
        if (!termo) return true;
        const base = `${normalizarTexto(descricao)} ${normalizarTexto(codigo)}`;
        return base.includes(termo);
      });

      const resultados = Number.isFinite(MUNICIPIOS_SUGESTOES_LIMITE)
        ? filtrados.slice(0, MUNICIPIOS_SUGESTOES_LIMITE)
        : filtrados;

      const scrollAnterior = municipiosSuggestions.scrollTop;
      municipiosSuggestions.innerHTML = '';

      if (resultados.length === 0) {
        const textoBusca = municipiosInput.value.trim();
        municipiosSuggestions.innerHTML = `<div class="suggestion-empty">Nenhum munic√≠pio encontrado para "${textoBusca}".</div>`;
        atualizarMunicipiosFeedback(textoBusca
          ? `Nenhum munic√≠pio encontrado para "${textoBusca}".`
          : 'Nenhum munic√≠pio dispon√≠vel para os crit√©rios selecionados.');
        if (aberto) {
          municipiosSuggestions.hidden = false;
        }
        return;
      }

      resultados.forEach(({ codigo, descricao }) => {
        const item = document.createElement('button');
        item.type = 'button';
        item.className = 'suggestion-item';
        item.dataset.codigo = codigo;
        if (selectedMunicipios.has(codigo)) {
          item.classList.add('selected');
        }
        const titulo = document.createElement('span');
        titulo.textContent = descricao;
        const meta = document.createElement('span');
        meta.className = 'suggestion-meta';
        meta.textContent = codigo;
        item.append(titulo, meta);
        item.addEventListener('click', () => {
          toggleMunicipio(codigo, descricao);
        });
        municipiosSuggestions.append(item);
      });

      if (municipiosInput.value.trim()) {
        const plural = resultados.length === 1 ? '' : 's';
        const selecionados = selectedMunicipios.size;
        const pluralSel = selecionados === 1 ? '' : 's';
        const trechoSelecionados = selecionados
          ? ` ${selecionados} munic√≠pio${pluralSel} selecionado${pluralSel}.`
          : '';
        municipiosFeedback.textContent = `${resultados.length} munic√≠pio${plural} correspondente${plural} ao filtro.${trechoSelecionados}`;
      } else {
        atualizarMunicipiosFeedback();
      }

      if (aberto) {
        municipiosSuggestions.hidden = false;
        municipiosSuggestions.scrollTop = scrollAnterior;
      }
    }

    function abrirMunicipiosSugestoes() {
      if (municipiosInput.disabled) return;
      municipiosMultiselect.classList.add('open');
      renderMunicipiosSugestoes();
    }

    function fecharMunicipiosSugestoes() {
      municipiosMultiselect.classList.remove('open');
      municipiosSuggestions.hidden = true;
    }

    function toggleMunicipio(codigo, descricao) {
      if (selectedMunicipios.has(codigo)) {
        selectedMunicipios.delete(codigo);
      } else {
        selectedMunicipios.set(codigo, descricao);
      }
      atualizarMunicipiosTags();
      renderMunicipiosSugestoes();
      municipiosInput.focus();
    }

    function atualizarCnaeTags() {
      cnaeTags.innerHTML = '';

      if (selectedCnaes.size === 0) {
        atualizarCnaeFeedback();
        renderCnaeSugestoes();
        return;
      }

      for (const [codigo, descricao] of selectedCnaes.entries()) {
        const tag = document.createElement('span');
        tag.className = 'tag';
        tag.textContent = `${codigo} ¬∑ ${descricao}`;

        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.setAttribute('aria-label', `Remover CNAE ${codigo}`);
        removeBtn.textContent = '√ó';
        removeBtn.addEventListener('click', () => {
          selectedCnaes.delete(codigo);
          atualizarCnaeTags();
        });

        tag.append(removeBtn);
        cnaeTags.append(tag);
      }

      atualizarCnaeFeedback();
      renderCnaeSugestoes();
    }

    async function obterMunicipiosPorUf(uf, { ignorarCache = false } = {}) {
      if (!uf) return [];
      const chave = uf.toUpperCase();

      if (!ignorarCache && MUNICIPIOS_CACHE_GLOBAL.has(chave)) {
        return MUNICIPIOS_CACHE_GLOBAL.get(chave);
      }

      const response = await apiFetch('/municipios', {
        parametros: { uf: chave, _: Date.now() },
        cache: 'no-store'
      });
      if (!response.ok) {
        throw new Error('Erro ao carregar munic√≠pios');
      }

      const dados = await response.json();
      const lista = Array.isArray(dados)
        ? dados.map(item => ({ codigo: item.codigo, descricao: item.descricao }))
        : [];

      MUNICIPIOS_CACHE_GLOBAL.set(chave, lista);
      return lista;
    }

    async function obterCnaesPorTermo(termo = '', { ignorarCache = false } = {}) {
      const texto = String(termo || '').trim();
      const chave = texto.toLowerCase();

      if (!ignorarCache && CNAE_CACHE_GLOBAL.has(chave)) {
        return CNAE_CACHE_GLOBAL.get(chave);
      }

      const parametros = { _: Date.now() };
      if (texto) {
        parametros.busca = texto;
      }

      const response = await apiFetch('/cnaes', {
        parametros,
        cache: 'no-store'
      });
      if (!response.ok) {
        throw new Error('Erro ao listar CNAEs');
      }

      const dados = await response.json();
      const lista = Array.isArray(dados)
        ? dados.map(item => ({ codigo: item.codigo, descricao: item.descricao }))
        : [];

      CNAE_CACHE_GLOBAL.set(chave, lista);
      return lista;
    }

    async function buscarMunicipios(uf, { manterSelecao = false, manterBusca = false, forcarAtualizacao = false } = {}) {
      fecharMunicipiosSugestoes();

      const selecaoAnterior = manterSelecao ? new Map(selectedMunicipios) : new Map();
      const buscaAnterior = manterBusca ? municipiosInput.value : '';

      if (!manterSelecao) {
        selectedMunicipios.clear();
      }

      if (!manterBusca) {
        municipiosInput.value = '';
      }

      municipiosCache = [];
      municipiosInput.disabled = true;
      atualizarMunicipiosTags();
      atualizarMunicipiosFeedback(uf ? 'Carregando munic√≠pios‚Ä¶' : 'Selecione uma UF para listar munic√≠pios.');
      municipiosSuggestions.innerHTML = '';

      if (!uf) {
        return true;
      }

      try {
        const dados = await obterMunicipiosPorUf(uf, { ignorarCache: forcarAtualizacao });

        municipiosCache = Array.isArray(dados) ? [...dados] : [];

        if (municipiosCache.length === 0) {
          atualizarMunicipiosFeedback('Nenhum munic√≠pio encontrado para a UF selecionada.');
          return false;
        }

        if (manterSelecao) {
          const novosSelecionados = new Map();
          for (const [codigo, descricao] of selecaoAnterior.entries()) {
            if (municipiosCache.some(m => m.codigo === codigo)) {
              novosSelecionados.set(codigo, descricao);
            }
          }
          selectedMunicipios = novosSelecionados;
        }

        if (manterBusca) {
          municipiosInput.value = buscaAnterior;
        }

        municipiosInput.disabled = false;
        atualizarMunicipiosTags();
        atualizarMunicipiosFeedback();
        renderMunicipiosSugestoes();
        return true;
      } catch (error) {
        console.error(error);
        atualizarMunicipiosFeedback('N√£o foi poss√≠vel carregar os munic√≠pios. Tente novamente.');
        municipiosSuggestions.innerHTML = '<div class="suggestion-empty">N√£o foi poss√≠vel carregar os munic√≠pios.</div>';
        return false;
      }
    }

    function formatarTelefone(ddd, numero) {
      if (!ddd && !numero) return '';
      const limpo = String(numero || '').replace(/\D+/g, '');
      if (!ddd && !limpo) return '';
      return `(${ddd || '--'}) ${limpo}`.trim();
    }

    function montarEndereco(linha) {
      const partes = [linha.logradouro, linha.numero, linha.complemento, linha.bairro, linha.municipio_nome || linha.municipio, linha.uf]
        .filter(Boolean)
        .map(parte => String(parte).trim());
      return partes.join(', ');
    }

    function formatarCnpjVisivel(valor) {
      const apenasDigitos = String(valor || '').replace(/\D+/g, '');
      if (apenasDigitos.length !== 14) return apenasDigitos;
      return apenasDigitos.replace(/(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})/, '$1.$2.$3/$4-$5');
    }

    function formatarCnaeVisivel(valor) {
      const apenasDigitos = String(valor || '').replace(/\D+/g, '');
      if (!apenasDigitos) return '';
      return apenasDigitos.padStart(7, '0');
    }

    function formatarCnpjParaCsv(valor) {
      if (!valor) return '';
      const apenasDigitos = String(valor).replace(/\D+/g, '').padStart(14, '0');
      return `="${apenasDigitos}"`;
    }

    function formatarCnaeParaCsv(valor) {
      if (!valor) return '';
      const apenasDigitos = String(valor).replace(/\D+/g, '').padStart(7, '0');
      return `="${apenasDigitos}"`;
    }

    function escaparCsv(valor) {
      return `"${String(valor ?? '').replace(/"/g, '""')}"`;
    }

    function limparResultados(mensagem = 'Utilize os filtros acima para iniciar uma pesquisa.') {
      ultimoResultado = [];
      exportarBtn.disabled = true;
      atualizarStatusCount(0);
      resultadosCorpo.innerHTML = `<tr class="empty-state"><td colspan="10">${mensagem}</td></tr>`;
      statusMessage.textContent = mensagem;
      prepararCoberturaParaNovaPesquisa(false);
      atualizarAbaCoberturaDisponibilidade();
    }

    function renderizarTabela(dados) {
      resultadosCorpo.innerHTML = '';
      dados.forEach(linha => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${linha.cnpj_completo || ''}</td>
          <td>${linha.razao_social || ''}</td>
          <td>${montarEndereco(linha)}</td>
          <td>${linha.cep || ''}</td>
          <td>${formatarTelefone(linha.ddd_1, linha.telefone_1)}</td>
          <td>${formatarTelefone(linha.ddd_2, linha.telefone_2)}</td>
          <td>${linha.correio_eletronico || ''}</td>
          <td>${linha.cnae_fiscal_principal || ''}</td>
          <td>${linha.situacao_cadastral_descricao || linha.situacao_cadastral || ''}</td>
          <td>${linha.motivo_situacao_cadastral_descricao || linha.motivo_situacao_cadastral || ''}</td>
        `;
        resultadosCorpo.append(tr);
      });
    }

function atualizarResultados(dados) {
      if (!Array.isArray(dados) || dados.length === 0) {
        limparResultados('Nenhum registro encontrado com os filtros informados.');
        return;
      }

      ultimoResultado = dados;
      exportarBtn.disabled = false;
      atualizarStatusCount(dados.length);
      statusMessage.textContent = 'Resultados atualizados com sucesso.';
      renderizarTabela(dados);
      atualizarEstadoBotaoPesquisa();
      prepararCoberturaParaNovaPesquisa(true);
      atualizarAbaCoberturaDisponibilidade();
      
      // Atualiza o Mapa
      if (typeof atualizarAbaMapa === 'function') {
          atualizarAbaMapa(); 
      }

      // [NOVO] Atualiza a Rota de Vendas (INSERIR AQUI)
      if (typeof atualizarAbaRota === 'function') {
          atualizarAbaRota();
      }

      // Sincroniza a aba "Rota de Vendas" com o novo resultado de pesquisa
      sincronizarRotaComListaCNPJ(dados);

      // [NOVO] Atualiza aba Estat√≠stica (IBGE + Segmentos)
      if (typeof atualizarAbaEstatistica === 'function') {
          atualizarAbaEstatistica();
      }

    }

    function sincronizarRotaComListaCNPJ(listaEmpresas) {
      if (!Array.isArray(listaEmpresas)) return;

      // Limpa o estado de rota baseado em pesquisa anterior
      estadoRota.dadosOriginais = listaEmpresas;
      estadoRota.cidadesPrioridade = [];
      estadoRota.bairrosPrioridade = [];
      estadoRota.clientesFiltrados = [];
      estadoRota.rotasGeradas = [];
      estadoRota.clientesSelecionadosIds = new Set();

      // Se existirem fun√ß√µes auxiliares para recarregar combos de cidade/bairro,
      // invoc√°-las aqui. Ajustar para os nomes reais j√° existentes no arquivo.
      if (typeof construirListaCidadesEBairros === 'function') {
        construirListaCidadesEBairros(listaEmpresas);
      }

      if (typeof atualizarContadorRota === 'function') {
        atualizarContadorRota(0);
      }

      if (rotaLinksContainer) {
        rotaLinksContainer.innerHTML = '';
      }
    }

    function consolidarRegistrosParaEnvio(registros) {
      const mapa = new Map();
      const invalidos = [];

      (Array.isArray(registros) ? registros : []).forEach(item => {
        const cnpjNormalizado = normalizarCnpj(item.cnpj);
        if (!cnpjNormalizado) {
          invalidos.push(item);
          return;
        }

        const codigoNormalizado = normalizarCodigo(extrairCodigoExterno(item));
        const ufNormalizada = normalizarUf(item.uf);
        const municipioInformado = limparMunicipioInformado(item.municipio);
        const municipioOriginalInformado = limparMunicipioInformado(item.municipio_original) || municipioInformado;
        const municipioResolvidoInformado = limparMunicipioInformado(
          item.municipio_resolvido
          || (item.municipio_mapeado && item.municipio_mapeado.descricao)
          || item.municipio_base
        );
        const municipioCodigosInformados = Array.isArray(item.municipio_codigos)
          ? item.municipio_codigos
              .map(valor => (valor === null || valor === undefined ? '' : String(valor).trim()))
              .filter(Boolean)
          : [];

        if (!mapa.has(cnpjNormalizado)) {
          mapa.set(cnpjNormalizado, {
            codigo_externo: codigoNormalizado,
            cnpj: cnpjNormalizado,
            uf: ufNormalizada,
            municipio: municipioInformado,
            municipio_original: municipioOriginalInformado,
            municipio_resolvido: municipioResolvidoInformado,
            municipio_codigos: municipioCodigosInformados
          });
        } else {
          const atual = mapa.get(cnpjNormalizado);
          if (codigoNormalizado && !atual.codigo_externo) {
            atual.codigo_externo = codigoNormalizado;
          }
          if (ufNormalizada && !atual.uf) {
            atual.uf = ufNormalizada;
          }
          if (municipioInformado && !atual.municipio) {
            atual.municipio = municipioInformado;
          }
          if (municipioOriginalInformado && !atual.municipio_original) {
            atual.municipio_original = municipioOriginalInformado;
          }
          if (municipioResolvidoInformado && !atual.municipio_resolvido) {
            atual.municipio_resolvido = municipioResolvidoInformado;
          }
          if (municipioCodigosInformados.length) {
            const conjunto = new Set(atual.municipio_codigos || []);
            municipioCodigosInformados.forEach(valor => conjunto.add(valor));
            atual.municipio_codigos = Array.from(conjunto);
          }
        }
      });

      return {
        lista: Array.from(mapa.values()),
        invalidos
      };
    }

    function aplicarMapeamentoImportacaoRegistro(item) {
      const registro = { ...item };
      if (!registro.municipio_original) {
        registro.municipio_original = registro.municipio || '';
      }

      const chave = gerarChaveMunicipioDePara(registro.uf, registro.municipio_original || registro.municipio);
      if (importacaoMunicipiosDePara.has(chave)) {
        const mapeamento = importacaoMunicipiosDePara.get(chave);
        registro.municipio_resolvido = mapeamento?.descricao ? limparMunicipioInformado(mapeamento.descricao) : '';
        registro.municipio_codigos = mapeamento?.codigo
          ? [String(mapeamento.codigo).trim()].filter(Boolean)
          : [];
        if (!registro.uf && mapeamento?.uf) {
          registro.uf = normalizarUf(mapeamento.uf);
        }
      } else if (Array.isArray(registro.municipio_codigos) && registro.municipio_codigos.length) {
        registro.municipio_codigos = Array.from(new Set(
          registro.municipio_codigos.map(valor => String(valor).trim()).filter(Boolean)
        ));
      } else {
        registro.municipio_codigos = [];
      }

      registro.municipio_chave = gerarChaveMunicipioImportacao(
        registro.uf,
        registro.municipio_resolvido || registro.municipio_original || registro.municipio || ''
      );

      return registro;
    }

    function combinarItensImportacao() {
      const { lista, invalidos } = consolidarRegistrosParaEnvio(csvRegistros);
      const listaComMapeamento = lista.map(aplicarMapeamentoImportacaoRegistro);
      return { lista: listaComMapeamento, invalidos };
    }

    function obterConjuntoCnpjsRemovidos(uf) {
      const ufNormalizada = normalizarUf(uf);
      if (!ufNormalizada) return null;
      if (!importacaoCnpjsRemovidosPorUf.has(ufNormalizada)) {
        importacaoCnpjsRemovidosPorUf.set(ufNormalizada, new Set());
      }
      return importacaoCnpjsRemovidosPorUf.get(ufNormalizada);
    }

    function sincronizarImportacaoRemocoes(lista) {
      const mapaValidos = new Map();
      (Array.isArray(lista) ? lista : []).forEach(item => {
        const uf = normalizarUf(item.uf);
        if (!uf) return;
        if (!mapaValidos.has(uf)) {
          mapaValidos.set(uf, new Set());
        }
        mapaValidos.get(uf).add(item.cnpj);
      });

      Array.from(importacaoCnpjsRemovidosPorUf.entries()).forEach(([uf, conjunto]) => {
        if (!mapaValidos.has(uf)) {
          importacaoCnpjsRemovidosPorUf.delete(uf);
          return;
        }
        const validos = mapaValidos.get(uf);
        Array.from(conjunto).forEach(cnpj => {
          if (!validos.has(cnpj)) {
            conjunto.delete(cnpj);
          }
        });
        if (conjunto.size === 0) {
          importacaoCnpjsRemovidosPorUf.delete(uf);
        }
      });
    }

    function atualizarImportacaoSubmitEstado({ habilitado, mensagem }) {
      if (!importacaoSubmitBtn) return;
      importacaoSubmitBtn.disabled = !habilitado;
      importacaoSubmitBtn.setAttribute('aria-disabled', habilitado ? 'false' : 'true');
      importacaoSubmitBtn.title = mensagem || '';
    }

    function atualizarImportacaoUfControles(listaCompleta) {
      if (!importacaoUfSelect || !importacaoUfFeedback) return;

      const mapa = new Map();
      listaCompleta.forEach(item => {
        const ufNormalizada = normalizarUf(item.uf);
        if (!ufNormalizada) return;
        if (!mapa.has(ufNormalizada)) {
          mapa.set(ufNormalizada, {
            cnpjs: new Set(),
            municipios: new Set()
          });
        }
        const grupo = mapa.get(ufNormalizada);
        grupo.cnpjs.add(item.cnpj);
        const municipioOrigem = item.municipio_resolvido || item.municipio_original || item.municipio || '';
        if (municipioOrigem) {
          grupo.municipios.add(municipioOrigem);
        }
      });

      importacaoUfDisponiveis = new Map(Array.from(mapa.entries()).sort((a, b) => a[0].localeCompare(b[0])));

      const selecaoAnterior = importacaoUfSelecionada;
      importacaoUfSelect.innerHTML = '<option value="">Selecione uma UF reconhecida</option>';

      importacaoUfDisponiveis.forEach((info, uf) => {
        const option = document.createElement('option');
        option.value = uf;
        option.textContent = `${uf} ¬∑ ${info.cnpjs.size} CNPJ${info.cnpjs.size === 1 ? '' : 's'}`;
        importacaoUfSelect.append(option);
      });

      const possuiArquivo = Array.isArray(csvRegistros) && csvRegistros.length > 0;

      if (importacaoUfDisponiveis.size === 0) {
        importacaoUfSelect.disabled = true;
        importacaoUfSelect.value = '';
        importacaoUfSelecionada = '';
        if (importacaoUfFeedback) {
          importacaoUfFeedback.textContent = possuiArquivo
            ? 'Nenhuma UF reconhecida no arquivo. Ajuste os dados informando a UF nas linhas ou concilie os munic√≠pios.'
            : 'Carregue um arquivo para listar as UFs dispon√≠veis.';
        }
        return;
      }

      importacaoUfSelect.disabled = false;

      if (selecaoAnterior && importacaoUfDisponiveis.has(selecaoAnterior)) {
        importacaoUfSelecionada = selecaoAnterior;
      } else if (importacaoUfDisponiveis.size === 1) {
        importacaoUfSelecionada = importacaoUfDisponiveis.keys().next().value;
      } else {
        importacaoUfSelecionada = '';
      }

      importacaoUfSelect.value = importacaoUfSelecionada;

      if (importacaoUfFeedback) {
        importacaoUfFeedback.textContent = importacaoUfSelecionada
          ? `UF ${importacaoUfSelecionada} selecionada para an√°lise.`
          : 'Selecione uma UF reconhecida para continuar.';
      }
    }

    function atualizarImportacaoListaCnpjs(listaCompleta, listaFiltrada, removidosConjunto) {
      if (!importacaoUfLista) return;

      importacaoUfLista.innerHTML = '';

      if (!importacaoUfSelecionada) {
        importacaoUfLista.classList.add('empty');
        importacaoUfLista.innerHTML = '<span class="helper-text">Selecione uma UF acima para visualizar os CNPJs do arquivo.</span>';
        return;
      }

      const listaBase = Array.isArray(listaCompleta) ? listaCompleta : [];
      const mapaPorCnpj = new Map(listaBase.map(item => [item.cnpj, item]));
      const totalCompleto = listaBase.length;
      const disponiveis = Array.isArray(listaFiltrada) ? listaFiltrada : [];
      const removidosSet = removidosConjunto instanceof Set ? removidosConjunto : null;
      const removidos = removidosSet ? Array.from(removidosSet) : [];

      if (!totalCompleto) {
        importacaoUfLista.classList.add('empty');
        importacaoUfLista.innerHTML = `<span class="helper-text">Nenhum CNPJ v√°lido identificado para a UF ${importacaoUfSelecionada}.</span>`;
        return;
      }

      importacaoUfLista.classList.remove('empty');

      const limite = 150;
      const itensExibidos = disponiveis.slice(0, limite);

      if (itensExibidos.length) {
        const listaElement = document.createElement('ul');
        itensExibidos.forEach(item => {
          const li = document.createElement('li');
          const identificador = document.createElement('span');
          identificador.className = 'cnpj-identificador';

          if (item.codigo_externo) {
            const codigoSpan = document.createElement('strong');
            codigoSpan.textContent = item.codigo_externo;
            identificador.append(codigoSpan);
          }

          const cnpjSpan = document.createElement('span');
          cnpjSpan.textContent = formatarCnpjVisivel(item.cnpj);
          identificador.append(cnpjSpan);

          const removerBtn = document.createElement('button');
          removerBtn.type = 'button';
          removerBtn.className = 'cnpj-action';
          removerBtn.textContent = 'Retirar';
          removerBtn.addEventListener('click', () => {
            const conjunto = obterConjuntoCnpjsRemovidos(importacaoUfSelecionada);
            if (!conjunto) return;
            conjunto.add(item.cnpj);
            atualizarResumoImportacao();
          });
          li.append(identificador, removerBtn);
          listaElement.append(li);
        });
        importacaoUfLista.append(listaElement);

        if (disponiveis.length > limite) {
          const restante = disponiveis.length - limite;
          const resumo = document.createElement('p');
          resumo.className = 'helper-text';
          resumo.textContent = `${formatadorNumero.format(restante)} CNPJ${restante === 1 ? '' : 's'} adicional${restante === 1 ? '' : 's'} oculto${restante === 1 ? '' : 's'} para preservar o desempenho.`;
          importacaoUfLista.append(resumo);
        }
      } else {
        if (!removidos.length) {
          importacaoUfLista.classList.add('empty');
        }
        const aviso = document.createElement('p');
        aviso.className = 'helper-text';
        aviso.textContent = removidos.length
          ? 'Todos os CNPJs desta UF foram descartados da an√°lise. Utilize a lista abaixo para restaurar os que desejar.'
          : `Nenhum CNPJ dispon√≠vel para a UF ${importacaoUfSelecionada} ap√≥s aplicar os filtros.`;
        importacaoUfLista.append(aviso);
      }

      if (removidos.length) {
        const removidosOrdenados = removidos.slice().sort();
        const cabecalho = document.createElement('div');
        cabecalho.className = 'cnpj-removed-header';
        const titulo = document.createElement('span');
        titulo.textContent = `${formatadorNumero.format(removidosOrdenados.length)} CNPJ${removidosOrdenados.length === 1 ? '' : 's'} descartado${removidosOrdenados.length === 1 ? '' : 's'}`;
        const restaurarTodosBtn = document.createElement('button');
        restaurarTodosBtn.type = 'button';
        restaurarTodosBtn.className = 'btn-chip';
        restaurarTodosBtn.textContent = 'Restaurar todos';
        restaurarTodosBtn.addEventListener('click', () => {
          const conjunto = importacaoCnpjsRemovidosPorUf.get(importacaoUfSelecionada);
          if (!conjunto) return;
          conjunto.clear();
          importacaoCnpjsRemovidosPorUf.delete(importacaoUfSelecionada);
          atualizarResumoImportacao();
        });
        cabecalho.append(titulo, restaurarTodosBtn);
        importacaoUfLista.append(cabecalho);

        const listaRemovidos = document.createElement('ul');
        listaRemovidos.className = 'cnpj-removed-list';
        const limiteRemovidos = 100;
        removidosOrdenados.slice(0, limiteRemovidos).forEach(cnpj => {
          const li = document.createElement('li');
          const identificador = document.createElement('span');
          identificador.className = 'cnpj-identificador';

          const registroOrigem = mapaPorCnpj.get(cnpj);
          if (registroOrigem?.codigo_externo) {
            const codigoSpan = document.createElement('strong');
            codigoSpan.textContent = registroOrigem.codigo_externo;
            identificador.append(codigoSpan);
          }

          const cnpjSpan = document.createElement('span');
          cnpjSpan.textContent = formatarCnpjVisivel(cnpj);
          identificador.append(cnpjSpan);

          const restaurarBtn = document.createElement('button');
          restaurarBtn.type = 'button';
          restaurarBtn.className = 'cnpj-action';
          restaurarBtn.textContent = 'Reincluir';
          restaurarBtn.addEventListener('click', () => {
            const conjunto = importacaoCnpjsRemovidosPorUf.get(importacaoUfSelecionada);
            if (!conjunto) return;
            conjunto.delete(cnpj);
            if (conjunto.size === 0) {
              importacaoCnpjsRemovidosPorUf.delete(importacaoUfSelecionada);
            }
            atualizarResumoImportacao();
          });
          li.append(identificador, restaurarBtn);
          listaRemovidos.append(li);
        });
        importacaoUfLista.append(listaRemovidos);

        if (removidosOrdenados.length > limiteRemovidos) {
          const restante = removidosOrdenados.length - limiteRemovidos;
          const resumoRemovidos = document.createElement('p');
          resumoRemovidos.className = 'helper-text';
          resumoRemovidos.textContent = `${formatadorNumero.format(restante)} CNPJ${restante === 1 ? '' : 's'} adicional${restante === 1 ? '' : 's'} oculto${restante === 1 ? '' : 's'} para preservar o desempenho.`;
          importacaoUfLista.append(resumoRemovidos);
        }
      }
    }

    function obterImportacaoMunicipiosAgrupados() {
      const { lista } = consolidarRegistrosParaEnvio(csvRegistros);
      const mapa = new Map();

      lista.forEach(item => {
        const municipioBase = item.municipio_original || item.municipio || '';
        if (!municipioBase) return;
        const uf = normalizarUf(item.uf);
        const chave = gerarChaveMunicipioDePara(uf, municipioBase);

        if (!mapa.has(chave)) {
          mapa.set(chave, {
            chave,
            uf,
            municipioArquivo: item.municipio || '',
            municipioOriginal: municipioBase,
            municipioResolvido: item.municipio_resolvido || '',
            quantidade: 0,
            codigos: new Set(Array.isArray(item.municipio_codigos) ? item.municipio_codigos : []),
            mapeamentoAtual: importacaoMunicipiosDePara.get(chave) || null
          });
        }

        const atual = mapa.get(chave);
        atual.quantidade += 1;
        if (!atual.municipioArquivo && item.municipio) {
          atual.municipioArquivo = item.municipio;
        }
        if (!atual.municipioResolvido && item.municipio_resolvido) {
          atual.municipioResolvido = item.municipio_resolvido;
        }
        if (Array.isArray(item.municipio_codigos)) {
          item.municipio_codigos.forEach(codigo => {
            if (codigo !== null && codigo !== undefined && String(codigo).trim()) {
              atual.codigos.add(String(codigo).trim());
            }
          });
        }
      });

      return Array.from(mapa.values()).sort((a, b) => {
        const ufA = a.uf || '';
        const ufB = b.uf || '';
        if (ufA === ufB) {
          return (a.municipioOriginal || '').localeCompare(b.municipioOriginal || '', 'pt-BR');
        }
        return ufA.localeCompare(ufB);
      });
    }

    function agruparMunicipiosImportacao(lista) {
      const mapa = new Map();
      (Array.isArray(lista) ? lista : []).forEach(item => {
        const uf = normalizarUf(item.uf);
        if (!uf) return;
        const chave = item.municipio_chave || gerarChaveMunicipioImportacao(
          uf,
          item.municipio_resolvido || item.municipio_original || item.municipio || ''
        );
        if (!mapa.has(uf)) {
          mapa.set(uf, new Map());
        }
        const mapaUf = mapa.get(uf);
        if (!mapaUf.has(chave)) {
          const descricaoBase = limparMunicipioInformado(
            item.municipio_resolvido || item.municipio_original || item.municipio
          );
          mapaUf.set(chave, {
            chave,
            uf,
            descricao: descricaoBase || 'Sem munic√≠pio informado',
            quantidade: 0,
            nomes: new Set(),
            codigos: new Set()
          });
        }
        const entrada = mapaUf.get(chave);
        entrada.quantidade += 1;
        [item.municipio_resolvido, item.municipio_original, item.municipio].forEach(valor => {
          const texto = limparMunicipioInformado(valor);
          if (texto) {
            entrada.nomes.add(texto);
          }
        });
        (Array.isArray(item.municipio_codigos) ? item.municipio_codigos : []).forEach(valor => {
          const texto = String(valor ?? '').trim();
          if (texto) {
            entrada.codigos.add(texto);
          }
        });
      });
      return mapa;
    }

    function renderImportacaoMunicipiosSelecao() {
      if (!importacaoMunicipiosLista || !importacaoMunicipiosFeedback) return;

      importacaoMunicipiosLista.innerHTML = '';
      importacaoMunicipiosLista.classList.remove('empty');
      if (importacaoMunicipiosAcoes) {
        importacaoMunicipiosAcoes.setAttribute('hidden', '');
      }

      const possuiArquivo = Array.isArray(csvRegistros) && csvRegistros.length > 0;

      if (!possuiArquivo) {
        importacaoMunicipiosLista.classList.add('empty');
        importacaoMunicipiosLista.innerHTML = '<span class="helper-text">Carregue um arquivo para listar os munic√≠pios reconhecidos.</span>';
        importacaoMunicipiosFeedback.textContent = 'Carregue um arquivo para listar os munic√≠pios reconhecidos.';
        return;
      }

      if (!importacaoUfSelecionada) {
        importacaoMunicipiosLista.classList.add('empty');
        importacaoMunicipiosLista.innerHTML = '<span class="helper-text">Selecione uma UF acima para visualizar os munic√≠pios do arquivo.</span>';
        importacaoMunicipiosFeedback.textContent = 'Selecione uma UF para visualizar os munic√≠pios reconhecidos.';
        return;
      }

      const ufAtual = importacaoUfSelecionada;
      const municipiosMap = importacaoMunicipiosDisponiveis.get(ufAtual);

      if (!municipiosMap || municipiosMap.size === 0) {
        importacaoMunicipiosLista.classList.add('empty');
        importacaoMunicipiosLista.innerHTML = '<span class="helper-text">Nenhum munic√≠pio informado para a UF selecionada.</span>';
        importacaoMunicipiosFeedback.textContent = 'Nenhum munic√≠pio informado para a UF selecionada.';
        return;
      }

      const selecionados = importacaoMunicipiosSelecionadosPorUf.get(ufAtual) || new Set();

      if (importacaoMunicipiosAcoes) {
        importacaoMunicipiosAcoes.removeAttribute('hidden');
      }
      if (importacaoMunicipiosSelecionarTodosBtn) {
        importacaoMunicipiosSelecionarTodosBtn.disabled = selecionados.size === municipiosMap.size;
      }
      if (importacaoMunicipiosSelecionarNenhumBtn) {
        importacaoMunicipiosSelecionarNenhumBtn.disabled = selecionados.size === 0;
      }

      municipiosMap.forEach((info, chave) => {
        const label = document.createElement('label');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = chave;
        checkbox.checked = selecionados.has(chave);
        checkbox.addEventListener('change', () => {
          const conjunto = importacaoMunicipiosSelecionadosPorUf.get(ufAtual);
          if (!conjunto) return;
          if (checkbox.checked) {
            conjunto.add(chave);
          } else {
            conjunto.delete(chave);
          }
          importacaoMunicipiosSelecaoManual.add(ufAtual);
          atualizarResumoImportacao();
        });

        const titulo = document.createElement('span');
        titulo.textContent = info.descricao;

        const meta = document.createElement('span');
        meta.className = 'checkbox-meta';
        meta.textContent = `${formatadorNumero.format(info.quantidade)} CNPJ${info.quantidade === 1 ? '' : 's'}`;

        label.append(checkbox, titulo, meta);
        importacaoMunicipiosLista.append(label);
      });

      const totalMunicipios = municipiosMap.size;
      const selecionadosCount = selecionados.size;
      const pluralTotal = totalMunicipios === 1 ? '' : 's';
      const pluralSelecionados = selecionadosCount === 1 ? '' : 's';

      if (selecionadosCount === 0) {
        importacaoMunicipiosFeedback.textContent = 'Nenhum munic√≠pio selecionado. Marque ao menos um para continuar.';
      } else if (selecionadosCount === totalMunicipios) {
        importacaoMunicipiosFeedback.textContent = `Todos os ${totalMunicipios} munic√≠pio${pluralTotal} do arquivo est√£o inclu√≠dos na an√°lise.`;
      } else {
        importacaoMunicipiosFeedback.textContent = `${selecionadosCount} de ${totalMunicipios} munic√≠pio${pluralTotal} selecionado${pluralSelecionados} para an√°lise.`;
      }
    }

    function sincronizarImportacaoMunicipios(lista) {
      importacaoMunicipiosDisponiveis = agruparMunicipiosImportacao(lista);
      const ufsAtuais = new Set(importacaoMunicipiosDisponiveis.keys());
      Array.from(importacaoMunicipiosSelecionadosPorUf.keys()).forEach(uf => {
        if (!ufsAtuais.has(uf)) {
          importacaoMunicipiosSelecionadosPorUf.delete(uf);
          importacaoMunicipiosSelecaoManual.delete(uf);
        }
      });
      importacaoMunicipiosDisponiveis.forEach((municipiosMap, uf) => {
        const jaExistia = importacaoMunicipiosSelecionadosPorUf.has(uf);
        let selecionados = importacaoMunicipiosSelecionadosPorUf.get(uf);
        if (!selecionados) {
          selecionados = new Set();
          importacaoMunicipiosSelecionadosPorUf.set(uf, selecionados);
        }
        Array.from(selecionados).forEach(chave => {
          if (!municipiosMap.has(chave)) {
            selecionados.delete(chave);
          }
        });
        if (selecionados.size === 0) {
          const selecaoManual = importacaoMunicipiosSelecaoManual.has(uf);
          if (jaExistia && selecaoManual) {
            return;
          }
          municipiosMap.forEach((_, chave) => selecionados.add(chave));
        }
      });
      renderImportacaoMunicipiosSelecao();
    }

    function limparImportacaoMunicipiosSelecao() {
      importacaoMunicipiosDisponiveis = new Map();
      importacaoMunicipiosSelecionadosPorUf = new Map();
      importacaoMunicipiosSelecaoManual = new Set();
      if (importacaoMunicipiosLista) {
        importacaoMunicipiosLista.innerHTML = '<span class="helper-text">Carregue um arquivo para listar os munic√≠pios reconhecidos.</span>';
        importacaoMunicipiosLista.classList.add('empty');
      }
      if (importacaoMunicipiosFeedback) {
        importacaoMunicipiosFeedback.textContent = 'Carregue um arquivo para listar os munic√≠pios reconhecidos.';
      }
      if (importacaoMunicipiosAcoes) {
        importacaoMunicipiosAcoes.setAttribute('hidden', '');
      }
    }

    function atualizarImportacaoConciliarMunicipiosEstado() {
      if (!importacaoConciliarMunicipiosBtn) return;
      const agrupados = obterImportacaoMunicipiosAgrupados();
      const habilitado = agrupados.length > 0;
      importacaoConciliarMunicipiosBtn.disabled = !habilitado;
      importacaoConciliarMunicipiosBtn.setAttribute('aria-disabled', habilitado ? 'false' : 'true');
    }

    function atualizarImportacaoMunicipiosModalStatus(texto, { erro = false } = {}) {
      if (!importacaoMunicipiosModalStatus) return;
      importacaoMunicipiosModalStatus.textContent = texto;
      importacaoMunicipiosModalStatus.classList.toggle('error', Boolean(erro));
    }

    function fecharImportacaoMunicipiosModal() {
      if (!importacaoMunicipiosModal) return;
      importacaoMunicipiosModal.classList.remove('open');
      importacaoMunicipiosModal.setAttribute('hidden', '');
      document.body.classList.remove('modal-open');
    }

    async function montarImportacaoMunicipiosModal(agrupados) {
      if (!importacaoMunicipiosModalCorpo) return;

      if (!Array.isArray(agrupados) || !agrupados.length) {
        importacaoMunicipiosModalCorpo.innerHTML = '<tr class="modal-empty"><td colspan="5">Nenhum munic√≠pio dispon√≠vel para concilia√ß√£o.</td></tr>';
        atualizarImportacaoMunicipiosModalStatus('Nenhum munic√≠pio dispon√≠vel para concilia√ß√£o.');
        return;
      }

      importacaoMunicipiosModalCorpo.innerHTML = '';
      const selects = [];

      for (const item of agrupados) {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${item.uf || '‚Äî'}</td>
          <td>${item.municipioOriginal || item.municipioArquivo || '‚Äî'}</td>
          <td class="numero-cell">${formatadorNumero.format(item.quantidade)}</td>
          <td class="codigo-cell">${item.codigos.size ? Array.from(item.codigos).join(', ') : '‚Äî'}</td>
          <td>
            <div class="modal-select-wrapper">
              <select data-chave="${item.chave}">
                <option value="">Manter como informado</option>
              </select>
            </div>
          </td>
        `;

        const select = tr.querySelector('select');
        if (select) {
          select.disabled = true;
          select.dataset.uf = item.uf || '';
          select.dataset.municipioOriginal = item.municipioOriginal || '';
          select.dataset.municipioArquivo = item.municipioArquivo || '';
          select.dataset.municipioResolvido = item.municipioResolvido || '';
          select.dataset.codigosSugeridos = JSON.stringify(Array.from(item.codigos || []));
          selects.push(select);
        }

        importacaoMunicipiosModalCorpo.append(tr);
      }

      if (!selects.length) {
        atualizarImportacaoMunicipiosModalStatus('Ajuste os munic√≠pios conforme necess√°rio.');
        return;
      }

      atualizarImportacaoMunicipiosModalStatus('Carregando munic√≠pios‚Ä¶');

      const carregamentos = selects.map(select => (async () => {
        const uf = select.dataset.uf;
        if (!uf) {
          select.disabled = false;
          select.value = '';
          return;
        }

        try {
          const lista = await obterMunicipiosPorUf(uf);
          const options = Array.isArray(lista) ? lista : [];
          options.forEach(municipio => {
            const option = document.createElement('option');
            option.value = municipio.codigo;
            option.textContent = `${municipio.codigo} ¬∑ ${municipio.descricao}`;
            select.append(option);
          });

          const chave = select.dataset.chave;
          const atual = importacaoMunicipiosDePara.get(chave);
          let codigoSelecionado = atual?.codigo || '';

          if (!codigoSelecionado) {
            const resolvido = select.dataset.municipioResolvido || '';
            if (resolvido) {
              const correspondenciaResolvida = options.find(op => normalizarTexto(op.descricao) === normalizarTexto(resolvido));
              if (correspondenciaResolvida) {
                codigoSelecionado = correspondenciaResolvida.codigo;
              }
            }
          }

          if (!codigoSelecionado) {
            try {
              const sugeridos = JSON.parse(select.dataset.codigosSugeridos || '[]');
              if (Array.isArray(sugeridos) && sugeridos.length === 1) {
                const unico = String(sugeridos[0]);
                if (options.some(op => op.codigo === unico)) {
                  codigoSelecionado = unico;
                }
              }
            } catch (error) {
              console.error(error);
            }
          }

          if (!codigoSelecionado) {
            const municipioOriginal = select.dataset.municipioOriginal || select.dataset.municipioArquivo || '';
            if (municipioOriginal) {
              const correspondenciaOriginal = options.find(op => normalizarTexto(op.descricao) === normalizarTexto(municipioOriginal));
              if (correspondenciaOriginal) {
                codigoSelecionado = correspondenciaOriginal.codigo;
              }
            }
          }

          if (codigoSelecionado && options.some(op => op.codigo === codigoSelecionado)) {
            select.value = codigoSelecionado;
          } else {
            select.value = '';
          }

          select.disabled = false;
        } catch (error) {
          console.error(error);
          select.innerHTML = '<option value="">Erro ao carregar munic√≠pios</option>';
          select.disabled = true;
          throw error;
        }
      })());

      const resultados = await Promise.allSettled(carregamentos);
      const falhas = resultados.filter(resultado => resultado.status === 'rejected').length;

      if (falhas === carregamentos.length) {
        atualizarImportacaoMunicipiosModalStatus('N√£o foi poss√≠vel carregar os munic√≠pios de refer√™ncia. Tente novamente.', { erro: true });
      } else if (falhas > 0) {
        atualizarImportacaoMunicipiosModalStatus('Alguns munic√≠pios n√£o puderam ser carregados. Ajuste manualmente se necess√°rio.', { erro: true });
      } else {
        atualizarImportacaoMunicipiosModalStatus('Ajuste os munic√≠pios conforme necess√°rio.');
      }
    }

    async function abrirImportacaoMunicipiosModal() {
      if (!importacaoMunicipiosModal) return;
      document.body.classList.add('modal-open');
      importacaoMunicipiosModal.removeAttribute('hidden');
      importacaoMunicipiosModal.classList.add('open');
      atualizarImportacaoMunicipiosModalStatus('Preparando concilia√ß√µes‚Ä¶');
      const agrupados = obterImportacaoMunicipiosAgrupados();
      await montarImportacaoMunicipiosModal(agrupados);
    }

    function aplicarImportacaoMunicipiosSelecao() {
      if (!importacaoMunicipiosModalCorpo) return;
      const selects = Array.from(importacaoMunicipiosModalCorpo.querySelectorAll('select[data-chave]'));
      selects.forEach(select => {
        const chave = select.dataset.chave;
        if (!chave) return;
        if (!select.value) {
          importacaoMunicipiosDePara.delete(chave);
          return;
        }
        importacaoMunicipiosDePara.set(chave, {
          codigo: select.value,
          descricao: select.options[select.selectedIndex]?.textContent?.replace(/^\s*[^¬∑]*¬∑\s*/, '') || select.value,
          uf: select.dataset.uf || '',
          municipioOriginal: select.dataset.municipioOriginal || select.dataset.municipioArquivo || ''
        });
      });
      atualizarResumoImportacao();
    }

    function aplicarMapeamentoCoberturaRegistro(item) {
      const registro = { ...item };
      if (!registro.municipio_original) {
        registro.municipio_original = registro.municipio || '';
      }
      const chave = gerarChaveMunicipioDePara(registro.uf, registro.municipio_original || registro.municipio);
      if (coberturaMunicipiosDePara.has(chave)) {
        const mapeamento = coberturaMunicipiosDePara.get(chave);
        registro.municipio_resolvido = mapeamento?.descricao ? limparMunicipioInformado(mapeamento.descricao) : '';
        registro.municipio_codigos = mapeamento?.codigo
          ? [String(mapeamento.codigo).trim()].filter(Boolean)
          : [];
        if (!registro.uf && mapeamento?.uf) {
          registro.uf = normalizarUf(mapeamento.uf);
        }
      } else if (Array.isArray(registro.municipio_codigos) && registro.municipio_codigos.length) {
        registro.municipio_codigos = Array.from(new Set(
          registro.municipio_codigos.map(valor => String(valor).trim()).filter(Boolean)
        ));
      } else {
        registro.municipio_codigos = [];
      }

      return registro;
    }

    function combinarItensCobertura() {
      const { lista, invalidos } = consolidarRegistrosParaEnvio(coberturaRegistros);

      if (!lista.length) {
        return { lista: [], invalidos };
      }

      const listaComMapeamento = lista.map(aplicarMapeamentoCoberturaRegistro);

      const ufFiltro = coberturaUfSelect && coberturaUfSelect.value
        ? coberturaUfSelect.value.trim().toUpperCase()
        : '';
      const municipiosSelecionados = coberturaMunicipiosSelecionados.size
        ? new Set(
            Array.from(coberturaMunicipiosSelecionados.values())
              .map(descricao => normalizarTexto(descricao))
              .filter(Boolean)
          )
        : null;

      const listaFiltrada = listaComMapeamento.filter(item => {
        if (ufFiltro && item.uf !== ufFiltro) {
          return false;
        }
        if (municipiosSelecionados && municipiosSelecionados.size) {
          const municipioComparacao = item.municipio_resolvido || item.municipio;
          const municipioNormalizado = normalizarTexto(municipioComparacao);
          if (!municipioNormalizado) {
            return false;
          }
          return municipiosSelecionados.has(municipioNormalizado);
        }
        return true;
      });

      return { lista: listaFiltrada, invalidos };
    }

    function obterCoberturaMunicipiosAgrupados() {
      const { lista } = consolidarRegistrosParaEnvio(coberturaRegistros);
      const mapa = new Map();

      lista.forEach(item => {
        const municipioBase = item.municipio_original || item.municipio || '';
        if (!municipioBase) return;
        const uf = normalizarUf(item.uf);
        const chave = gerarChaveMunicipioDePara(uf, municipioBase);

        if (!mapa.has(chave)) {
          mapa.set(chave, {
            chave,
            uf,
            municipioArquivo: item.municipio || '',
            municipioOriginal: municipioBase,
            municipioResolvido: item.municipio_resolvido || '',
            quantidade: 0,
            codigos: new Set(Array.isArray(item.municipio_codigos) ? item.municipio_codigos : []),
            mapeamentoAtual: coberturaMunicipiosDePara.get(chave) || null
          });
        }

        const atual = mapa.get(chave);
        atual.quantidade += 1;
        if (!atual.municipioArquivo && item.municipio) {
          atual.municipioArquivo = item.municipio;
        }
        if (!atual.municipioResolvido && item.municipio_resolvido) {
          atual.municipioResolvido = item.municipio_resolvido;
        }
        if (Array.isArray(item.municipio_codigos)) {
          item.municipio_codigos.forEach(codigo => {
            if (codigo !== null && codigo !== undefined && String(codigo).trim()) {
              atual.codigos.add(String(codigo).trim());
            }
          });
        }
      });

      return Array.from(mapa.values()).sort((a, b) => {
        const ufA = a.uf || '';
        const ufB = b.uf || '';
        if (ufA === ufB) {
          return (a.municipioOriginal || '').localeCompare(b.municipioOriginal || '', 'pt-BR');
        }
        return ufA.localeCompare(ufB);
      });
    }

    function atualizarCoberturaValidarMunicipiosEstado() {
      if (!coberturaValidarMunicipiosBtn) return;
      const agrupados = obterCoberturaMunicipiosAgrupados();
      const habilitado = agrupados.length > 0;
      coberturaValidarMunicipiosBtn.disabled = !habilitado;
      coberturaValidarMunicipiosBtn.setAttribute('aria-disabled', habilitado ? 'false' : 'true');
    }

    function atualizarCoberturaMunicipiosModalStatus(texto, { erro = false } = {}) {
      if (!coberturaMunicipiosModalStatus) return;
      coberturaMunicipiosModalStatus.textContent = texto;
      coberturaMunicipiosModalStatus.classList.toggle('error', Boolean(erro));
    }

    function fecharCoberturaMunicipiosModal() {
      if (!coberturaMunicipiosModal) return;
      coberturaMunicipiosModal.classList.remove('open');
      coberturaMunicipiosModal.setAttribute('hidden', '');
      document.body.classList.remove('modal-open');
    }

    async function montarCoberturaMunicipiosModal(agrupados) {
      if (!coberturaMunicipiosModalCorpo) return;

      if (!Array.isArray(agrupados) || !agrupados.length) {
        coberturaMunicipiosModalCorpo.innerHTML = '<tr class="modal-empty"><td colspan="5">Nenhum munic√≠pio dispon√≠vel para valida√ß√£o.</td></tr>';
        atualizarCoberturaMunicipiosModalStatus('Nenhum munic√≠pio com nome dispon√≠vel para valida√ß√£o.');
        return;
      }

      atualizarCoberturaMunicipiosModalStatus('Selecione a correspond√™ncia adequada para cada munic√≠pio e aplique o mapeamento.');

      const ufs = Array.from(new Set(agrupados.map(item => item.uf).filter(Boolean)));
      const municipiosPorUf = new Map();

      await Promise.all(ufs.map(async uf => {
        try {
          const lista = await obterMunicipiosPorUf(uf);
          municipiosPorUf.set(uf, Array.isArray(lista) ? lista : []);
        } catch (error) {
          console.error(error);
          municipiosPorUf.set(uf, []);
        }
      }));

      coberturaMunicipiosModalCorpo.innerHTML = '';

      const atualizarResumoPendencias = () => {
        const selects = coberturaMunicipiosModalCorpo.querySelectorAll('select.municipio-mapeamento-select');
        if (!selects.length) {
          atualizarCoberturaMunicipiosModalStatus('Nenhum munic√≠pio com nome dispon√≠vel para valida√ß√£o.');
          return;
        }
        let pendencias = 0;
        selects.forEach(select => {
          if (select.disabled || !String(select.value || '').trim()) {
            pendencias += 1;
          }
        });
        if (pendencias > 0) {
          atualizarCoberturaMunicipiosModalStatus(`Selecione a correspond√™ncia para ${pendencias} munic√≠pio${pendencias === 1 ? '' : 's'} pendente${pendencias === 1 ? '' : 's'} e aplique o mapeamento.`);
        } else {
          atualizarCoberturaMunicipiosModalStatus('Todos os munic√≠pios est√£o mapeados. Revise e aplique as altera√ß√µes se necess√°rio.');
        }
      };

      agrupados.forEach(item => {
        const listaMunicipios = item.uf ? (municipiosPorUf.get(item.uf) || []) : [];
        const tr = document.createElement('tr');
        tr.dataset.chaveMunicipio = item.chave;

        const tdUf = document.createElement('td');
        tdUf.textContent = item.uf || '‚Äî';
        tr.append(tdUf);

        const tdArquivo = document.createElement('td');
        const nomeArquivo = item.municipioOriginal || item.municipioArquivo || '‚Äî';
        tdArquivo.innerHTML = `<strong>${nomeArquivo}</strong>`;
        if (item.municipioArquivo && item.municipioArquivo !== item.municipioOriginal) {
          tdArquivo.innerHTML += `<span class="value-meta">Formato original: ${item.municipioArquivo}</span>`;
        }
        if (item.municipioResolvido && item.municipioResolvido !== nomeArquivo) {
          tdArquivo.innerHTML += `<span class="value-meta">Mapeado anteriormente: ${item.municipioResolvido}</span>`;
        }
        tr.append(tdArquivo);

        const tdSelect = document.createElement('td');
        const select = document.createElement('select');
        select.dataset.chave = item.chave;
        select.dataset.uf = item.uf || '';
        select.className = 'municipio-mapeamento-select';

        let codigoSelecionado = item.mapeamentoAtual?.codigo || '';

        if (!codigoSelecionado && item.municipioResolvido) {
          const correspondenciaResolvida = listaMunicipios.find(opcao => normalizarTexto(opcao.descricao) === normalizarTexto(item.municipioResolvido));
          if (correspondenciaResolvida) {
            codigoSelecionado = correspondenciaResolvida.codigo;
          }
        }

        if (!codigoSelecionado && item.codigos instanceof Set && item.codigos.size === 1) {
          const [codigoUnico] = Array.from(item.codigos);
          if (listaMunicipios.some(op => op.codigo === codigoUnico)) {
            codigoSelecionado = codigoUnico;
          }
        }

        if (!codigoSelecionado && item.municipioOriginal) {
          const correspondenciaOriginal = listaMunicipios.find(opcao => normalizarTexto(opcao.descricao) === normalizarTexto(item.municipioOriginal));
          if (correspondenciaOriginal) {
            codigoSelecionado = correspondenciaOriginal.codigo;
          }
        }

        if (!listaMunicipios.length) {
          const option = document.createElement('option');
          option.value = '';
          option.textContent = item.uf ? 'Nenhum munic√≠pio encontrado' : 'Informe a UF no arquivo';
          select.append(option);
          select.disabled = true;
        } else {
          const optionPadrao = document.createElement('option');
          optionPadrao.value = '';
          optionPadrao.textContent = 'Selecione um munic√≠pio';
          select.append(optionPadrao);

          listaMunicipios.forEach(municipio => {
            const option = document.createElement('option');
            option.value = municipio.codigo;
            option.textContent = `${municipio.codigo} ¬∑ ${municipio.descricao}`;
            option.dataset.descricao = municipio.descricao;
            select.append(option);
          });

          if (codigoSelecionado && listaMunicipios.some(m => m.codigo === codigoSelecionado)) {
            select.value = codigoSelecionado;
          }
        }

        tdSelect.append(select);
        tr.append(tdSelect);

        const tdCodigo = document.createElement('td');
        tdCodigo.className = 'codigo-cell';
        tdCodigo.textContent = select.value || '‚Äî';
        tr.append(tdCodigo);

        const tdQuantidade = document.createElement('td');
        const chip = document.createElement('span');
        chip.className = 'count-chip';
        chip.textContent = formatadorNumero.format(item.quantidade || 0);
        tdQuantidade.append(chip);
        tr.append(tdQuantidade);

        const atualizarDescricaoSelecionada = () => {
          const opcaoSelecionada = select.selectedOptions[0];
          tdCodigo.textContent = select.value || '‚Äî';
          if (opcaoSelecionada) {
            select.dataset.descricao = opcaoSelecionada.dataset.descricao || opcaoSelecionada.textContent;
          } else {
            select.dataset.descricao = '';
          }
        };

        select.addEventListener('change', () => {
          atualizarDescricaoSelecionada();
          atualizarResumoPendencias();
        });
        atualizarDescricaoSelecionada();

        coberturaMunicipiosModalCorpo.append(tr);
      });

      atualizarResumoPendencias();
    }

    async function abrirCoberturaMunicipiosModal() {
      if (!coberturaMunicipiosModal) return;
      const agrupados = obterCoberturaMunicipiosAgrupados();
      coberturaMunicipiosModal.classList.add('open');
      coberturaMunicipiosModal.removeAttribute('hidden');
      document.body.classList.add('modal-open');

      try {
        await montarCoberturaMunicipiosModal(agrupados);
      } catch (error) {
        console.error(error);
        coberturaMunicipiosModalCorpo.innerHTML = '<tr class="modal-empty"><td colspan="5">N√£o foi poss√≠vel carregar as correspond√™ncias de munic√≠pios.</td></tr>';
        atualizarCoberturaMunicipiosModalStatus('N√£o foi poss√≠vel carregar os munic√≠pios de refer√™ncia. Tente novamente.', { erro: true });
      }

      const focoInicial = coberturaMunicipiosModalCorpo.querySelector('select:not(:disabled)')
        || coberturaMunicipiosModalFechar
        || coberturaMunicipiosModalCancelar
        || coberturaMunicipiosModalSalvar;
      if (focoInicial) {
        focoInicial.focus();
      }
    }

    function salvarCoberturaMunicipiosModal() {
      if (!coberturaMunicipiosModalCorpo) return;
      const selects = coberturaMunicipiosModalCorpo.querySelectorAll('select.municipio-mapeamento-select');
      let aplicados = 0;

      selects.forEach(select => {
        const chave = select.dataset.chave;
        if (!chave) return;
        const valor = String(select.value || '').trim();
        if (valor) {
          const descricao = select.selectedOptions[0]?.dataset.descricao || select.selectedOptions[0]?.textContent || '';
          const uf = select.dataset.uf || '';
          coberturaMunicipiosDePara.set(chave, { codigo: valor, descricao, uf });
          aplicados += 1;
        } else {
          coberturaMunicipiosDePara.delete(chave);
        }
      });

      fecharCoberturaMunicipiosModal();
      atualizarCoberturaValidarMunicipiosEstado();
      atualizarResumoCobertura();
      atualizarCoberturaCompararEstado();
      if (coberturaStatus) {
        coberturaStatus.textContent = aplicados
          ? `Mapeamento de munic√≠pios atualizado (${aplicados} correspond√™ncia${aplicados === 1 ? '' : 's'} aplicada${aplicados === 1 ? '' : 's'}).`
          : 'Nenhuma correspond√™ncia de munic√≠pio selecionada.';
      }
      if (coberturaValidarMunicipiosBtn) {
        coberturaValidarMunicipiosBtn.focus();
      }
    }

    function atualizarResumoImportacao() {
      if (!importacaoResumo) {
        return { lista: [], invalidos: [], total: 0 };
      }

      const { lista, invalidos } = combinarItensImportacao();

      atualizarImportacaoUfControles(lista);
      sincronizarImportacaoMunicipios(lista);
      sincronizarImportacaoRemocoes(lista);

      const listaPorUf = importacaoUfSelecionada
        ? lista.filter(item => item.uf === importacaoUfSelecionada)
        : lista;

      const municipiosMapAtual = importacaoUfSelecionada
        ? importacaoMunicipiosDisponiveis.get(importacaoUfSelecionada)
        : null;
      const selecionadosMunicipios = importacaoUfSelecionada
        ? importacaoMunicipiosSelecionadosPorUf.get(importacaoUfSelecionada)
        : null;
      const removidosAtual = importacaoUfSelecionada
        ? importacaoCnpjsRemovidosPorUf.get(importacaoUfSelecionada) || null
        : null;

      let listaFiltrada = listaPorUf;
      let nenhumMunicipioSelecionado = false;

      if (importacaoUfSelecionada && municipiosMapAtual && municipiosMapAtual.size > 0) {
        if (!selecionadosMunicipios || selecionadosMunicipios.size === 0) {
          listaFiltrada = [];
          nenhumMunicipioSelecionado = true;
        } else {
          listaFiltrada = listaPorUf.filter(item => {
            const chave = item.municipio_chave || gerarChaveMunicipioImportacao(
              importacaoUfSelecionada,
              item.municipio_resolvido || item.municipio_original || item.municipio || ''
            );
            return selecionadosMunicipios.has(chave);
          });
        }
      }

      if (importacaoUfSelecionada && removidosAtual && removidosAtual.size) {
        listaFiltrada = listaFiltrada.filter(item => !removidosAtual.has(item.cnpj));
      }

      atualizarImportacaoListaCnpjs(listaPorUf, listaFiltrada, removidosAtual);
      atualizarImportacaoConciliarMunicipiosEstado();

      const possuiArquivo = Array.isArray(csvRegistros) && csvRegistros.length > 0;
      let podeEnviar = false;
      let mensagemBloqueio = '';

      if (!possuiArquivo) {
        mensagemBloqueio = 'Carregue um arquivo para iniciar a an√°lise.';
      } else if (!lista.length) {
        mensagemBloqueio = invalidos.length
          ? 'Nenhum CNPJ v√°lido identificado no arquivo.'
          : 'Nenhum CNPJ informado.';
      } else if (importacaoUfDisponiveis.size === 0) {
        mensagemBloqueio = 'Nenhuma UF reconhecida no arquivo. Ajuste os dados antes de continuar.';
      } else if (!importacaoUfSelecionada) {
        mensagemBloqueio = 'Selecione uma UF reconhecida para continuar.';
      } else if (nenhumMunicipioSelecionado) {
        mensagemBloqueio = 'Selecione ao menos um munic√≠pio para continuar.';
      } else if (!listaFiltrada.length) {
        if (removidosAtual && removidosAtual.size && listaPorUf.length) {
          mensagemBloqueio = 'Todos os CNPJs desta UF foram descartados da an√°lise. Restaure ao menos um para continuar.';
        } else {
          mensagemBloqueio = `Nenhum CNPJ v√°lido identificado para a UF ${importacaoUfSelecionada}.`;
        }
      } else {
        podeEnviar = true;
      }

      atualizarImportacaoSubmitEstado({
        habilitado: podeEnviar,
        mensagem: podeEnviar ? '' : mensagemBloqueio
      });

      if (!lista.length) {
        if (invalidos.length) {
          importacaoResumo.textContent = `${invalidos.length} registro${invalidos.length === 1 ? '' : 's'} ignorado${invalidos.length === 1 ? '' : 's'} por CNPJ inv√°lido.`;
        } else if (possuiArquivo) {
          importacaoResumo.textContent = 'Nenhum CNPJ v√°lido identificado.';
        } else {
          importacaoResumo.textContent = 'Nenhum CNPJ informado.';
        }
      } else if (importacaoUfDisponiveis.size === 0) {
        const pluralTotal = lista.length === 1 ? '' : 's';
        importacaoResumo.textContent = `${formatadorNumero.format(lista.length)} CNPJ${pluralTotal} reconhecido${pluralTotal}, mas nenhuma UF foi identificada. Informe a UF na planilha ou utilize a concilia√ß√£o de munic√≠pios.`;
      } else if (!importacaoUfSelecionada) {
        const pluralTotal = lista.length === 1 ? '' : 's';
        const pluralUf = importacaoUfDisponiveis.size === 1 ? '' : 's';
        const trechoInvalidos = invalidos.length
          ? ` ‚Ä¢ ${invalidos.length} registro${invalidos.length === 1 ? '' : 's'} ignorado${invalidos.length === 1 ? '' : 's'}.`
          : '';
        importacaoResumo.textContent = `${formatadorNumero.format(lista.length)} CNPJ${pluralTotal} reconhecido${pluralTotal} no arquivo ‚Ä¢ ${importacaoUfDisponiveis.size} UF${pluralUf} dispon√≠vel${pluralUf}. Selecione uma UF para continuar.${trechoInvalidos}`;
      } else if (nenhumMunicipioSelecionado) {
        importacaoResumo.textContent = 'Nenhum munic√≠pio selecionado. Escolha ao menos um munic√≠pio para incluir na an√°lise.';
      } else if (!listaFiltrada.length) {
        if (removidosAtual && removidosAtual.size && listaPorUf.length) {
          importacaoResumo.textContent = 'Todos os CNPJs desta UF foram descartados da an√°lise. Utilize a lista ao lado para reincluir os itens necess√°rios.';
        } else {
          importacaoResumo.textContent = `Nenhum CNPJ v√°lido identificado para a UF ${importacaoUfSelecionada}.`;
        }
      } else {
        const pluralFiltrado = listaFiltrada.length === 1 ? '' : 's';
        const trechoInvalidos = invalidos.length
          ? ` ‚Ä¢ ${invalidos.length} registro${invalidos.length === 1 ? '' : 's'} ignorado${invalidos.length === 1 ? '' : 's'}.`
          : '';
        const detalhes = [`UF ${importacaoUfSelecionada}`];
        if (municipiosMapAtual && municipiosMapAtual.size) {
          const totalMunicipios = municipiosMapAtual.size;
          const selecionadosMunicipiosCount = selecionadosMunicipios
            ? selecionadosMunicipios.size
            : totalMunicipios;
          if (selecionadosMunicipiosCount && selecionadosMunicipiosCount < totalMunicipios) {
            const pluralTotal = totalMunicipios === 1 ? '' : 's';
            const pluralSelecionados = selecionadosMunicipiosCount === 1 ? '' : 's';
            detalhes.push(`${selecionadosMunicipiosCount} de ${totalMunicipios} munic√≠pio${pluralTotal} inclu√≠do${pluralSelecionados}`);
          } else {
            const pluralMun = totalMunicipios === 1 ? '' : 's';
            detalhes.push(`${totalMunicipios} munic√≠pio${pluralMun}`);
          }
        }
        if (removidosAtual && removidosAtual.size) {
          const pluralRemovidos = removidosAtual.size === 1 ? '' : 's';
          detalhes.push(`${formatadorNumero.format(removidosAtual.size)} CNPJ${pluralRemovidos} descartado${pluralRemovidos}`);
        }
        importacaoResumo.textContent = `${formatadorNumero.format(listaFiltrada.length)} CNPJ${pluralFiltrado} pronto${pluralFiltrado} para an√°lise ‚Ä¢ ${detalhes.join(' ‚Ä¢ ')}${trechoInvalidos}`;
      }

      return { lista: listaFiltrada, invalidos, total: lista.length };
    }

    function limparImportacaoTabela(mensagem = 'Nenhum resultado dispon√≠vel.') {
      ultimoImportacaoResultado = [];
      if (importacaoCorpo) {
        importacaoCorpo.innerHTML = `<tr class="empty-state"><td colspan="8">${mensagem}</td></tr>`;
      }
      if (importacaoCount) {
        importacaoCount.textContent = 'Nenhum resultado dispon√≠vel.';
      }
      if (importacaoExportarBtn) {
        importacaoExportarBtn.disabled = true;
      }
    }

    function renderizarImportacaoTabela(dados) {
      if (!importacaoCorpo) return;
      importacaoCorpo.innerHTML = '';

      dados.forEach(item => {
        const tr = document.createElement('tr');
        const razaoBase = item.razao_social || '';
        const municipioInformado = item.municipio_informado || '';
        const ufInformado = item.uf_informado || '';
        const encontrado = Boolean(
          item.orgao
          || item.tipo_situacao_inscricao
          || item.receita_principal
          || (typeof item.valor_consolidado === 'number' && !Number.isNaN(item.valor_consolidado))
          || (razaoBase && razaoBase.trim())
        );

        const razaoPartes = [];
        razaoPartes.push(razaoBase || '‚Äî');
        if (municipioInformado || ufInformado) {
          const origem = [municipioInformado, ufInformado].filter(Boolean).join(' - ');
          if (origem) {
            razaoPartes.push(`<span class="value-meta">Informado: ${origem}</span>`);
          }
        }

        const orgao = item.orgao || (encontrado ? '‚Äî' : '');
        const tipoSituacao = item.tipo_situacao_inscricao || (encontrado ? '‚Äî' : '');
        const situacaoInscricao = item.situacao_inscricao || (encontrado ? '‚Äî' : 'CNPJ regular na lista da situa√ß√£o divida ativa.');
        const receitaPrincipal = item.receita_principal || (encontrado ? '‚Äî' : '');
        const valorConsolidadoTexto = (() => {
          const valor = item.valor_consolidado;
          if (typeof valor === 'number' && !Number.isNaN(valor)) {
            return formatadorMoeda.format(valor);
          }
          return '‚Äî';
        })();

        tr.innerHTML = `
          <td>${item.codigo_externo || ''}</td>
          <td>${formatarCnpjVisivel(item.cnpj)}</td>
          <td>${razaoPartes.join('')}</td>
          <td>${orgao || '‚Äî'}</td>
          <td>${tipoSituacao || '‚Äî'}</td>
          <td>${situacaoInscricao || '‚Äî'}</td>
          <td>${receitaPrincipal || '‚Äî'}</td>
          <td>${valorConsolidadoTexto}</td>
        `;
        importacaoCorpo.append(tr);
      });
    }

    function limparImportacao() {
      csvRegistros = [];
      importacaoMunicipiosDePara = new Map();
      importacaoMunicipiosDisponiveis = new Map();
      importacaoMunicipiosSelecionadosPorUf = new Map();
      importacaoUfDisponiveis = new Map();
      importacaoUfSelecionada = '';
      importacaoCnpjsRemovidosPorUf = new Map();
      if (importacaoArquivoInput) {
        importacaoArquivoInput.value = '';
      }
      if (importacaoArquivoFeedback) {
        importacaoArquivoFeedback.textContent = '';
      }
      if (importacaoUfSelect) {
        importacaoUfSelect.innerHTML = '<option value="">Selecione uma UF reconhecida</option>';
        importacaoUfSelect.disabled = true;
        importacaoUfSelect.value = '';
      }
      if (importacaoUfFeedback) {
        importacaoUfFeedback.textContent = 'Carregue um arquivo para listar as UFs dispon√≠veis.';
      }
      if (importacaoUfLista) {
        importacaoUfLista.classList.add('empty');
        importacaoUfLista.innerHTML = '<span class="helper-text">Selecione uma UF acima para visualizar os CNPJs do arquivo.</span>';
      }
      if (importacaoStatus) {
        importacaoStatus.textContent = 'Carregue um arquivo para iniciar a an√°lise.';
      }
      limparImportacaoTabela();
      atualizarImportacaoSubmitEstado({ habilitado: false, mensagem: 'Carregue um arquivo para iniciar a an√°lise.' });
      atualizarResumoImportacao();
      limparImportacaoMunicipiosSelecao();
    }

    function atualizarCoberturaMunicipiosFeedback(mensagem) {
      if (!coberturaMunicipiosFeedback) return;

      if (mensagem) {
        coberturaMunicipiosFeedback.textContent = mensagem;
        return;
      }

      if (!coberturaUfSelect || !coberturaUfSelect.value) {
        coberturaMunicipiosFeedback.textContent = 'Selecione uma UF para listar munic√≠pios.';
        return;
      }

      if (!coberturaMunicipiosCache.length) {
        coberturaMunicipiosFeedback.textContent = 'Nenhum munic√≠pio dispon√≠vel para a UF selecionada.';
        return;
      }

      if (!coberturaMunicipiosSelecionados.size) {
        coberturaMunicipiosFeedback.textContent = MUNICIPIOS_HELPER_BASE;
        return;
      }

      const plural = coberturaMunicipiosSelecionados.size === 1 ? '' : 's';
      coberturaMunicipiosFeedback.textContent = `${coberturaMunicipiosSelecionados.size} munic√≠pio${plural} selecionado${plural}.`;
    }

    function atualizarCoberturaMunicipiosTags() {
      if (!coberturaMunicipiosTags) return;

      coberturaMunicipiosTags.innerHTML = '';

      if (!coberturaMunicipiosSelecionados.size) {
        atualizarCoberturaMunicipiosFeedback();
        renderCoberturaMunicipiosSugestoes();
        return;
      }

      for (const [codigo, descricao] of coberturaMunicipiosSelecionados.entries()) {
        const tag = document.createElement('span');
        tag.className = 'tag';
        tag.textContent = descricao;

        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.setAttribute('aria-label', `Remover munic√≠pio ${descricao}`);
        removeBtn.textContent = '√ó';
        removeBtn.addEventListener('click', () => {
          coberturaMunicipiosSelecionados.delete(codigo);
          atualizarCoberturaMunicipiosTags();
        });

        tag.append(removeBtn);
        coberturaMunicipiosTags.append(tag);
      }

      atualizarCoberturaMunicipiosFeedback();
      renderCoberturaMunicipiosSugestoes();
      atualizarResumoCobertura();
    }

    function toggleCoberturaMunicipio(codigo, descricao) {
      if (coberturaMunicipiosSelecionados.has(codigo)) {
        coberturaMunicipiosSelecionados.delete(codigo);
      } else {
        coberturaMunicipiosSelecionados.set(codigo, descricao);
      }
      atualizarCoberturaMunicipiosTags();
      if (coberturaMunicipiosInput) {
        coberturaMunicipiosInput.focus();
      }
    }

    function renderCoberturaMunicipiosSugestoes() {
      if (!coberturaMunicipiosSuggestions || !coberturaMunicipiosMultiselect) return;

      const aberto = coberturaMunicipiosMultiselect.classList.contains('open');

      if (!coberturaMunicipiosCache.length) {
        if (aberto) {
          coberturaMunicipiosSuggestions.innerHTML = '<div class="suggestion-empty">Nenhum munic√≠pio dispon√≠vel.</div>';
          coberturaMunicipiosSuggestions.hidden = false;
        }
        return;
      }

      const termo = coberturaMunicipiosInput ? normalizarTexto(coberturaMunicipiosInput.value.trim()) : '';
      const filtrados = coberturaMunicipiosCache.filter(({ descricao, codigo }) => {
        if (!termo) return true;
        const base = `${normalizarTexto(descricao)} ${normalizarTexto(codigo)}`;
        return base.includes(termo);
      });

      const resultados = Number.isFinite(MUNICIPIOS_SUGESTOES_LIMITE)
        ? filtrados.slice(0, MUNICIPIOS_SUGESTOES_LIMITE)
        : filtrados;

      const scrollAnterior = coberturaMunicipiosSuggestions.scrollTop;
      coberturaMunicipiosSuggestions.innerHTML = '';

      if (!resultados.length) {
        const textoBusca = coberturaMunicipiosInput ? coberturaMunicipiosInput.value.trim() : '';
        coberturaMunicipiosSuggestions.innerHTML = textoBusca
          ? `<div class="suggestion-empty">Nenhum munic√≠pio encontrado para "${textoBusca}".</div>`
          : '<div class="suggestion-empty">Nenhum munic√≠pio dispon√≠vel.</div>';
        atualizarCoberturaMunicipiosFeedback(textoBusca
          ? `Nenhum munic√≠pio encontrado para "${textoBusca}".`
          : 'Nenhum munic√≠pio dispon√≠vel para os crit√©rios selecionados.');
        if (aberto) {
          coberturaMunicipiosSuggestions.hidden = false;
        }
        return;
      }

      resultados.forEach(({ codigo, descricao }) => {
        const item = document.createElement('button');
        item.type = 'button';
        item.className = 'suggestion-item';
        item.dataset.codigo = codigo;
        if (coberturaMunicipiosSelecionados.has(codigo)) {
          item.classList.add('selected');
        }
        const titulo = document.createElement('span');
        titulo.textContent = descricao;
        const meta = document.createElement('span');
        meta.className = 'suggestion-meta';
        meta.textContent = codigo;
        item.append(titulo, meta);
        item.addEventListener('click', () => {
          toggleCoberturaMunicipio(codigo, descricao);
        });
        coberturaMunicipiosSuggestions.append(item);
      });

      if (coberturaMunicipiosInput && coberturaMunicipiosInput.value.trim()) {
        const plural = resultados.length === 1 ? '' : 's';
        const selecionados = coberturaMunicipiosSelecionados.size;
        const pluralSel = selecionados === 1 ? '' : 's';
        const trechoSelecionados = selecionados
          ? ` ${selecionados} munic√≠pio${pluralSel} selecionado${pluralSel}.`
          : '';
        coberturaMunicipiosFeedback.textContent = `${resultados.length} munic√≠pio${plural} correspondente${plural} ao filtro.${trechoSelecionados}`;
      } else {
        atualizarCoberturaMunicipiosFeedback();
      }

      if (aberto) {
        coberturaMunicipiosSuggestions.hidden = false;
        coberturaMunicipiosSuggestions.scrollTop = scrollAnterior;
      }
    }

    function abrirCoberturaMunicipiosSugestoes() {
      if (!coberturaMunicipiosMultiselect || !coberturaMunicipiosInput || coberturaMunicipiosInput.disabled) return;
      coberturaMunicipiosMultiselect.classList.add('open');
      renderCoberturaMunicipiosSugestoes();
    }

    function fecharCoberturaMunicipiosSugestoes() {
      if (!coberturaMunicipiosMultiselect || !coberturaMunicipiosSuggestions) return;
      coberturaMunicipiosMultiselect.classList.remove('open');
      coberturaMunicipiosSuggestions.hidden = true;
    }

    async function carregarCoberturaMunicipios(uf, { manterSelecao = false, manterBusca = false, forcarAtualizacao = false } = {}) {
      if (!coberturaMunicipiosInput) return true;

      fecharCoberturaMunicipiosSugestoes();

      const selecaoAnterior = manterSelecao ? new Map(coberturaMunicipiosSelecionados) : new Map();
      const buscaAnterior = manterBusca ? coberturaMunicipiosInput.value : '';

      if (!manterSelecao) {
        coberturaMunicipiosSelecionados.clear();
      }

      if (!manterBusca) {
        coberturaMunicipiosInput.value = '';
      }

      coberturaMunicipiosCache = [];
      coberturaMunicipiosInput.disabled = true;
      atualizarCoberturaMunicipiosTags();
      atualizarCoberturaMunicipiosFeedback(uf ? 'Carregando munic√≠pios‚Ä¶' : 'Selecione uma UF para listar munic√≠pios.');
      if (coberturaMunicipiosSuggestions) {
        coberturaMunicipiosSuggestions.innerHTML = '';
      }

      if (!uf) {
        return true;
      }

      try {
        const dados = await obterMunicipiosPorUf(uf, { ignorarCache: forcarAtualizacao });
        coberturaMunicipiosCache = Array.isArray(dados) ? [...dados] : [];

        if (!coberturaMunicipiosCache.length) {
          atualizarCoberturaMunicipiosFeedback('Nenhum munic√≠pio encontrado para a UF selecionada.');
          return false;
        }

        if (manterSelecao) {
          const novosSelecionados = new Map();
          for (const [codigo, descricao] of selecaoAnterior.entries()) {
            if (coberturaMunicipiosCache.some(m => m.codigo === codigo)) {
              novosSelecionados.set(codigo, descricao);
            }
          }
          coberturaMunicipiosSelecionados = novosSelecionados;
        }

        if (manterBusca) {
          coberturaMunicipiosInput.value = buscaAnterior;
        }

        coberturaMunicipiosInput.disabled = false;
        atualizarCoberturaMunicipiosTags();
        atualizarCoberturaMunicipiosFeedback();
        renderCoberturaMunicipiosSugestoes();
        return true;
      } catch (error) {
        console.error(error);
        atualizarCoberturaMunicipiosFeedback('N√£o foi poss√≠vel carregar os munic√≠pios. Tente novamente.');
        if (coberturaMunicipiosSuggestions) {
          coberturaMunicipiosSuggestions.innerHTML = '<div class="suggestion-empty">N√£o foi poss√≠vel carregar os munic√≠pios.</div>';
        }
        return false;
      }
    }

    function atualizarCoberturaCnaeFeedback(mensagem) {
      if (!coberturaCnaeFeedback) return;

      if (mensagem) {
        coberturaCnaeFeedback.textContent = mensagem;
        return;
      }

      if (!coberturaCnaeSelecionados.size) {
        coberturaCnaeFeedback.textContent = 'Selecione ao menos um CNAE para habilitar a compara√ß√£o.';
        return;
      }

      const plural = coberturaCnaeSelecionados.size === 1 ? '' : 's';
      coberturaCnaeFeedback.textContent = `${coberturaCnaeSelecionados.size} CNAE${plural} selecionado${plural}.`;
    }

    function atualizarCoberturaCompararEstado() {
      if (!coberturaSubmitBtn) return;
      const possuiPesquisa = Array.isArray(ultimoResultado) && ultimoResultado.length > 0;
      const possuiArquivo = Array.isArray(coberturaResumoAtual.lista) && coberturaResumoAtual.lista.length > 0;
      let titulo = '';
      let desabilitar = false;

      if (!possuiPesquisa) {
        desabilitar = true;
        titulo = 'Realize uma pesquisa na aba Lista CNPJ para habilitar a cobertura.';
      } else if (!possuiArquivo) {
        desabilitar = true;
        titulo = 'Importe um arquivo CSV com os CNPJs que deseja comparar.';
      }

      coberturaSubmitBtn.disabled = desabilitar;
      coberturaSubmitBtn.title = titulo;
    }

    function atualizarCoberturaCnaeTags() {
      if (!coberturaCnaeTags) return;

      coberturaCnaeTags.innerHTML = '';

      if (!coberturaCnaeSelecionados.size) {
        atualizarCoberturaCnaeFeedback();
        renderCoberturaCnaeSugestoes();
        atualizarCoberturaCompararEstado();
        atualizarResumoCobertura();
        return;
      }

      for (const [codigo, descricao] of coberturaCnaeSelecionados.entries()) {
        const tag = document.createElement('span');
        tag.className = 'tag';
        tag.textContent = `${codigo} ¬∑ ${descricao}`;

        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.setAttribute('aria-label', `Remover CNAE ${codigo}`);
        removeBtn.textContent = '√ó';
        removeBtn.addEventListener('click', () => {
          coberturaCnaeSelecionados.delete(codigo);
          atualizarCoberturaCnaeTags();
        });

        tag.append(removeBtn);
        coberturaCnaeTags.append(tag);
      }

      atualizarCoberturaCnaeFeedback();
      renderCoberturaCnaeSugestoes();
      atualizarCoberturaCompararEstado();
      atualizarResumoCobertura();
    }

    function toggleCoberturaCnae(codigo, descricao) {
      if (coberturaCnaeSelecionados.has(codigo)) {
        coberturaCnaeSelecionados.delete(codigo);
      } else {
        coberturaCnaeSelecionados.set(codigo, descricao);
      }
      atualizarCoberturaCnaeTags();
      if (coberturaCnaeInput) {
        coberturaCnaeInput.focus();
      }
    }

    function renderCoberturaCnaeSugestoes() {
      if (!coberturaCnaeSuggestions || !coberturaCnaeMultiselect) return;

      const aberto = coberturaCnaeMultiselect.classList.contains('open');

      if (!coberturaCnaeCache.length) {
        if (aberto) {
          coberturaCnaeSuggestions.innerHTML = '<div class="suggestion-empty">Nenhum CNAE dispon√≠vel.</div>';
          coberturaCnaeSuggestions.hidden = false;
        }
        return;
      }

      const scrollAnterior = coberturaCnaeSuggestions.scrollTop;
      coberturaCnaeSuggestions.innerHTML = '';

      coberturaCnaeCache.forEach(({ codigo, descricao }) => {
        const item = document.createElement('button');
        item.type = 'button';
        item.className = 'suggestion-item';
        item.dataset.codigo = codigo;
        if (coberturaCnaeSelecionados.has(codigo)) {
          item.classList.add('selected');
        }
        const titulo = document.createElement('span');
        titulo.textContent = descricao;
        const meta = document.createElement('span');
        meta.className = 'suggestion-meta';
        meta.textContent = codigo;
        item.append(titulo, meta);
        item.addEventListener('click', () => {
          toggleCoberturaCnae(codigo, descricao);
        });
        coberturaCnaeSuggestions.append(item);
      });

      if (coberturaCnaeInput && coberturaCnaeInput.value.trim()) {
        const plural = coberturaCnaeCache.length === 1 ? '' : 's';
        const selecionados = coberturaCnaeSelecionados.size;
        const pluralSel = selecionados === 1 ? '' : 's';
        const trechoSelecionados = selecionados
          ? ` ${selecionados} CNAE${pluralSel} selecionado${pluralSel}.`
          : '';
        coberturaCnaeFeedback.textContent = `${coberturaCnaeCache.length} CNAE${plural} correspondente${plural} ao filtro.${trechoSelecionados}`;
      } else {
        atualizarCoberturaCnaeFeedback();
      }

      if (aberto) {
        coberturaCnaeSuggestions.hidden = false;
        coberturaCnaeSuggestions.scrollTop = scrollAnterior;
      }
    }

    function abrirCoberturaCnaeSugestoes() {
      if (!coberturaCnaeMultiselect || !coberturaCnaeInput) return;
      coberturaCnaeMultiselect.classList.add('open');
      renderCoberturaCnaeSugestoes();
    }

    function fecharCoberturaCnaeSugestoes() {
      if (!coberturaCnaeMultiselect || !coberturaCnaeSuggestions) return;
      coberturaCnaeMultiselect.classList.remove('open');
      coberturaCnaeSuggestions.hidden = true;
    }

    async function buscarCoberturaCnaes(termo, { forcar = false } = {}) {
      const consulta = (termo || '').trim();

      if (!forcar && coberturaUltimoCnaeTermo === consulta && coberturaCnaeCache.length) {
        abrirCoberturaCnaeSugestoes();
        return;
      }

      coberturaUltimoCnaeTermo = consulta;

      try {
        abrirCoberturaCnaeSugestoes();
        coberturaCnaeSuggestions.innerHTML = '<div class="suggestion-empty">Carregando CNAEs‚Ä¶</div>';
        const dados = await obterCnaesPorTermo(consulta, { ignorarCache: forcar });
        coberturaCnaeCache = Array.isArray(dados) ? dados.slice(0, CNAE_SUGESTOES_LIMITE) : [];
        renderCoberturaCnaeSugestoes();
      } catch (error) {
        console.error(error);
        coberturaCnaeSuggestions.innerHTML = '<div class="suggestion-empty">N√£o foi poss√≠vel carregar os CNAEs.</div>';
        abrirCoberturaCnaeSugestoes();
        atualizarCoberturaCnaeFeedback('N√£o foi poss√≠vel carregar os CNAEs no momento.');
      }
    }

    function coletarValoresCheckbox(container) {
      return [...container.querySelectorAll('input[type="checkbox"]:checked')].map(input => input.value);
    }

    function cancelarPesquisa() {
      if (currentFetchController) {
        currentFetchController.abort();
        cancelarBtn.disabled = true;
      }
    }

    async function realizarBusca(event) {
      event.preventDefault();

      cancelarPesquisa();
      const uf = ufSelect.value;
      if (!uf) {
        statusMessage.textContent = 'Selecione uma UF para realizar a pesquisa.';
        ufSelect.focus();
        return;
      }

      const params = new URLSearchParams();
      params.append('uf', uf);

      if (setorSelect && setorSelect.value) {
        params.append('setor', setorSelect.value);
      }
      if (segmentoSelect && segmentoSelect.value) {
        params.append('segmento', segmentoSelect.value);
      }

      selectedMunicipios.forEach((_, codigo) => params.append('municipio', codigo));
      selectedCnaes.forEach((_, codigo) => params.append('cnae', codigo));

      coletarValoresCheckbox(porteCheckboxes).forEach(porte => params.append('porte', porte));
      coletarValoresCheckbox(situacaoCheckboxes).forEach(situacao => params.append('situacao', situacao));

      statusMessage.textContent = 'Buscando dados‚Ä¶';
      atualizarStatusCount('loading');
      resultadosCorpo.innerHTML = `<tr class="empty-state"><td colspan="10">Carregando resultados‚Ä¶</td></tr>`;
      exportarBtn.disabled = true;

      currentFetchController = new AbortController();
      const controladorAtual = currentFetchController;
      cancelarBtn.disabled = false;

      try {
        const url = construirUrlApi('/buscar', params);
        url.searchParams.set('_', Date.now());
        const response = await fetch(url.toString(), {
          signal: controladorAtual.signal,
          cache: 'no-store'
        });
        if (!response.ok) throw new Error('Erro ao buscar dados');
        const dados = await response.json();
        atualizarResultados(dados);
      } catch (error) {
        if (error.name === 'AbortError') {
          if (currentFetchController && currentFetchController !== controladorAtual) {
            return;
          }
          if (ultimoResultado.length > 0) {
            renderizarTabela(ultimoResultado);
            atualizarStatusCount(ultimoResultado.length);
            statusMessage.textContent = 'Pesquisa cancelada. Resultados anteriores mantidos.';
            exportarBtn.disabled = false;
          } else {
            limparResultados('Pesquisa cancelada pelo usu√°rio.');
          }
        } else {
          console.error(error);
          limparResultados('Ocorreu um erro ao buscar os dados. Tente novamente.');
        }
      } finally {
        if (currentFetchController === controladorAtual) {
          cancelarBtn.disabled = true;
          currentFetchController = null;
        }
      }
    }

    function limparFiltros() {
      cancelarPesquisa();
      filtrosForm.reset();
      selectedMunicipios.clear();
      selectedCnaes.clear();
      cnaeInput.value = '';
      fecharCnaeSugestoes();
      cnaeSuggestions.innerHTML = '';
      ultimoCnaeTermo = null;
      cnaeCache = [];
      municipiosCache = [];
      fecharMunicipiosSugestoes();
      municipiosInput.value = '';
      municipiosInput.disabled = true;
      municipiosSuggestions.innerHTML = '';
      atualizarMunicipiosFeedback('Selecione uma UF para listar munic√≠pios.');
      atualizarMunicipiosTags();
      atualizarCnaeTags();
      statusMessage.textContent = 'Filtros redefinidos. Selecione uma UF para come√ßar.';
      limparResultados('Nenhuma pesquisa realizada ainda.');

      if (setorSelect) setorSelect.value = "";
      if (segmentoSelect) {
        segmentoSelect.value = "";
        segmentoSelect.innerHTML = '<option value="">Selecione um Setor primeiro</option>';
        segmentoSelect.disabled = true;
      }}


    function renderCnaeSugestoes(lista = cnaeCache) {
      const aberto = cnaeMultiselect.classList.contains('open');

      if (!lista || lista.length === 0) {
        cnaeSuggestions.innerHTML = '<div class="suggestion-empty">Nenhum CNAE encontrado.</div>';
        if (cnaeInput.value.trim()) {
          const termo = cnaeInput.value.trim();
          atualizarCnaeFeedback(`Nenhum CNAE encontrado para "${termo}".`);
        } else {
          atualizarCnaeFeedback();
        }
        if (aberto) {
          cnaeSuggestions.hidden = false;
        }
        return;
      }

      const scrollAnterior = cnaeSuggestions.scrollTop;
      cnaeSuggestions.innerHTML = '';

      lista.forEach(({ codigo, descricao }) => {
        const item = document.createElement('button');
        item.type = 'button';
        item.className = 'suggestion-item';
        item.dataset.codigo = codigo;
        if (selectedCnaes.has(codigo)) {
          item.classList.add('selected');
        }
        const titulo = document.createElement('span');
        titulo.textContent = descricao;
        const meta = document.createElement('span');
        meta.className = 'suggestion-meta';
        meta.textContent = codigo;
        item.append(titulo, meta);
        item.addEventListener('click', () => {
          if (selectedCnaes.has(codigo)) {
            selectedCnaes.delete(codigo);
          } else {
            selectedCnaes.set(codigo, descricao);
          }
          atualizarCnaeTags();
          renderCnaeSugestoes();
          cnaeInput.focus();
        });
        cnaeSuggestions.append(item);
      });

      if (cnaeInput.value.trim()) {
        const plural = lista.length === 1 ? '' : 's';
        const selecionados = selectedCnaes.size;
        const pluralSel = selecionados === 1 ? '' : 's';
        const trechoSelecionados = selecionados
          ? ` ${selecionados} CNAE${pluralSel} selecionado${pluralSel}.`
          : '';
        cnaeFeedback.textContent = `${lista.length} CNAE${plural} correspondente${plural} ao filtro.${trechoSelecionados}`;
      } else {
        atualizarCnaeFeedback();
      }

      if (aberto) {
        cnaeSuggestions.hidden = false;
        cnaeSuggestions.scrollTop = scrollAnterior;
      }
    }

    function abrirCnaeSugestoes() {
      cnaeMultiselect.classList.add('open');
      renderCnaeSugestoes();
    }

    function fecharCnaeSugestoes() {
      cnaeMultiselect.classList.remove('open');
      cnaeSuggestions.hidden = true;
    }

    async function buscarCnaes(termo, { forcar = false } = {}) {
      const consulta = (termo || '').trim();

      if (!forcar && ultimoCnaeTermo === consulta && cnaeCache.length) {
        abrirCnaeSugestoes();
        return;
      }

      ultimoCnaeTermo = consulta;

      try {
        abrirCnaeSugestoes();
        cnaeSuggestions.innerHTML = '<div class="suggestion-empty">Carregando CNAEs‚Ä¶</div>';
        const dados = await obterCnaesPorTermo(consulta, { ignorarCache: forcar });
        cnaeCache = Array.isArray(dados) ? dados.slice(0, CNAE_SUGESTOES_LIMITE) : [];
        renderCnaeSugestoes();
      } catch (error) {
        console.error(error);
        cnaeSuggestions.innerHTML = '<div class="suggestion-empty">N√£o foi poss√≠vel carregar os CNAEs.</div>';
        abrirCnaeSugestoes();
        atualizarCnaeFeedback('N√£o foi poss√≠vel carregar os CNAEs no momento.');
      }
    }

    ufSelect.addEventListener('change', () => {
      buscarMunicipios(ufSelect.value);
    });

    municipiosInput.addEventListener('focus', () => {
      if (!municipiosInput.disabled) {
        abrirMunicipiosSugestoes();
      }
    });

    municipiosInput.addEventListener('click', () => {
      if (!municipiosInput.disabled) {
        abrirMunicipiosSugestoes();
      }
    });

    municipiosInput.addEventListener('input', () => {
      if (municipiosInput.disabled) return;
      abrirMunicipiosSugestoes();
      renderMunicipiosSugestoes();
    });

    municipiosInput.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        event.stopPropagation();
        municipiosInput.value = '';
        renderMunicipiosSugestoes();
        fecharMunicipiosSugestoes();
      }

      if (event.key === 'Enter') {
        event.preventDefault();
        abrirMunicipiosSugestoes();
        const primeiro = municipiosSuggestions.querySelector('.suggestion-item');
        if (primeiro) {
          primeiro.click();
        }
      }
    });

    cnaeInput.addEventListener('focus', () => {
      abrirCnaeSugestoes();
      buscarCnaes(cnaeInput.value, { forcar: true });
    });

    cnaeInput.addEventListener('click', () => {
      abrirCnaeSugestoes();
      if (!cnaeCache.length) {
        buscarCnaes(cnaeInput.value, { forcar: true });
      }
    });

    cnaeInput.addEventListener('input', (event) => {
      const termo = event.target.value;
      clearTimeout(cnaeDebounce);
      abrirCnaeSugestoes();
      cnaeDebounce = setTimeout(() => buscarCnaes(termo), 250);
    });

    cnaeInput.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        event.stopPropagation();
        cnaeInput.value = '';
        ultimoCnaeTermo = null;
        cnaeCache = [];
        cnaeSuggestions.innerHTML = '';
        fecharCnaeSugestoes();
        atualizarCnaeFeedback();
      }

      if (event.key === 'Enter') {
        event.preventDefault();
        buscarCnaes(event.target.value, { forcar: true });
      }
    });

    document.addEventListener('click', (event) => {
      if (!municipiosMultiselect.contains(event.target)) {
        fecharMunicipiosSugestoes();
      }
      if (!cnaeMultiselect.contains(event.target)) {
        fecharCnaeSugestoes();
      }
      if (coberturaMunicipiosMultiselect && !coberturaMunicipiosMultiselect.contains(event.target)) {
        fecharCoberturaMunicipiosSugestoes();
      }
      if (coberturaCnaeMultiselect && !coberturaCnaeMultiselect.contains(event.target)) {
        fecharCoberturaCnaeSugestoes();
      }
    });

    async function processarArquivoCsv(arquivo) {
      if (!arquivo) {
        limparImportacao();
        return;
      }

      try {
        const conteudo = await arquivo.text();
        const registros = extrairItensDoCsv(conteudo);
        csvRegistros = registros;
        importacaoMunicipiosDePara = new Map();
        importacaoMunicipiosDisponiveis = new Map();
        importacaoMunicipiosSelecionadosPorUf = new Map();
        importacaoUfDisponiveis = new Map();
        importacaoUfSelecionada = '';
        importacaoCnpjsRemovidosPorUf = new Map();
        if (importacaoArquivoFeedback) {
          if (!registros.length) {
            importacaoArquivoFeedback.textContent = 'Nenhum registro reconhecido no arquivo.';
          } else {
            const plural = registros.length === 1 ? '' : 's';
            importacaoArquivoFeedback.textContent = `${registros.length} registro${plural} identificado${plural} no arquivo.`;
          }
        }
      } catch (error) {
        console.error(error);
        csvRegistros = [];
        importacaoMunicipiosDePara = new Map();
        importacaoMunicipiosDisponiveis = new Map();
        importacaoMunicipiosSelecionadosPorUf = new Map();
        importacaoUfDisponiveis = new Map();
        importacaoUfSelecionada = '';
        importacaoCnpjsRemovidosPorUf = new Map();
        if (importacaoArquivoFeedback) {
          importacaoArquivoFeedback.textContent = 'N√£o foi poss√≠vel ler o arquivo. Verifique se est√° em formato CSV.';
        }
        limparImportacaoMunicipiosSelecao();
      }

      atualizarResumoImportacao();
    }

    function atualizarResumoCobertura() {
      const { lista, invalidos } = consolidarRegistrosParaEnvio(coberturaRegistros);
      coberturaResumoAtual = { lista, invalidos };

      if (!coberturaResumo) {
        atualizarCoberturaCompararEstado();
        return coberturaResumoAtual;
      }

      if (!coberturaRegistros.length) {
        coberturaResumo.textContent = 'Nenhum CNPJ informado.';
        atualizarCoberturaCompararEstado();
        return coberturaResumoAtual;
      }

      if (!lista.length) {
        if (invalidos.length) {
          coberturaResumo.textContent = `${invalidos.length} registro${invalidos.length === 1 ? '' : 's'} ignorado${invalidos.length === 1 ? '' : 's'} por CNPJ inv√°lido.`;
        } else {
          coberturaResumo.textContent = 'Nenhum CNPJ v√°lido identificado no arquivo.';
        }
        atualizarCoberturaCompararEstado();
        return coberturaResumoAtual;
      }

      const plural = lista.length === 1 ? '' : 's';
      const trechoInvalidos = invalidos.length
        ? ` ‚Ä¢ ${invalidos.length} registro${invalidos.length === 1 ? '' : 's'} ignorado${invalidos.length === 1 ? '' : 's'}.`
        : '';
      coberturaResumo.textContent = `${formatadorNumero.format(lista.length)} CNPJ${plural} dispon√≠vel${plural} para cobertura.${trechoInvalidos}`;

      atualizarCoberturaCompararEstado();
      return coberturaResumoAtual;
    }

    function limparCoberturaTabela(mensagem = 'Nenhum resultado dispon√≠vel.') {
      ultimoCoberturaResultado = [];
      if (coberturaCorpo) {
        coberturaCorpo.innerHTML = `<tr class="empty-state"><td colspan="11">${mensagem}</td></tr>`;
      }
      if (coberturaCount) {
        coberturaCount.textContent = 'Nenhum resultado dispon√≠vel.';
      }
      if (coberturaExportarBtn) {
        coberturaExportarBtn.disabled = true;
      }
    }

    function prepararCoberturaParaNovaPesquisa(possuiResultados) {
      limparCoberturaTabela('Nenhum resultado dispon√≠vel.');
      if (coberturaStatus) {
        coberturaStatus.textContent = possuiResultados
          ? 'Importe um arquivo CSV para verificar a cobertura desta pesquisa.'
          : 'Realize uma pesquisa na aba Lista CNPJ para habilitar a cobertura.';
      }
      atualizarCoberturaCompararEstado();
    }

    function renderizarCoberturaTabela(dados) {
      if (!coberturaCorpo) return;
      coberturaCorpo.innerHTML = '';

      dados.forEach(item => {
        const statusClasse = item.statusClasse || (item.encontrado ? 'atendido' : 'nao-atendido');
        const statusTexto = item.status || (item.encontrado ? 'Atendido' : 'N√£o atendido');
        const statusHtml = `<span class="status-pill ${statusClasse}">${statusTexto}</span>`;
        const codigoHtml = item.codigo_externo
          ? `<span class="value-meta">C√≥digo externo: ${item.codigo_externo}</span>`
          : '';
        const cnpjDisplay = item.cnpj || formatarCnpjVisivel(item.cnpj_export || item.cnpj_normalizado || '');
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${statusHtml}${codigoHtml}</td>
          <td>${cnpjDisplay || ''}</td>
          <td>${item.razao_social || ''}</td>
          <td>${item.endereco || ''}</td>
          <td>${item.cep || ''}</td>
          <td>${item.telefone_1 || ''}</td>
          <td>${item.telefone_2 || ''}</td>
          <td>${item.email || ''}</td>
          <td>${item.cnae || ''}</td>
          <td>${item.situacao || ''}</td>
          <td>${item.motivo || ''}</td>
        `;
        coberturaCorpo.append(tr);
      });
    }

    function limparCobertura() {
      coberturaRegistros = [];
      coberturaMunicipiosSelecionados.clear();
      coberturaCnaeSelecionados.clear();
      coberturaMunicipiosCache = [];
      coberturaCnaeCache = [];
      coberturaUltimoCnaeTermo = null;
      coberturaMunicipiosDePara.clear();
      if (coberturaArquivoInput) {
        coberturaArquivoInput.value = '';
      }
      if (coberturaArquivoFeedback) {
        coberturaArquivoFeedback.textContent = '';
      }
      if (coberturaUfSelect) {
        coberturaUfSelect.value = '';
      }
      if (coberturaMunicipiosInput) {
        coberturaMunicipiosInput.value = '';
        coberturaMunicipiosInput.disabled = true;
      }
      if (coberturaMunicipiosSuggestions) {
        coberturaMunicipiosSuggestions.innerHTML = '';
      }
      atualizarCoberturaMunicipiosTags();
      if (coberturaCnaeInput) {
        coberturaCnaeInput.value = '';
      }
      if (coberturaCnaeSuggestions) {
        coberturaCnaeSuggestions.innerHTML = '';
      }
      atualizarCoberturaCnaeTags();
      if (coberturaStatus) {
        coberturaStatus.textContent = 'Carregue um arquivo para iniciar a compara√ß√£o.';
      }
      limparCoberturaTabela();
      atualizarCoberturaCompararEstado();
      atualizarResumoCobertura();
      atualizarCoberturaValidarMunicipiosEstado();
    }

    async function processarCoberturaArquivo(arquivo) {
      if (!arquivo) {
        coberturaRegistros = [];
        coberturaMunicipiosDePara.clear();
        if (coberturaArquivoFeedback) {
          coberturaArquivoFeedback.textContent = '';
        }
        atualizarResumoCobertura();
        atualizarCoberturaValidarMunicipiosEstado();
        return;
      }

      try {
        const conteudo = await arquivo.text();
        const registros = extrairItensDoCsv(conteudo);
        coberturaRegistros = registros;
        coberturaMunicipiosDePara.clear();
        if (coberturaArquivoFeedback) {
          if (!registros.length) {
            coberturaArquivoFeedback.textContent = 'Nenhum registro reconhecido no arquivo.';
          } else {
            const plural = registros.length === 1 ? '' : 's';
            coberturaArquivoFeedback.textContent = `${registros.length} registro${plural} identificado${plural} no arquivo.`;
          }
        }
      } catch (error) {
        console.error(error);
        coberturaRegistros = [];
        coberturaMunicipiosDePara.clear();
        if (coberturaArquivoFeedback) {
          coberturaArquivoFeedback.textContent = 'N√£o foi poss√≠vel ler o arquivo. Verifique se est√° em formato CSV.';
        }
      }

      atualizarResumoCobertura();
      atualizarCoberturaValidarMunicipiosEstado();
      atualizarCoberturaCompararEstado();
      atualizarAbaMapa();
    }

    if (importacaoArquivoInput) {
      importacaoArquivoInput.addEventListener('change', (event) => {
        const [arquivo] = event.target.files || [];
        processarArquivoCsv(arquivo);
      });
    }

    if (importacaoLimparBtn) {
      importacaoLimparBtn.addEventListener('click', () => {
        limparImportacao();
      });
    }

    if (importacaoUfSelect) {
      importacaoUfSelect.addEventListener('change', () => {
        importacaoUfSelecionada = importacaoUfSelect.value || '';
        atualizarResumoImportacao();
      });
    }

    if (importacaoConciliarMunicipiosBtn) {
      importacaoConciliarMunicipiosBtn.addEventListener('click', async () => {
        await abrirImportacaoMunicipiosModal();
        if (importacaoMunicipiosModalSalvar) {
          importacaoMunicipiosModalSalvar.focus();
        }
      });
    }

    if (importacaoMunicipiosSelecionarTodosBtn) {
      importacaoMunicipiosSelecionarTodosBtn.addEventListener('click', () => {
        if (!importacaoUfSelecionada) return;
        const municipiosMap = importacaoMunicipiosDisponiveis.get(importacaoUfSelecionada);
        if (!municipiosMap || municipiosMap.size === 0) return;
        let selecionados = importacaoMunicipiosSelecionadosPorUf.get(importacaoUfSelecionada);
        if (!selecionados) {
          selecionados = new Set();
          importacaoMunicipiosSelecionadosPorUf.set(importacaoUfSelecionada, selecionados);
        }
        municipiosMap.forEach((_, chave) => selecionados.add(chave));
        importacaoMunicipiosSelecaoManual.add(importacaoUfSelecionada);
        atualizarResumoImportacao();
      });
    }

    if (importacaoMunicipiosSelecionarNenhumBtn) {
      importacaoMunicipiosSelecionarNenhumBtn.addEventListener('click', () => {
        if (!importacaoUfSelecionada) return;
        const selecionados = importacaoMunicipiosSelecionadosPorUf.get(importacaoUfSelecionada);
        if (!selecionados) return;
        selecionados.clear();
        importacaoMunicipiosSelecaoManual.add(importacaoUfSelecionada);
        atualizarResumoImportacao();
      });
    }

    if (importacaoMunicipiosModalSalvar) {
      importacaoMunicipiosModalSalvar.addEventListener('click', () => {
        aplicarImportacaoMunicipiosSelecao();
        fecharImportacaoMunicipiosModal();
        if (importacaoConciliarMunicipiosBtn) {
          importacaoConciliarMunicipiosBtn.focus();
        }
      });
    }

    if (importacaoMunicipiosModalCancelar) {
      importacaoMunicipiosModalCancelar.addEventListener('click', () => {
        fecharImportacaoMunicipiosModal();
        if (importacaoConciliarMunicipiosBtn) {
          importacaoConciliarMunicipiosBtn.focus();
        }
      });
    }

    if (importacaoMunicipiosModalFechar) {
      importacaoMunicipiosModalFechar.addEventListener('click', () => {
        fecharImportacaoMunicipiosModal();
        if (importacaoConciliarMunicipiosBtn) {
          importacaoConciliarMunicipiosBtn.focus();
        }
      });
    }

    if (importacaoForm) {
      importacaoForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        const { lista, invalidos, total } = atualizarResumoImportacao();
        const municipiosMapAtual = importacaoUfSelecionada
          ? importacaoMunicipiosDisponiveis.get(importacaoUfSelecionada)
          : null;
        const selecionadosMunicipios = importacaoUfSelecionada
          ? importacaoMunicipiosSelecionadosPorUf.get(importacaoUfSelecionada)
          : null;
        const nenhumMunicipioSelecionado = Boolean(
          municipiosMapAtual
          && municipiosMapAtual.size > 0
          && (!selecionadosMunicipios || selecionadosMunicipios.size === 0)
        );

        if (importacaoUfDisponiveis.size === 0) {
          if (importacaoStatus) {
            importacaoStatus.textContent = 'Nenhuma UF reconhecida no arquivo. Ajuste os dados antes de continuar.';
          }
          return;
        }

        if (!importacaoUfSelecionada) {
          if (importacaoStatus) {
            importacaoStatus.textContent = 'Selecione uma UF reconhecida para realizar a an√°lise.';
          }
          return;
        }

        if (!lista.length) {
          let mensagem;
          if (nenhumMunicipioSelecionado) {
            mensagem = 'Selecione ao menos um munic√≠pio para realizar a an√°lise.';
          } else if (total > 0 || invalidos.length) {
            mensagem = 'Nenhum CNPJ v√°lido identificado para a UF selecionada.';
          } else {
            mensagem = 'Informe ao menos um CNPJ para realizar a an√°lise.';
          }
          if (importacaoStatus) {
            importacaoStatus.textContent = mensagem;
          }
          if (importacaoCorpo) {
            importacaoCorpo.innerHTML = '<tr class="empty-state"><td colspan="8">Nenhum CNPJ v√°lido informado.</td></tr>';
          }
          if (importacaoExportarBtn) {
            importacaoExportarBtn.disabled = true;
          }
          if (importacaoCount) {
            importacaoCount.textContent = 'Nenhum resultado dispon√≠vel.';
          }
          ultimoImportacaoResultado = [];
          return;
        }

        const totalSolicitado = lista.length;
        const municipioCodigosSet = new Set();
        const municipioNomesSet = new Set();

        lista.forEach(item => {
          (Array.isArray(item.municipio_codigos) ? item.municipio_codigos : []).forEach(valor => {
            if (valor !== null && valor !== undefined && String(valor).trim()) {
              municipioCodigosSet.add(String(valor).trim());
            }
          });
          const nomeMunicipio = item.municipio_resolvido || item.municipio_original || item.municipio || '';
          if (nomeMunicipio) {
            municipioNomesSet.add(nomeMunicipio);
          }
        });

        if (importacaoStatus) {
          importacaoStatus.textContent = 'Analisando lista de CNPJs‚Ä¶';
        }
        if (importacaoCount) {
          importacaoCount.textContent = 'Processando an√°lise‚Ä¶';
        }
        if (importacaoCorpo) {
          importacaoCorpo.innerHTML = '<tr class="empty-state"><td colspan="8">Analisando dados‚Ä¶</td></tr>';
        }
        if (importacaoExportarBtn) {
          importacaoExportarBtn.disabled = true;
        }

        try {
          const itensPayload = lista.map(item => {
            const cnpjNormalizado = normalizarCnpj(item.cnpj);
            return {
              codigo_externo: item.codigo_externo || '',
              cnpj: cnpjNormalizado || item.cnpj || '',
              uf: importacaoUfSelecionada,
              municipio: item.municipio_resolvido || item.municipio_original || item.municipio || '',
              municipio_codigos: Array.isArray(item.municipio_codigos) ? item.municipio_codigos : []
            };
          });

          const response = await apiFetch('/importacao/cnpjs', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              uf: importacaoUfSelecionada,
              municipio_codigos: Array.from(municipioCodigosSet),
              municipio_nomes: Array.from(municipioNomesSet),
              itens: itensPayload
            }),
            cache: 'no-store'
          });

          if (response.status === 413) {
            throw Object.assign(new Error('Payload too large'), { name: 'PayloadTooLargeError' });
          }

          const corpoResposta = await response.text();

          if (!response.ok) {
            let mensagemErro = 'Erro ao analisar CNPJs';
            if (corpoResposta) {
              try {
                const payloadErro = JSON.parse(corpoResposta);
                if (payloadErro && typeof payloadErro.mensagem === 'string' && payloadErro.mensagem.trim()) {
                  mensagemErro = payloadErro.mensagem.trim();
                } else if (typeof payloadErro?.detalhes === 'string' && payloadErro.detalhes.trim()) {
                  mensagemErro = payloadErro.detalhes.trim();
                } else {
                  mensagemErro = corpoResposta.trim();
                }
              } catch (parseError) {
                if (corpoResposta.trim()) {
                  mensagemErro = corpoResposta.trim();
                }
              }
            }
            throw new Error(mensagemErro);
          }

          let dados = {};
          if (corpoResposta) {
            try {
              dados = JSON.parse(corpoResposta);
            } catch (parseError) {
              throw new Error('N√£o foi poss√≠vel interpretar a resposta da an√°lise.');
            }
          }
          const itens = Array.isArray(dados.itens) ? dados.itens : [];
          const mapaEntrada = new Map(lista.map(item => [item.cnpj, item]));
          const itensMap = new Map(itens.map(item => [item.cnpj, item]));
          const itensComOrigem = lista
            .map(item => {
              const retorno = itensMap.get(item.cnpj);
              if (!retorno) {
                return null;
              }
              const origem = mapaEntrada.get(item.cnpj) || {};
              return {
                codigo_externo: retorno.codigo_externo || origem.codigo_externo || '',
                cnpj: retorno.cnpj,
                razao_social: retorno.razao_social || null,
                orgao: retorno.orgao || null,
                tipo_situacao_inscricao: retorno.tipo_situacao_inscricao || null,
                situacao_inscricao: retorno.situacao_inscricao || null,
                receita_principal: retorno.receita_principal || null,
                valor_consolidado: retorno.valor_consolidado,
                uf_informado: origem.uf || importacaoUfSelecionada || '',
                municipio_informado: origem.municipio_resolvido || origem.municipio_original || origem.municipio || '',
                municipio_nome: retorno.municipio_nome || null,
                municipio_codigo: retorno.municipio_codigo || null
              };
            })
            .filter(Boolean);

          ultimoImportacaoResultado = itensComOrigem;

          if (itensComOrigem.length) {
            renderizarImportacaoTabela(itensComOrigem);
          } else if (importacaoCorpo) {
            importacaoCorpo.innerHTML = '<tr class="empty-state"><td colspan="8">Nenhuma empresa encontrada para os CNPJs enviados.</td></tr>';
          }

          const encontrados = typeof dados.encontrados === 'number'
            ? dados.encontrados
            : itensComOrigem.length;
          const naoEncontrados = typeof dados.nao_encontrados === 'number'
            ? dados.nao_encontrados
            : Math.max(totalSolicitado - encontrados, 0);

          const trechoInvalidos = invalidos.length
            ? ` ‚Ä¢ ${invalidos.length} registro${invalidos.length === 1 ? '' : 's'} ignorado${invalidos.length === 1 ? '' : 's'} por CNPJ inv√°lido.`
            : '';

          if (importacaoCount) {
            const pluralEncontrados = encontrados === 1 ? '' : 's';
            const pluralNao = naoEncontrados === 1 ? '' : 's';
            let textoResumo = '';
            if (encontrados > 0) {
              textoResumo = `${formatadorNumero.format(encontrados)} CNPJ${pluralEncontrados} localizado${pluralEncontrados} na base de inativos`;
            } else {
              textoResumo = 'Nenhum CNPJ da lista foi localizado na base de inativos';
            }
            if (naoEncontrados > 0) {
              textoResumo += ` ‚Ä¢ ${formatadorNumero.format(naoEncontrados)} CNPJ${pluralNao} da lista n√£o encontrado${pluralNao}.`;
            } else {
              textoResumo += '.';
            }
            importacaoCount.textContent = `${textoResumo}${trechoInvalidos}`.trim();
          }

          if (importacaoStatus) {
            importacaoStatus.textContent = itensComOrigem.length
              ? `An√°lise conclu√≠da para a UF ${importacaoUfSelecionada}.`
              : 'Nenhum CNPJ da lista foi localizado na base para a UF selecionada.';
          }

          if (importacaoExportarBtn) {
            importacaoExportarBtn.disabled = itensComOrigem.length === 0;
          }
        } catch (error) {
          console.error(error);
          const mensagemErro = error.name === 'PayloadTooLargeError'
            ? 'A lista enviada √© muito grande para processar de uma vez. Divida o arquivo e tente novamente.'
            : (error.message || 'N√£o foi poss√≠vel analisar os CNPJs no momento. Tente novamente.');

          if (importacaoStatus) {
            importacaoStatus.textContent = mensagemErro;
          }

          limparImportacaoTabela(error.name === 'PayloadTooLargeError'
            ? 'A lista enviada excede o limite permitido.'
            : (mensagemErro || 'N√£o foi poss√≠vel concluir a an√°lise.'));
        }
      });
    }

    if (importacaoExportarBtn) {
      importacaoExportarBtn.addEventListener('click', () => {
        if (!ultimoImportacaoResultado.length) return;

        const cabecalho = [
          'codigo_externo',
          'cnpj',
          'razao_social',
          'orgao',
          'tipo_situacao_inscricao',
          'situacao_inscricao',
          'receita_principal',
          'valor_consolidado',
          'uf_informado',
          'municipio_informado',
          'status_encontrado'
        ];

        const linhas = ultimoImportacaoResultado.map(item => {
          const valorDivida = typeof item.valor_consolidado === 'number' && !Number.isNaN(item.valor_consolidado)
            ? formatadorMoeda.format(item.valor_consolidado)
            : '';
          const encontrado = Boolean(
            item.orgao
            || item.tipo_situacao_inscricao
            || item.receita_principal
            || (typeof item.valor_consolidado === 'number' && !Number.isNaN(item.valor_consolidado))
            || (item.razao_social && item.razao_social.trim())
          );
          return [
            item.codigo_externo || '',
            formatarCnpjParaCsv(item.cnpj),
            item.razao_social || '',
            item.orgao || '',
            item.tipo_situacao_inscricao || '',
            item.situacao_inscricao || '',
            item.receita_principal || '',
            valorDivida,
            item.uf_informado || '',
            item.municipio_informado || '',
            encontrado ? 'Sim' : 'Nao'
          ];
        });

        const conteudo = '\ufeff' + [cabecalho, ...linhas]
          .map(colunas => colunas.map(escaparCsv).join(';'))
          .join('\n');

        const blob = new Blob([conteudo], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const dataAtual = new Date().toISOString().slice(0, 10);
        const link = document.createElement('a');
        link.href = url;
        link.download = `analise_inativos_${dataAtual}.csv`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      });
    }

    if (coberturaArquivoInput) {
      coberturaArquivoInput.addEventListener('change', (event) => {
        const [arquivo] = event.target.files || [];
        processarCoberturaArquivo(arquivo);
      });
    }

    if (coberturaLimparBtn) {
      coberturaLimparBtn.addEventListener('click', () => {
        limparCobertura();
      });
    }

    if (coberturaValidarMunicipiosBtn) {
      coberturaValidarMunicipiosBtn.addEventListener('click', () => {
        abrirCoberturaMunicipiosModal();
      });
    }

    if (coberturaMunicipiosModalSalvar) {
      coberturaMunicipiosModalSalvar.addEventListener('click', salvarCoberturaMunicipiosModal);
    }

    if (coberturaMunicipiosModalCancelar) {
      coberturaMunicipiosModalCancelar.addEventListener('click', () => {
        fecharCoberturaMunicipiosModal();
        if (coberturaValidarMunicipiosBtn) {
          coberturaValidarMunicipiosBtn.focus();
        }
      });
    }

    if (coberturaMunicipiosModalFechar) {
      coberturaMunicipiosModalFechar.addEventListener('click', () => {
        fecharCoberturaMunicipiosModal();
        if (coberturaValidarMunicipiosBtn) {
          coberturaValidarMunicipiosBtn.focus();
        }
      });
    }

    if (importacaoMunicipiosModal) {
      importacaoMunicipiosModal.addEventListener('click', (event) => {
        if (event.target === importacaoMunicipiosModal) {
          fecharImportacaoMunicipiosModal();
          if (importacaoConciliarMunicipiosBtn) {
            importacaoConciliarMunicipiosBtn.focus();
          }
        }
      });
    }

    if (coberturaMunicipiosModal) {
      coberturaMunicipiosModal.addEventListener('click', (event) => {
        if (event.target === coberturaMunicipiosModal) {
          fecharCoberturaMunicipiosModal();
          if (coberturaValidarMunicipiosBtn) {
            coberturaValidarMunicipiosBtn.focus();
          }
        }
      });
    }

    if (coberturaUfSelect) {
      coberturaUfSelect.addEventListener('change', () => {
        carregarCoberturaMunicipios(coberturaUfSelect.value).finally(() => {
          atualizarResumoCobertura();
        });
      });
    }

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && importacaoMunicipiosModal && importacaoMunicipiosModal.classList.contains('open')) {
        event.preventDefault();
        fecharImportacaoMunicipiosModal();
        if (importacaoConciliarMunicipiosBtn) {
          importacaoConciliarMunicipiosBtn.focus();
        }
        return;
      }
      if (event.key === 'Escape' && coberturaMunicipiosModal && coberturaMunicipiosModal.classList.contains('open')) {
        event.preventDefault();
        fecharCoberturaMunicipiosModal();
        if (coberturaValidarMunicipiosBtn) {
          coberturaValidarMunicipiosBtn.focus();
        }
      }
    });

    if (coberturaMunicipiosInput) {
      coberturaMunicipiosInput.addEventListener('focus', () => {
        if (!coberturaMunicipiosInput.disabled) {
          abrirCoberturaMunicipiosSugestoes();
        }
      });

      coberturaMunicipiosInput.addEventListener('click', () => {
        if (!coberturaMunicipiosInput.disabled) {
          abrirCoberturaMunicipiosSugestoes();
        }
      });

      coberturaMunicipiosInput.addEventListener('input', () => {
        if (coberturaMunicipiosInput.disabled) return;
        abrirCoberturaMunicipiosSugestoes();
        renderCoberturaMunicipiosSugestoes();
      });

      coberturaMunicipiosInput.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          event.stopPropagation();
          coberturaMunicipiosInput.value = '';
          renderCoberturaMunicipiosSugestoes();
          fecharCoberturaMunicipiosSugestoes();
        }

        if (event.key === 'Enter') {
          event.preventDefault();
          abrirCoberturaMunicipiosSugestoes();
          const primeiro = coberturaMunicipiosSuggestions ? coberturaMunicipiosSuggestions.querySelector('.suggestion-item') : null;
          if (primeiro) {
            primeiro.click();
          }
        }
      });
    }

    if (coberturaCnaeInput) {
      coberturaCnaeInput.addEventListener('focus', () => {
        abrirCoberturaCnaeSugestoes();
        buscarCoberturaCnaes(coberturaCnaeInput.value, { forcar: true });
      });

      coberturaCnaeInput.addEventListener('click', () => {
        abrirCoberturaCnaeSugestoes();
      });

      coberturaCnaeInput.addEventListener('input', () => {
        abrirCoberturaCnaeSugestoes();
        if (coberturaCnaeDebounce) {
          clearTimeout(coberturaCnaeDebounce);
        }
        coberturaCnaeDebounce = setTimeout(() => {
          buscarCoberturaCnaes(coberturaCnaeInput.value);
        }, 250);
      });

      coberturaCnaeInput.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          event.stopPropagation();
          coberturaCnaeInput.value = '';
          buscarCoberturaCnaes('');
          fecharCoberturaCnaeSugestoes();
        }

        if (event.key === 'Enter') {
          event.preventDefault();
          abrirCoberturaCnaeSugestoes();
          const primeiro = coberturaCnaeSuggestions ? coberturaCnaeSuggestions.querySelector('.suggestion-item') : null;
          if (primeiro) {
            primeiro.click();
          }
        }
      });
    }

    if (coberturaForm) {
      coberturaForm.addEventListener('submit', (event) => {
        event.preventDefault();

        const possuiPesquisa = Array.isArray(ultimoResultado) && ultimoResultado.length > 0;
        if (!possuiPesquisa) {
          prepararCoberturaParaNovaPesquisa(false);
          if (coberturaStatus) {
            coberturaStatus.textContent = 'Realize uma pesquisa na aba Lista CNPJ antes de gerar a cobertura.';
          }
          return;
        }

        const { lista, invalidos } = atualizarResumoCobertura();

        if (!lista.length) {
          const mensagem = coberturaRegistros.length
            ? 'Nenhum CNPJ v√°lido identificado no arquivo. Corrija os registros e tente novamente.'
            : 'Carregue um arquivo com os CNPJs que deseja comparar.';
          if (coberturaStatus) {
            coberturaStatus.textContent = mensagem;
          }
          limparCoberturaTabela();
          atualizarCoberturaCompararEstado();
	  atualizarAbaMapa	
          return;
        }

        const registrosArquivo = new Map();
        lista.forEach(item => {
          if (!item.cnpj) return;
          if (!registrosArquivo.has(item.cnpj)) {
            registrosArquivo.set(item.cnpj, item);
          }
        });

        const encontrados = new Set();
        const linhasCobertura = ultimoResultado.map(linha => {
          const cnpjNormalizado = normalizarCnpj(linha.cnpj_completo);
          const registroArquivo = cnpjNormalizado ? registrosArquivo.get(cnpjNormalizado) : undefined;
          if (registroArquivo) {
            encontrados.add(cnpjNormalizado);
          }
          const statusEncontrado = Boolean(registroArquivo);
          const statusTexto = statusEncontrado ? 'Atendido' : 'N√£o atendido';
          const statusClasse = statusEncontrado ? 'atendido' : 'nao-atendido';
          const telefone1 = formatarTelefone(linha.ddd_1, linha.telefone_1);
          const telefone2 = formatarTelefone(linha.ddd_2, linha.telefone_2);
          const cnpjExibicao = linha.cnpj_completo || formatarCnpjVisivel(registroArquivo?.cnpj || cnpjNormalizado);
          return {
            status: statusTexto,
            statusClasse,
            codigo_externo: registroArquivo?.codigo_externo || '',
            cnpj: cnpjExibicao || '',
            cnpj_export: registroArquivo?.cnpj || cnpjNormalizado || '',
            razao_social: linha.razao_social || '',
            endereco: montarEndereco(linha),
            cep: linha.cep || '',
            telefone_1: telefone1,
            telefone_2: telefone2,
            email: linha.correio_eletronico || '',
            cnae: linha.cnae_fiscal_principal || '',
            situacao: linha.situacao_cadastral_descricao || linha.situacao_cadastral || '',
            motivo: linha.motivo_situacao_cadastral_descricao || linha.motivo_situacao_cadastral || '',
            encontrado: statusEncontrado,
            cnpj_normalizado: cnpjNormalizado
          };
        });

        const extrasArquivo = lista.filter(item => !encontrados.has(item.cnpj));
        ultimoCoberturaResultado = linhasCobertura;

        if (linhasCobertura.length) {
          renderizarCoberturaTabela(linhasCobertura);
        } else {
          limparCoberturaTabela('Nenhum CNPJ retornado na pesquisa para comparar.');
        }

        const atendidos = linhasCobertura.filter(item => item.encontrado).length;
        const naoAtendidos = linhasCobertura.length - atendidos;

        if (coberturaCount) {
          if (!linhasCobertura.length) {
            coberturaCount.textContent = 'Nenhum resultado dispon√≠vel.';
          } else {
            const pluralTotal = linhasCobertura.length === 1 ? '' : 's';
            const pluralAtendido = atendidos === 1 ? '' : 's';
            const pluralNao = naoAtendidos === 1 ? '' : 's';
            let texto = `${formatadorNumero.format(linhasCobertura.length)} CNPJ${pluralTotal} analisado${pluralTotal}: ${formatadorNumero.format(atendidos)} atendido${pluralAtendido}, ${formatadorNumero.format(naoAtendidos)} n√£o atendido${pluralNao}.`;
            if (invalidos.length) {
              texto += ` ‚Ä¢ ${invalidos.length} registro${invalidos.length === 1 ? '' : 's'} ignorado${invalidos.length === 1 ? '' : 's'}.`;
            }
            if (extrasArquivo.length) {
              const pluralExtras = extrasArquivo.length === 1 ? '' : 's';
              const verboExtras = extrasArquivo.length === 1 ? 'n√£o estava' : 'n√£o estavam';
              texto += ` ‚Ä¢ ${extrasArquivo.length} CNPJ${pluralExtras} do arquivo ${verboExtras} na pesquisa.`;
            }
            coberturaCount.textContent = texto;
          }
        }

        if (coberturaStatus) {
          let mensagem = 'Cobertura gerada com base na √∫ltima pesquisa.';
          if (extrasArquivo.length) {
            mensagem += extrasArquivo.length === 1
              ? ' 1 CNPJ do arquivo n√£o foi localizado na pesquisa.'
              : ` ${extrasArquivo.length} CNPJs do arquivo n√£o foram localizados na pesquisa.`;
          }
          if (invalidos.length) {
            mensagem += invalidos.length === 1
              ? ' 1 registro foi ignorado por CNPJ inv√°lido.'
              : ` ${invalidos.length} registros foram ignorados por CNPJ inv√°lido.`;
          }
          coberturaStatus.textContent = mensagem.trim();
        }

if (coberturaExportarBtn) {
          coberturaExportarBtn.disabled = linhasCobertura.length === 0;
        }

        atualizarCoberturaCompararEstado();
        
        // Atualiza o Mapa
        if (typeof atualizarAbaMapa === 'function') {
            atualizarAbaMapa();
        }

        if (typeof atualizarAbaRota === 'function') {
            atualizarAbaRota();
        }

      }); // <--- Fim do listener
    }

    if (coberturaExportarBtn) {
      coberturaExportarBtn.addEventListener('click', () => {
        if (!ultimoCoberturaResultado.length) return;

        const cabecalho = [
          'status',
          'codigo_externo',
          'cnpj',
          'razao_social',
          'endereco',
          'cep',
          'telefone_1',
          'telefone_2',
          'email',
          'cnae',
          'situacao_cadastral',
          'motivo_situacao_cadastral'
        ];

        const linhas = ultimoCoberturaResultado.map(item => {
          return [
            item.status || (item.encontrado ? 'Atendido' : 'N√£o atendido'),
            item.codigo_externo || '',
            formatarCnpjParaCsv(item.cnpj_export || item.cnpj || ''),
            item.razao_social || '',
            item.endereco || '',
            item.cep || '',
            item.telefone_1 || '',
            item.telefone_2 || '',
            item.email || '',
            item.cnae || '',
            item.situacao || '',
            item.motivo || ''
          ];
        });

        const conteudo = '\ufeff' + [cabecalho, ...linhas]
          .map(colunas => colunas.map(escaparCsv).join(';'))
          .join('\n');

        const blob = new Blob([conteudo], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const dataAtual = new Date().toISOString().slice(0, 10);
        const link = document.createElement('a');
        link.href = url;
        link.download = `cobertura_cnpjs_${dataAtual}.csv`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      });
    }

    atualizarOpcoesBtn.addEventListener('click', async () => {
      const textoAnterior = atualizarOpcoesBtn.textContent;
      atualizarOpcoesBtn.disabled = true;
      atualizarOpcoesBtn.textContent = 'Atualizando‚Ä¶';

      try {
        const promessas = [carregarSituacoes({ manterSelecao: true })];
        if (ufSelect.value) {
          promessas.push(buscarMunicipios(ufSelect.value, { manterSelecao: true, manterBusca: true, forcarAtualizacao: true }));
        }
        if (coberturaUfSelect && coberturaUfSelect.value) {
          promessas.push(carregarCoberturaMunicipios(coberturaUfSelect.value, { manterSelecao: true, manterBusca: true, forcarAtualizacao: true }));
        }

        const resultados = await Promise.all(promessas);

        cnaeCache = [];
        ultimoCnaeTermo = null;
        if (cnaeMultiselect.classList.contains('open')) {
          await buscarCnaes(cnaeInput.value, { forcar: true });
        }
        atualizarCnaeFeedback();

        if (resultados.includes(false)) {
          statusMessage.textContent = 'Listas auxiliares atualizadas com avisos. Verifique os filtros.';
        } else {
          statusMessage.textContent = 'Listas auxiliares atualizadas com sucesso.';
        }
      } catch (error) {
        console.error(error);
        statusMessage.textContent = 'N√£o foi poss√≠vel atualizar todas as listas. Tente novamente.';
      } finally {
        atualizarOpcoesBtn.textContent = textoAnterior;
        atualizarOpcoesBtn.disabled = false;
      }
    });


// [NOVO] Fun√ß√£o para carregar categorias ao iniciar
    async function carregarCategoriasMercado() {
      try {
        const response = await apiFetch('/categorias-mercado');
        if (!response.ok) throw new Error('Falha ao carregar categorias');
        
        cacheCategoriasMercado = await response.json();
        
        // Popula o combo de Setores
        setorSelect.innerHTML = '<option value="">Todos os Setores</option>';
        Object.keys(cacheCategoriasMercado).sort().forEach(setor => {
          const option = document.createElement('option');
          option.value = setor;
          option.textContent = setor;
          setorSelect.appendChild(option);
        });
      } catch (err) {
        console.error('Erro ao carregar categorias:', err);
      }
    }

    // [NOVO] Evento "Cascata": Ao mudar Setor, carrega Segmento
    if (setorSelect) {
      setorSelect.addEventListener('change', () => {
        const setorSelecionado = setorSelect.value;
        
        // Reseta o segmento
        segmentoSelect.innerHTML = '<option value="">Todos os Segmentos</option>';
        segmentoSelect.value = "";
        
        if (!setorSelecionado) {
          segmentoSelect.disabled = true;
          segmentoSelect.innerHTML = '<option value="">Selecione um Setor primeiro</option>';
          return;
        }

        // Habilita e preenche
        segmentoSelect.disabled = false;
        const segmentos = cacheCategoriasMercado[setorSelecionado] || [];
        segmentos.sort().forEach(seg => {
          const option = document.createElement('option');
          option.value = seg;
          option.textContent = seg;
          segmentoSelect.appendChild(option);
        });
      });
    }

    filtrosForm.addEventListener('submit', realizarBusca);
    limparBtn.addEventListener('click', limparFiltros);
    cancelarBtn.addEventListener('click', cancelarPesquisa);
    exportarBtn.addEventListener('click', () => {
      if (ultimoResultado.length === 0) return;

      const cabecalho = [
        'CNPJ completo',
        'Razao social',
        'Endereco completo',
        'CEP',
        'Telefone 01 com DDD',
        'Telefone 02 com DDD',
        'Email',
        'CNAE principal',
        'Situacao cadastral',
        'Motivo situacao cadastral',
        'Capital social'
      ];

      const linhas = ultimoResultado.map(linha => {
        return [
          formatarCnpjParaCsv(linha.cnpj_completo),
          linha.razao_social || '',
          montarEndereco(linha),
          linha.cep || '',
          formatarTelefone(linha.ddd_1, linha.telefone_1),
          formatarTelefone(linha.ddd_2, linha.telefone_2),
          linha.correio_eletronico || '',
          formatarCnaeParaCsv(linha.cnae_fiscal_principal),
          linha.situacao_cadastral_descricao || linha.situacao_cadastral || '',
          linha.motivo_situacao_cadastral_descricao || linha.motivo_situacao_cadastral || '',
          linha.capital_social != null && linha.capital_social !== ''
            ? formatadorCapital.format(Number(linha.capital_social))
            : ''
        ];
      });

      const conteudo = '\ufeff' + [cabecalho, ...linhas]
        .map(colunas => colunas.map(escaparCsv).join(';'))
        .join('\n');

      const blob = new Blob([conteudo], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      const dataAtual = new Date().toISOString().slice(0, 10);
      link.href = url;
      link.download = `pesquisa_empresas_${dataAtual}.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    });

    function ativarTab(destino) {
      if (!destino) return;
      tabButtons.forEach(btn => {
        const ativo = btn.dataset.tab === destino;
        btn.classList.toggle('active', ativo);
        btn.setAttribute('aria-selected', ativo ? 'true' : 'false');
      });
      tabPanels.forEach(painel => {
        painel.classList.toggle('active', painel.id === `tab-${destino}`);
      });
    }

    function atualizarAbaCoberturaDisponibilidade() {
      if (!tabCoberturaBtn) return;
      const possuiResultados = Array.isArray(ultimoResultado) && ultimoResultado.length > 0;
      const desabilitar = !possuiResultados;
      tabCoberturaBtn.disabled = desabilitar;
      tabCoberturaBtn.setAttribute('aria-disabled', desabilitar ? 'true' : 'false');
      tabCoberturaBtn.setAttribute('tabindex', desabilitar ? '-1' : '0');
      tabCoberturaBtn.title = desabilitar
        ? 'Realize uma pesquisa na aba Lista CNPJ para habilitar esta funcionalidade.'
        : '';
      if (desabilitar && tabCoberturaBtn.classList.contains('active')) {
        ativarTab('pesquisa');
      }
      atualizarCoberturaCompararEstado();
    }

    tabButtons.forEach(botao => {
      botao.addEventListener('click', () => {
        if (botao.disabled || botao.getAttribute('aria-disabled') === 'true') {
          return;
        }
        const destino = botao.dataset.tab;
        ativarTab(destino);
      });
    });

    popularUFs();
    carregarSituacoes();
    atualizarMunicipiosFeedback();
    atualizarCnaeFeedback();
    atualizarCoberturaMunicipiosFeedback();
    atualizarCoberturaCnaeFeedback();
    limparResultados();
    atualizarResumoImportacao();
    limparCoberturaTabela();
    atualizarResumoCobertura();
    atualizarCoberturaValidarMunicipiosEstado();
    atualizarCoberturaCompararEstado();
    carregarCategoriasMercado();

    // ===========================================================
    // [FRONTEND-GF2] M√ìDULO D√çVIDA ATIVA (H√çBRIDO - VERS√ÉO FINAL)
    // ===========================================================
    
    const btnDividaArquivo = document.getElementById('divida-analisar-arquivo-btn');
    const btnDividaPesquisa = document.getElementById('divida-analisar-pesquisa-btn');
    const inpDividaArquivo = document.getElementById('divida-arquivo');
    const txtDividaFeedback = document.getElementById('divida-arquivo-feedback');
    const btnDividaLimpar = document.getElementById('divida-limpar-btn');
    const btnDividaExportar = document.getElementById('divida-exportar-btn');
    const lblDividaStatus = document.getElementById('divida-status');
    const tblDividaCorpo = document.getElementById('divida-corpo');
    
    let dividaDadosArquivo = [];
    let dividaResultadoFinal = [];

    // 1. Monitoramento da Pesquisa
    function atualizarEstadoBotaoPesquisa() {
      if (!btnDividaPesquisa) return;
      const temPesquisa = Array.isArray(ultimoResultado) && ultimoResultado.length > 0;
      
      btnDividaPesquisa.disabled = !temPesquisa;
      if (temPesquisa) {
        btnDividaPesquisa.textContent = `Usar Resultado da Pesquisa (${ultimoResultado.length} CNPJs)`;
        btnDividaPesquisa.title = "Analisar d√≠vidas dos CNPJs listados na aba anterior";
      } else {
        btnDividaPesquisa.textContent = "Usar Resultado da Pesquisa";
        btnDividaPesquisa.title = "Realize uma pesquisa na aba Lista CNPJ primeiro";
      }
    }

    // 2. Leitura do Arquivo
    if (inpDividaArquivo) {
      inpDividaArquivo.addEventListener('change', async (e) => {
        const arquivo = e.target.files[0];
        if (!arquivo) {
          dividaDadosArquivo = [];
          btnDividaArquivo.disabled = true;
          return;
        }

        try {
          const texto = await arquivo.text();
          const registros = extrairItensDoCsv(texto);
          
          // Filtra e mant√©m estrutura necess√°ria
          dividaDadosArquivo = registros.filter(r => {
             const c = normalizarCnpj(r.cnpj);
             return c && c.length === 14;
          }).map(r => ({
             codigo_externo: r.codigo_externo || '', // Garante captura do c√≥digo
             cnpj: normalizarCnpj(r.cnpj),
             razao_arquivo: r.razao_social || '' // Tenta pegar raz√£o do CSV se tiver
          }));

          if (dividaDadosArquivo.length > 0) {
            txtDividaFeedback.textContent = `${dividaDadosArquivo.length} CNPJs identificados no arquivo.`;
            btnDividaArquivo.disabled = false;
            btnDividaArquivo.textContent = `Analisar ${dividaDadosArquivo.length} CNPJs do Arquivo`;
          } else {
            txtDividaFeedback.textContent = "Nenhum CNPJ v√°lido encontrado no arquivo.";
            btnDividaArquivo.disabled = true;
          }
        } catch (err) {
          console.error(err);
          txtDividaFeedback.textContent = "Erro ao ler arquivo.";
        }
      });
    }

    // 3. A√ß√£o: Analisar
    async function executarAnaliseDivida(fonte) {
      let listaParaEnvio = [];
      
      lblDividaStatus.textContent = 'Preparando dados (isso pode levar alguns segundos)...';
      tblDividaCorpo.innerHTML = '<tr class="empty-state"><td colspan="5">Processando...</td></tr>';
      btnDividaExportar.disabled = true;

      // Prepara lista unificada baseada na fonte
      if (fonte === 'PESQUISA') {
        listaParaEnvio = ultimoResultado.map(item => ({
          codigo_externo: item.codigo_externo || '', // Se houver na pesquisa
          cnpj: String(item.cnpj_completo).replace(/\D+/g, ''),
          razao_origem: item.razao_social || ''
        }));
      } else {
        listaParaEnvio = dividaDadosArquivo.map(item => ({
          codigo_externo: item.codigo_externo,
          cnpj: item.cnpj,
          razao_origem: item.razao_arquivo || '' // Usa nome do arquivo se tiver
        }));
      }

      const arrayCnpjs = listaParaEnvio.map(i => i.cnpj);

      try {
        lblDividaStatus.textContent = `Consultando ${arrayCnpjs.length} CNPJs na base PGFN...`;
        
        const response = await apiFetch('/divida-ativa/verificar', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(arrayCnpjs)
        });

        const dadosApi = await response.json(); 

        // Merge dos dados
        dividaResultadoFinal = listaParaEnvio.map(entrada => {
          const info = dadosApi[entrada.cnpj];
          
          // L√≥gica de Prioridade de Nome:
          // 1. Nome vindo da tabela de d√≠vida (PGFN)
          // 2. Nome vindo da origem (Pesquisa ou CSV)
          // 3. Vazio
          const razaoSocialFinal = (info && info.nome) ? info.nome : entrada.razao_origem;

          return {
            codigo_externo: entrada.codigo_externo,
            cnpj: entrada.cnpj,
            razao_social: razaoSocialFinal,
            situacao: info ? info.situacao : 'NADA CONSTA',
            valor: info ? Number(info.valor) : 0,
            tem_divida: !!info
          };
        });

        renderizarTabelaDivida(dividaResultadoFinal);
        
        const devedores = dividaResultadoFinal.filter(x => x.tem_divida).length;
        lblDividaStatus.textContent = `An√°lise conclu√≠da. ${dividaResultadoFinal.length} registros processados. ${devedores} com d√≠vida ativa.`;
        btnDividaExportar.disabled = false;

      } catch (error) {
        console.error(error);
        lblDividaStatus.textContent = 'Erro de comunica√ß√£o com o servidor.';
        tblDividaCorpo.innerHTML = '<tr class="empty-state"><td colspan="5">Erro na an√°lise.</td></tr>';
      }
    }

    // 4. Renderiza√ß√£o (Sem Limite)
    function renderizarTabelaDivida(lista) {
      tblDividaCorpo.innerHTML = '';
      
      // [CORRE√á√ÉO] Removido o slice(0, 2000). Agora mostra TUDO.
      // Pode causar lentid√£o moment√¢nea no navegador com +5000 registros.
      
      // Fragmento para otimizar inser√ß√£o no DOM
      const fragmento = document.createDocumentFragment();

      lista.forEach(row => {
        const tr = document.createElement('tr');
        
        const valorFmt = row.valor > 0 
          ? row.valor.toLocaleString('pt-BR', {style: 'currency', currency: 'BRL'}) 
          : '‚Äî';
        
        const classeSit = row.tem_divida ? 'nao-atendido' : 'atendido';
        
        tr.innerHTML = `
          <td>${row.codigo_externo || '‚Äî'}</td>
          <td>${formatarCnpjVisivel(row.cnpj)}</td>
          <td>${row.razao_social || '‚Äî'}</td>
          <td><span class="status-pill ${classeSit}">${row.situacao}</span></td>
          <td style="font-weight: 600; color: ${row.tem_divida ? '#b02232' : 'inherit'}">${valorFmt}</td>
        `;
        fragmento.append(tr);
      });
      
      tblDividaCorpo.append(fragmento);
    }

    // 5. Listeners e Exporta√ß√£o
    if (btnDividaArquivo) btnDividaArquivo.onclick = () => executarAnaliseDivida('ARQUIVO');
    if (btnDividaPesquisa) btnDividaPesquisa.onclick = () => executarAnaliseDivida('PESQUISA');

    if (btnDividaLimpar) {
      btnDividaLimpar.addEventListener('click', () => {
        if(inpDividaArquivo) inpDividaArquivo.value = '';
        txtDividaFeedback.textContent = '';
        dividaDadosArquivo = [];
        btnDividaArquivo.disabled = true;
        dividaResultadoFinal = [];
        tblDividaCorpo.innerHTML = '<tr class="empty-state"><td colspan="5">Aguardando comando...</td></tr>';
        lblDividaStatus.textContent = 'Dados limpos.';
        btnDividaExportar.disabled = true;
      });
    }

    if (btnDividaExportar) {
      btnDividaExportar.addEventListener('click', () => {
        if(!dividaResultadoFinal.length) return;
        
        // [CORRE√á√ÉO] Colunas da Exporta√ß√£o Atualizadas
        const header = ['Codigo Externo', 'CNPJ', 'Razao Social', 'Situacao Divida', 'Valor Divida'];
        const linhas = dividaResultadoFinal.map(r => [
           r.codigo_externo || '',
           formatarCnpjParaCsv(r.cnpj),
           r.razao_social || '',
           r.situacao,
           r.valor ? r.valor.toLocaleString('pt-BR', {minimumFractionDigits: 2}) : '0,00'
        ]);
        
        const conteudo = '\ufeff' + [header, ...linhas].map(c => c.map(escaparCsv).join(';')).join('\n');
        const blob = new Blob([conteudo], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `divida_ativa_completo_${new Date().toISOString().slice(0,10)}.csv`;
        link.click();
      });
    }


// ===========================================================
    // [FRONTEND-GF2] M√ìDULO MAPA (VISUAL PRO + SAT√âLITE)
    // ===========================================================
    
    const tabMapaBtn = document.getElementById('tab-btn-mapa');
    const btnGeocodificar = document.getElementById('mapa-geocodificar-btn');
    const lblMapaStatus = document.getElementById('mapa-status');
    const barraProgresso = document.getElementById('mapa-barra');
    const divProgresso = document.getElementById('mapa-progresso');
    
    let mapaInstancia = null;
    let camadaPontos = null;
    let listaParaMapear = []; 

	const setBtnGeocodificar = (disabled, label) => {
  if (!btnGeocodificar) return;          // hardening
  btnGeocodificar.disabled = !!disabled;
  if (label !== undefined) btnGeocodificar.textContent = label;
};


    // --- Defini√ß√£o dos Novos √çcones (Estilo Alfinete) ---
    const iconUrlBase = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/';
    const shadowUrl = 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png';

    // √çcone Vermelho (Padr√£o/Pendente)
    const pinVermelho = L.icon({
        iconUrl: iconUrlBase + 'marker-icon-2x-red.png',
        shadowUrl: shadowUrl,
        iconSize: [25, 41],    // Tamanho do alfinete
        iconAnchor: [12, 41],  // Ponto que toca o mapa (a ponta inferior)
        popupAnchor: [1, -34], // Onde o popup abre em rela√ß√£o ao √≠cone
        shadowSize: [41, 41]
    });

    // √çcone Verde (Encontrado/OK - √ötil para mapa de cobertura)
    const pinVerde = L.icon({
        iconUrl: iconUrlBase + 'marker-icon-2x-green.png',
        shadowUrl: shadowUrl,
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
    });


    // 1. Habilita a aba
    function atualizarAbaMapa() {
        if (!tabMapaBtn) return;
        
        let dados = [];
        let fonte = '';

        // Prioridade: Cobertura > Pesquisa
        if (Array.isArray(ultimoCoberturaResultado) && ultimoCoberturaResultado.length > 0) {
            dados = ultimoCoberturaResultado;
            fonte = 'Arquivo';
        } else if (Array.isArray(ultimoResultado) && ultimoResultado.length > 0) {
            dados = ultimoResultado;
            fonte = 'Pesquisa';
        }

        const temDados = dados.length > 0;
        tabMapaBtn.disabled = !temDados;
        tabMapaBtn.setAttribute('aria-disabled', !temDados);
        
        if (temDados) {
            tabMapaBtn.title = `Visualizar mapa (${dados.length} registros de ${fonte})`;
            listaParaMapear = dados; 
        }
    }

    // 2. Busca Coordenadas no Banco
    async function carregarCoordenadasDoBanco() {
        if (!listaParaMapear || !listaParaMapear.length) {
            console.warn("[MAPA] Lista vazia, nada a buscar.");
            return;
        }

        lblMapaStatus.textContent = "Consultando coordenadas no banco...";
        
        const listaCnpjs = listaParaMapear.map(r => {
            const raw = r.cnpj_completo || r.cnpj || '';
            return String(raw).replace(/\D+/g, '');
        }).filter(c => c.length === 14);
        
        try {
            const resp = await apiFetch('/geocodificacao/consultar_lote', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(listaCnpjs)
            });
            
            if (!resp.ok) throw new Error("Erro na API de Geo");
            
            const mapaCoords = await resp.json(); 

            listaParaMapear = listaParaMapear.map(item => {
                const cnpjLimpo = String(item.cnpj_completo || item.cnpj).replace(/\D+/g, '');
                const coord = mapaCoords[cnpjLimpo];
                
                // L√≥gica de Cobertura: Se veio de arquivo, usa o status 'encontrado' original.
                // Se veio de pesquisa, todos s√£o 'encontrados'.
                const statusEncontrado = item.hasOwnProperty('encontrado') ? item.encontrado : true;

                return {
                    ...item,
                    cnpj_tratado: cnpjLimpo,
                    razao_social: item.razao_social,
                    endereco: montarEndereco(item),
                    lat: coord ? parseFloat(coord.lat) : null,
                    lon: coord ? parseFloat(coord.lon) : null,
                    tem_coord: coord && parseFloat(coord.lat) !== 0,
                    encontrado: statusEncontrado
                };
            });

            const comGeo = listaParaMapear.filter(i => i.tem_coord).length;
            const pendentes = listaParaMapear.length - comGeo;

            lblMapaStatus.textContent = `Mapa carregado. ${comGeo} pontos encontrados. ${pendentes} pendentes.`;
            
            if (pendentes > 0) {
                btnGeocodificar.disabled = false;
                btnGeocodificar.textContent = `Buscar Online (${pendentes} pendentes)`;
            } else {
                btnGeocodificar.disabled = true;
                btnGeocodificar.textContent = "Todos Mapeados";
            }

            plotarPontosDoBanco();

        } catch (e) {
            console.error("[MAPA] Erro fatal:", e);
            lblMapaStatus.textContent = "Erro ao carregar dados do mapa.";
        }
    }

    // 3. Renderiza o Mapa (Com novos √≠cones)
    function plotarPontosDoBanco() {
        if (!mapaInstancia) inicializarMapa();
        if (!camadaPontos) return;
        
        camadaPontos.clearLayers();
        
        let qtdVerde = 0;
        const plotaveis = listaParaMapear.filter(d => d.tem_coord);

        plotaveis.forEach(dado => {
            // Seleciona o √≠cone baseado no status (Verde se encontrado na cobertura, Vermelho se n√£o)
            // Na pesquisa normal, todos ser√£o verdes.
            const iconeUsado = dado.encontrado ? pinVerde : pinVermelho;

            const marcador = L.marker([dado.lat, dado.lon], { icon: iconeUsado });
            
            // Popup estilizado
            marcador.bindPopup(`
                <div style="text-align:left;">
                    <strong style="color:#007bff; font-size:1.1em;">${dado.razao_social || 'Empresa'}</strong><br>
                    <small style="color:#666;">CNPJ: ${dado.cnpj_tratado}</small><br>
                    <div style="margin-top:5px; border-top:1px solid #eee; padding-top:5px;">
                        Is${dado.endereco}
                    </div>
                </div>
            `);
            camadaPontos.addLayer(marcador);
            qtdVerde++;
        });

        // Atualiza Legenda
        const pendentes = listaParaMapear.length - qtdVerde;
        if(document.getElementById('mapa-legenda-verde')) 
            document.getElementById('mapa-legenda-verde').textContent = `${qtdVerde} Exibidos`;
        if(document.getElementById('mapa-legenda-vermelho')) 
            document.getElementById('mapa-legenda-vermelho').textContent = `${pendentes} Sem Coordenada`;

        if (qtdVerde > 0) {
            const grupo = new L.featureGroup(camadaPontos.getLayers());
            mapaInstancia.fitBounds(grupo.getBounds(), { padding: [50, 50] });
        }
    }

    // 4. Inicializa o Mapa (Com Sat√©lite Esri)
    // 4. Inicializa o Mapa (AGORA COM GOOGLE H√çBRIDO)
    // 4. Inicializa o Mapa (VISUAL LIMPO - SEM POLUI√á√ÉO)
    function inicializarMapa() {
        if (mapaInstancia) return;
        
        mapaInstancia = L.map('mapa-real').setView([-15.7801, -47.9292], 4);

        // [OP√á√ÉO 1 - RECOMENDADA] CartoDB Positron
        // Mapa claro, minimalista, mostra ruas e cidades mas SEM √≠cones de empresas.
        // Perfeito para destacar os seus pontos (Verde/Vermelho).
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 20
        }).addTo(mapaInstancia);

        /* // [OP√á√ÉO 2] Se voc√™ preferir SAT√âLITE PURO (S√≥ foto, sem nomes de rua nem locais)
        // Descomente abaixo e comente a Op√ß√£o 1 se quiser usar este.
        L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
            attribution: '&copy; Google Maps',
            maxZoom: 21
        }).addTo(mapaInstancia);
        */

        camadaPontos = L.layerGroup().addTo(mapaInstancia);
        
        setTimeout(() => { mapaInstancia.invalidateSize(); }, 200);
    }

    // Busca Online (Fallback)
    async function buscarPendentesOnline() {
        const pendentes = listaParaMapear.filter(d => !d.tem_coord);
        if (!pendentes.length) return;
        
        btnGeocodificar.disabled = true;
        divProgresso.style.display = 'block';
        const total = pendentes.length;

        for (let i = 0; i < total; i++) {
            const item = pendentes[i];
            const pct = Math.round(((i + 1) / total) * 100);
            barraProgresso.style.width = `${pct}%`;
            lblMapaStatus.textContent = `Buscando ${i+1}/${total}: ${item.razao_social}...`;

            try {
                const enderecoLimpo = item.endereco.split('-')[0].trim();
                const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(enderecoLimpo)}&limit=1`;
                const resp = await fetch(url);
                const geo = await resp.json();

                if (geo && geo.length > 0) {
                    item.lat = parseFloat(geo[0].lat);
                    item.lon = parseFloat(geo[0].lon);
                    item.tem_coord = true;
                    apiFetch('/geocodificacao/salvar', {
                        method: 'POST', headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ cnpj: item.cnpj_tratado, lat: item.lat, lon: item.lon })
                    }).catch(() => {});
                }
                await new Promise(r => setTimeout(r, 1100));
            } catch (e) {}
        }
        divProgresso.style.display = 'none';
        plotarPontosDoBanco();
        btnGeocodificar.disabled = false;
    }

    // Listeners
    tabMapaBtn.addEventListener('click', () => {
        ativarTab('mapa');
        inicializarMapa();
        carregarCoordenadasDoBanco();
    });

if (btnGeocodificar) btnGeocodificar.addEventListener('click', buscarPendentesOnline);


// [NOVO] Fun√ß√£o de Rota Otimizada
    const btnRota = document.getElementById('mapa-rota-btn');

    function gerarRotaGoogleMaps() {
        // 1. Filtra apenas quem tem coordenada v√°lida
        const pontosValidos = listaParaMapear.filter(d => d.tem_coord);

        if (pontosValidos.length === 0) {
            mostrarAlerta("Nenhum ponto com coordenada v√°lida para gerar rota.", "‚ö†Ô∏è Sem Coordenadas");
            return;
        }

        // 2. Limite do Google Maps (Aprox 20 pontos na URL gratuita)
        // Se tiver mais que 20, pegamos os primeiros 20 para n√£o quebrar o link
        const limite = 20;
        const rota = pontosValidos.slice(0, limite);

        if (pontosValidos.length > limite) {
            mostrarAlerta(`Aten√ß√£o: Sua lista tem ${pontosValidos.length} locais. O Google Maps aceita no m√°ximo ${limite} paradas por link. Gerando rota para os primeiros ${limite}.`, "‚ö†Ô∏è Limite de Rotas");
        }

        // 3. Constru√ß√£o da URL
        // Formato: https://www.google.com/maps/dir/?api=1&origin=My+Location&destination=LAT,LON&waypoints=LAT,LON|LAT,LON...
        
        // O √∫ltimo ponto ser√° o destino final
        const destinoFinal = rota[rota.length - 1];
        
        // Os outros (exceto o √∫ltimo) ser√£o paradas (waypoints)
        const paradas = rota.slice(0, rota.length - 1);
        
        // Monta string de waypoints (Lat,Lon | Lat,Lon)
        const waypointsStr = paradas.map(p => `${p.lat},${p.lon}`).join('|');

        const url = `https://www.google.com/maps/dir/?api=1&origin=Current+Location&destination=${destinoFinal.lat},${destinoFinal.lon}&waypoints=${waypointsStr}&travelmode=driving`;

        // 4. Abre em nova aba
        window.open(url, '_blank');
    }

    // Listener
    if (btnRota) {
        btnRota.addEventListener('click', gerarRotaGoogleMaps);
    }


// ===========================================================
// [FRONTEND-GF2] M√ìDULO ROTA DE VENDAS - L√ìGICA DE TAGS
// ===========================================================

// 1. Inicializa/Atualiza a aba
function atualizarAbaRota() {
    if (!tabRotaBtn) return;

    // Reset de seguran√ßa se o estado estiver corrompido
    if (!estadoRota || !estadoRota.clientesSelecionadosIds) {
        estadoRota = {
            dadosOriginais: [],
            cidadesPrioridade: [],
            bairrosPrioridade: [],
            clientesFiltrados: [],
            clientesSelecionadosIds: new Set(),
            rotasGeradas: [],
            rotasSalvas: {}
        };
    }

    // Determina qual fonte usar
    let fonteSelecionada = 'pesquisa';
    for(const radio of rotaInputsFonte) {
        if(radio.checked) fonteSelecionada = radio.value;
    }

    // Exibe/Oculta filtros extras de cobertura
    if(rotaFiltrosCoberturaDiv) {
        rotaFiltrosCoberturaDiv.style.display = (fonteSelecionada === 'cobertura') ? 'flex' : 'none';
    }

    let dadosBrutos = [];
    if (fonteSelecionada === 'cobertura') {
        if (Array.isArray(ultimoCoberturaResultado) && ultimoCoberturaResultado.length > 0) {
            dadosBrutos = ultimoCoberturaResultado;
        }
    } else {
        if (Array.isArray(ultimoResultado) && ultimoResultado.length > 0) {
            dadosBrutos = ultimoResultado;
        }
    }

    const temDados = dadosBrutos.length > 0;
    tabRotaBtn.disabled = !temDados;
    tabRotaBtn.setAttribute('aria-disabled', !temDados);

    if (temDados) {
        // Normaliza os dados
        estadoRota.dadosOriginais = dadosBrutos.map(item => ({
            cnpj: String(item.cnpj_completo || item.cnpj || '').replace(/\D+/g, ''),
            razao: item.razao_social || 'Sem Nome',
            endereco: item.endereco || montarEndereco(item),
            bairro: String(item.bairro || 'OUTROS').trim().toUpperCase(),
            cidade: String(item.municipio_nome || item.municipio || item.cidade || '').trim().toUpperCase(),
            lat: item.lat ? parseFloat(item.lat) : 0,
            lon: item.lon ? parseFloat(item.lon) : 0,
            validado: (item.lat && parseFloat(item.lat) !== 0),
            // Propriedade espec√≠fica da cobertura (encontrado = atendido)
            encontrado: item.hasOwnProperty('encontrado') ? item.encontrado : true 
        }));

        const total = estadoRota.dadosOriginais.length;
        rotaFeedbackFonte.textContent = `Carregado: ${total} registros via ${fonteSelecionada === 'pesquisa' ? 'Pesquisa' : 'Cobertura'}.`;
        
        // Se a lista de cidades estiver vazia, popula
        if (rotaSelectCidade.options.length <= 1) {
            popularSelectCidades();
        }
        
        // Aplica filtros (caso j√° tenha cidades selecionadas ou filtros de cobertura mudados)
        aplicarFiltrosGerais();
    } else {
        rotaFeedbackFonte.textContent = "Nenhum dado dispon√≠vel nesta fonte.";
        if(rotaSelectCidade) rotaSelectCidade.innerHTML = '<option value="">Sem dados</option>';
    }
}

// 2. Popula o Select de Cidades
function popularSelectCidades() {
    const cidadesUnicas = new Set(estadoRota.dadosOriginais.map(i => i.cidade).filter(c => c));
    const listaSorted = Array.from(cidadesUnicas).sort();

    rotaSelectCidade.innerHTML = '<option value="">Selecione para adicionar...</option>';
    
    // Op√ß√£o especial: Todas
    const optAll = document.createElement('option');
    optAll.value = "ALL";
    optAll.textContent = "Adicionar Todas as Cidades";
    rotaSelectCidade.appendChild(optAll);

    listaSorted.forEach(cidade => {
        const opt = document.createElement('option');
        opt.value = cidade;
        opt.textContent = cidade;
        rotaSelectCidade.appendChild(opt);
    });
}

// 3. Listener: Adicionar Cidade (Tag com Prioridade)
rotaSelectCidade.addEventListener('change', () => {
    const valor = rotaSelectCidade.value;
    if (!valor) return;

    if (valor === "ALL") {
        const opcoes = Array.from(rotaSelectCidade.options).map(o => o.value).filter(v => v && v !== "ALL");
        opcoes.forEach(c => {
            if (!estadoRota.cidadesPrioridade.includes(c)) {
                estadoRota.cidadesPrioridade.push(c);
                estadoRota.cidadesSelecionadas.add(c); // Adiciona aos selecionados
            }
        });
    } else {
        if (!estadoRota.cidadesPrioridade.includes(valor)) {
            estadoRota.cidadesPrioridade.push(valor);
            estadoRota.cidadesSelecionadas.add(valor); // Adiciona aos selecionados
        }
    }

    renderizarTagsCidades();
    popularSelectBairros();
    aplicarFiltrosGerais();

    rotaSelectCidade.value = "";
});

function renderizarTagsCidades() {
    rotaTagsCidades.innerHTML = '';

    if (estadoRota.cidadesPrioridade.length === 0) {
        rotaTagsCidades.innerHTML = '<small style="color: #94a3b8; font-style: italic;">Arraste para reorganizar prioridade</small>';
        return;
    }

    estadoRota.cidadesPrioridade.forEach((cidade, index) => {
        const tag = document.createElement('span');
        tag.className = 'tag';
        tag.draggable = true;
        tag.dataset.cidade = cidade;
        tag.dataset.index = index;
        tag.style.background = index === 0 ? '#b02232' : '#e2e8f0';
        tag.style.color = index === 0 ? '#fff' : '#334155';
        tag.style.cursor = 'grab';
        tag.style.padding = '6px 12px';
        tag.style.borderRadius = '6px';
        tag.style.display = 'inline-flex';
        tag.style.alignItems = 'center';
        tag.style.gap = '8px';
        tag.style.margin = '4px';
        tag.style.fontWeight = index === 0 ? '600' : '400';

        const prioridade = document.createElement('span');
        prioridade.textContent = `${index + 1}.`;
        prioridade.style.fontWeight = '700';
        prioridade.style.opacity = '0.7';
        tag.appendChild(prioridade);

        const nomeTexto = document.createTextNode(cidade);
        tag.appendChild(nomeTexto);

        const btn = document.createElement('button');
        btn.textContent = '√ó';
        btn.style.marginLeft = '6px';
        btn.style.cursor = 'pointer';
        btn.onclick = (e) => {
            e.stopPropagation();
            estadoRota.cidadesPrioridade = estadoRota.cidadesPrioridade.filter(c => c !== cidade);
            estadoRota.cidadesSelecionadas.delete(cidade); // Remove dos selecionados
            renderizarTagsCidades();
            popularSelectBairros();
            aplicarFiltrosGerais();
        };
        tag.appendChild(btn);

        // Drag and Drop Events
        tag.addEventListener('dragstart', (e) => {
            tag.style.opacity = '0.4';
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', index);
        });

        tag.addEventListener('dragend', () => {
            tag.style.opacity = '1';
        });

        tag.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            tag.style.borderLeft = '3px solid #b02232';
        });

        tag.addEventListener('dragleave', () => {
            tag.style.borderLeft = '';
        });

        tag.addEventListener('drop', (e) => {
            e.preventDefault();
            tag.style.borderLeft = '';
            const dragIndex = parseInt(e.dataTransfer.getData('text/plain'));
            const dropIndex = index;

            if (dragIndex !== dropIndex) {
                const [removed] = estadoRota.cidadesPrioridade.splice(dragIndex, 1);
                estadoRota.cidadesPrioridade.splice(dropIndex, 0, removed);
                renderizarTagsCidades();
                aplicarFiltrosGerais();
            }
        });

        rotaTagsCidades.appendChild(tag);
    });
}

// 4. Popula Select de Bairros (Depende das Cidades selecionadas)
function popularSelectBairros() {
    if (!rotaSelectBairro) return;

    const base = Array.isArray(estadoRota.dadosOriginais)
        ? estadoRota.dadosOriginais
        : [];

    // Normaliza cidades selecionadas para UPPERCASE
    const cidadesAtivas = Array.isArray(estadoRota.cidadesPrioridade)
        ? estadoRota.cidadesPrioridade.map(c => String(c || '').trim().toUpperCase())
        : [];

    // Reset do select
    rotaSelectBairro.innerHTML = '<option value="">Selecione para priorizar...</option>';

    if (!base.length || !cidadesAtivas.length) {
        rotaSelectBairro.disabled = true;
        return;
    }

    const bairrosUnicos = new Set();

    base.forEach(item => {
        const cidade = String(item.cidade || '').trim().toUpperCase();
        if (!cidadesAtivas.includes(cidade)) return;

        const bairro = String(item.bairro || 'OUTROS').trim().toUpperCase();
        bairrosUnicos.add(bairro);
    });

    let listaSorted = Array.from(bairrosUnicos).sort();

    // Se, por qualquer motivo, n√£o encontrarmos nada, mantemos pelo menos OUTROS
    if (!listaSorted.length) {
        listaSorted = ['OUTROS'];
    }

    rotaSelectBairro.disabled = false;

    listaSorted.forEach(bairro => {
        const opt = document.createElement('option');
        opt.value = bairro;
        opt.textContent = bairro;
        rotaSelectBairro.appendChild(opt);
    });
}

// 5. Listener: Adicionar Bairro (Tag com Prioridade)
rotaSelectBairro.addEventListener('change', () => {
    const bairro = rotaSelectBairro.value;
    if (!bairro) return;

    if (!estadoRota.bairrosPrioridade.includes(bairro)) {
        estadoRota.bairrosPrioridade.push(bairro);
        estadoRota.bairrosSelecionados.add(bairro); // Adiciona aos selecionados para valida√ß√£o
    }

    renderizarTagsBairros();
    aplicarFiltrosGerais();
    rotaSelectBairro.value = "";
});

function renderizarTagsBairros() {
    rotaTagsBairros.innerHTML = '';

    if (estadoRota.bairrosPrioridade.length === 0) {
        rotaTagsBairros.innerHTML = '<small style="color: #94a3b8; font-style: italic;">Arraste para reorganizar prioridade</small>';
        return;
    }

    estadoRota.bairrosPrioridade.forEach((bairro, index) => {
        const tag = document.createElement('span');
        tag.className = 'tag';
        tag.draggable = true;
        tag.dataset.bairro = bairro;
        tag.dataset.index = index;
        tag.style.background = '#fee2e2';
        tag.style.color = '#b02232';
        tag.style.cursor = 'grab';
        tag.style.padding = '6px 12px';
        tag.style.borderRadius = '6px';
        tag.style.display = 'inline-flex';
        tag.style.alignItems = 'center';
        tag.style.gap = '8px';
        tag.style.margin = '4px';
        tag.style.fontWeight = '500';

        const prioridade = document.createElement('span');
        prioridade.textContent = `P${index + 1}:`;
        prioridade.style.fontWeight = '700';
        tag.appendChild(prioridade);

        const nomeTexto = document.createTextNode(bairro);
        tag.appendChild(nomeTexto);

        const btn = document.createElement('button');
        btn.textContent = '√ó';
        btn.style.marginLeft = '6px';
        btn.style.cursor = 'pointer';
        btn.onclick = (e) => {
            e.stopPropagation();
            estadoRota.bairrosPrioridade = estadoRota.bairrosPrioridade.filter(b => b !== bairro);
            estadoRota.bairrosSelecionados.delete(bairro); // Remove dos selecionados
            renderizarTagsBairros();
            aplicarFiltrosGerais();
        };
        tag.appendChild(btn);

        // Drag and Drop Events
        tag.addEventListener('dragstart', (e) => {
            tag.style.opacity = '0.4';
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', index);
        });

        tag.addEventListener('dragend', () => {
            tag.style.opacity = '1';
        });

        tag.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            tag.style.borderLeft = '3px solid #b02232';
        });

        tag.addEventListener('dragleave', () => {
            tag.style.borderLeft = '';
        });

        tag.addEventListener('drop', (e) => {
            e.preventDefault();
            tag.style.borderLeft = '';
            const dragIndex = parseInt(e.dataTransfer.getData('text/plain'));
            const dropIndex = index;

            if (dragIndex !== dropIndex) {
                const [removed] = estadoRota.bairrosPrioridade.splice(dragIndex, 1);
                estadoRota.bairrosPrioridade.splice(dropIndex, 0, removed);
                renderizarTagsBairros();
                aplicarFiltrosGerais();
            }
        });

        rotaTagsBairros.appendChild(tag);
    });
}

// 6. Motor de Filtragem Principal e Renderiza√ß√£o da Tabela
function aplicarFiltrosGerais() {
    // 1. Determina a fonte selecionada (Pesquisa x Cobertura)
    let fonteSelecionada = '';
    for (const radio of rotaInputsFonte) {
        if (radio.checked) fonteSelecionada = radio.value;
    }

    const incluirAtendidos = rotaCheckAtendidos ? rotaCheckAtendidos.checked : true;
    const incluirNaoAtendidos = rotaCheckNaoAtendidos ? rotaCheckNaoAtendidos.checked : true;

    const base = Array.isArray(estadoRota.dadosOriginais)
        ? estadoRota.dadosOriginais
        : [];

    // 2. Filtro por status (somente relevante na fonte "cobertura")
    let filtrados = base.filter(item => {
        if (fonteSelecionada === 'cobertura') {
            if (item.encontrado && !incluirAtendidos) return false;
            if (!item.encontrado && !incluirNaoAtendidos) return false;
        }
        return true;
    });

    // 3. Filtros por cidade e bairro (defensivos)
    const cidadesPrio = Array.isArray(estadoRota.cidadesPrioridade)
        ? estadoRota.cidadesPrioridade.map(c => String(c || '').trim().toUpperCase()).filter(Boolean)
        : [];

    const bairrosPrio = Array.isArray(estadoRota.bairrosPrioridade)
        ? estadoRota.bairrosPrioridade.map(b => String(b || '').trim().toUpperCase()).filter(Boolean)
        : [];

    // 3.1 Filtro por cidade ‚Äì com fallback: se zerar tudo, mantemos a lista original
    if (cidadesPrio.length) {
        const filtradosCidade = filtrados.filter(item =>
            cidadesPrio.includes(String(item.cidade || '').trim().toUpperCase())
        );

        if (filtradosCidade.length > 0) {
            filtrados = filtradosCidade;
        } else {
            console.warn('[ROTA] Nenhum registro bateu com as cidades selecionadas. Mantendo sem filtro de cidade.', { cidadesPrio });
        }
    }

    // 3.2 Filtro por bairro ‚Äì tamb√©m com fallback
    if (bairrosPrio.length) {
        const filtradosBairro = filtrados.filter(item =>
            bairrosPrio.includes(String(item.bairro || '').trim().toUpperCase())
        );

        if (filtradosBairro.length > 0) {
            filtrados = filtradosBairro;
        } else {
            console.warn('[ROTA] Nenhum registro bateu com os bairros selecionados. Mantendo sem filtro de bairro.', { bairrosPrio });
        }
    }

    // 4. Ordena√ß√£o inteligente, √† prova de nulos
    filtrados.sort((a, b) => {
        const cidadesCfg = cidadesPrio;
        const bairrosCfg = bairrosPrio;

        const cidadeA = String(a.cidade || '').trim().toUpperCase();
        const cidadeB = String(b.cidade || '').trim().toUpperCase();
        const bairroA = String(a.bairro || '').trim().toUpperCase();
        const bairroB = String(b.bairro || '').trim().toUpperCase();
        const enderecoA = String(a.endereco || '');
        const enderecoB = String(b.endereco || '');

        // 4.1 prioridade de cidade
        const idxCidadeA = cidadesCfg.indexOf(cidadeA);
        const idxCidadeB = cidadesCfg.indexOf(cidadeB);
        const prioCidadeA = idxCidadeA === -1 ? 9999 : idxCidadeA;
        const prioCidadeB = idxCidadeB === -1 ? 9999 : idxCidadeB;
        if (prioCidadeA !== prioCidadeB) {
            return prioCidadeA - prioCidadeB;
        }

        // 4.2 prioridade de bairro
        const idxBairroA = bairrosCfg.indexOf(bairroA);
        const idxBairroB = bairrosCfg.indexOf(bairroB);
        const prioBairroA = idxBairroA === -1 ? 9999 : idxBairroA;
        const prioBairroB = idxBairroB === -1 ? 9999 : idxBairroB;
        if (prioBairroA !== prioBairroB) {
            return prioBairroA - prioBairroB;
        }

        // 4.3 nome do bairro como fallback
        if (bairroA !== bairroB) {
            return bairroA.localeCompare(bairroB);
        }

        // 4.4 endere√ßo como crit√©rio final
        return enderecoA.localeCompare(enderecoB);
    });

    // 5. Atualiza estado e re-renderiza a tabela
    estadoRota.clientesFiltrados = filtrados;
    renderizarTabelaRota();
}

const LIMITE_ROTA_PADRAO = 10;
const LIMITE_ROTA_MIN = 1;
const LIMITE_ROTA_MAX = 100;

function obterLimiteClientesPorRota() {
    if (!rotaLimiteClientesInput) return LIMITE_ROTA_PADRAO;

    let valor = parseInt(rotaLimiteClientesInput.value, 10);

    if (!Number.isFinite(valor) || isNaN(valor)) {
        valor = LIMITE_ROTA_PADRAO;
    }

    if (valor < LIMITE_ROTA_MIN) {
        valor = LIMITE_ROTA_MIN;
    } else if (valor > LIMITE_ROTA_MAX) {
        valor = LIMITE_ROTA_MAX;
    }

    // Normaliza o valor no input para evitar inconsist√™ncia visual
    rotaLimiteClientesInput.value = String(valor);

    return valor;
}

// Algoritmo de Agrupamento Inteligente de Rotas
function gerarRotasInteligentes() {
    const limitePorRota = obterLimiteClientesPorRota(); // limite configur√°vel pelo usu√°rio

    // Filtra apenas clientes com coordenadas v√°lidas
    const clientesValidos = estadoRota.clientesFiltrados.filter(c => c.validado && c.lat && c.lon);

    // Mapeia rotas por nome (para agrupar clientes com mesmo nome de rota)
    const rotasPorNome = new Map();

    // Primeiro, agrupa clientes que j√° t√™m nome de rota definido
    clientesValidos.forEach(cliente => {
        if (cliente.rotaNome && cliente.rotaNome.trim() !== '') {
            const nomeRota = cliente.rotaNome.trim().toUpperCase();

            if (!rotasPorNome.has(nomeRota)) {
                rotasPorNome.set(nomeRota, []);
            }

            const rotaClientes = rotasPorNome.get(nomeRota);

            // S√≥ adiciona se n√£o atingiu o limite
            if (rotaClientes.length < limitePorRota) {
                rotaClientes.push(cliente);
            }
        }
    });

    // Clientes sem nome de rota definido - agrupa automaticamente
    const clientesSemRota = clientesValidos.filter(c => !c.rotaNome || c.rotaNome.trim() === '');

    let rotas = [];
    let rotaAtual = [];
    let cidadeAtual = null;
    let bairroAtual = null;

    clientesSemRota.forEach((cliente, index) => {
        // Adiciona cliente √† rota atual
        rotaAtual.push(cliente);
        cidadeAtual = cliente.cidade;
        bairroAtual = cliente.bairro;

        // L√ìGICA AJUSTADA: S√≥ fecha rota se atingiu o limite de 10
        // Remove quebra autom√°tica por cidade/bairro que estava causando rotas pequenas
        if (rotaAtual.length >= limitePorRota) {
            rotas.push([...rotaAtual]);
            rotaAtual = [];
        }
    });

    // Adiciona √∫ltima rota se houver clientes pendentes
    if (rotaAtual.length > 0) {
        rotas.push(rotaAtual);
    }

    // Combina rotas nomeadas e autom√°ticas
    const rotasNomeadas = Array.from(rotasPorNome.entries()).map(([nome, clientes]) => ({
        nome: nome,
        clientes: clientes
    }));

    // Atualiza o estado com as rotas geradas
    let idCounter = 1;

    // Primeiro adiciona rotas nomeadas
    estadoRota.rotasGeradas = rotasNomeadas.map(rota => ({
        id: idCounter++,
        nome: rota.nome,
        clientes: rota.clientes
    }));

    // Depois adiciona rotas autom√°ticas
    rotas.forEach(clientes => {
        estadoRota.rotasGeradas.push({
            id: idCounter++,
            clientes: clientes
        });
    });

    // Marca cada cliente com o ID da rota e o nome
    estadoRota.clientesFiltrados.forEach(cliente => {
        const rotaEncontrada = estadoRota.rotasGeradas.find(rota =>
            rota.clientes.some(c => c.cnpj === cliente.cnpj)
        );

        if (rotaEncontrada) {
            cliente.rotaId = rotaEncontrada.id;
            if (rotaEncontrada.nome) {
                cliente.rotaNome = rotaEncontrada.nome;
            }
        } else {
            cliente.rotaId = null;
        }
    });
}

function renderizarTabelaRota() {
    const tbody = document.getElementById('rota-corpo');
    tbody.innerHTML = '';

    if (estadoRota.clientesFiltrados.length === 0) {
        tbody.innerHTML = '<tr class="empty-state"><td colspan="8">Selecione cidade e bairro para carregar os dados.</td></tr>';
        document.getElementById('rota-contador').textContent = '0 na rota';
        return;
    }

    // ORDENA√á√ÉO: Clientes validados primeiro, n√£o validados por √∫ltimo
    // Mant√©m a ordem original dentro de cada grupo
    const clientesOrdenados = [...estadoRota.clientesFiltrados].sort((a, b) => {
        // Validados primeiro (true = 1, false = 0)
        // Inverte para que validados (1) venham antes de n√£o validados (0)
        return (b.validado ? 1 : 0) - (a.validado ? 1 : 0);
    });

    // Fragmento para performance
    const fragment = document.createDocumentFragment();

    clientesOrdenados.forEach((cli, index) => {
        const tr = document.createElement('tr');

        // Destaque se est√° em rota gerada e validado
        if (cli.rotaId && cli.validado) {
            tr.style.background = '#f0fdf4'; // Verde claro para clientes em rota v√°lida
        }

        // Destaque extra se tem prioridade de bairro
        const bairroIndex = estadoRota.bairrosPrioridade.indexOf(cli.bairro);
        if (bairroIndex >= 0) {
            tr.style.background = '#fff1f2'; // Vermelho claro para prioridade
            tr.style.fontWeight = '500';
        }

        // Se n√£o foi validado, marca como removido mas permite inclus√£o manual
        if (!cli.validado) {
            tr.style.opacity = '0.5';
            tr.style.textDecoration = 'line-through';
            tr.style.background = '#f5f5f5';
        }

        const statusIcon = cli.validado
            ? '<span style="color:#22c55e; font-size:1.2rem;" title="Endere√ßo validado">‚úî</span>'
            : '<span style="color:#ef4444; font-size:1.2rem;" title="Endere√ßo n√£o validado">‚úñ</span>';

        // Dropdown de rotas dispon√≠veis
        const rotasDisponiveis = estadoRota.rotasGeradas.map(r => ({
            id: r.id,
            nome: r.nome || `R${r.id}`
        }));

        let rotaSelectHTML = `<select class="rota-nome-select" data-cnpj="${cli.cnpj}" style="width:140px; padding:0.5rem; border:1px solid ${cli.rotaId ? 'var(--gf2-red)' : 'var(--gf2-border)'}; border-radius:8px; font-size:0.8rem; background:${cli.rotaId ? 'var(--gf2-red)' : 'var(--gf2-neutral)'}; color:${cli.rotaId ? '#fff' : 'var(--gf2-text)'}; font-weight:${cli.rotaId ? '600' : '400'}; font-family:'Inter', sans-serif; transition: border-color 0.2s ease, box-shadow 0.2s ease;">`;
        rotaSelectHTML += '<option value="">Sem rota</option>';
        rotaSelectHTML += '<option value="__NOVA__" style="font-weight:600; color:#22c55e;">‚ûï Nova Rota...</option>';

        rotasDisponiveis.forEach(rota => {
            const selected = cli.rotaId === rota.id ? 'selected' : '';
            rotaSelectHTML += `<option value="${rota.id}" ${selected}>${rota.nome}</option>`;
        });

        rotaSelectHTML += '</select>';

        const rotaBadge = rotaSelectHTML;

        // Bot√£o remover sempre dispon√≠vel
        const btnRemover = `<button class="btn-remover-rota" data-cnpj="${cli.cnpj}" style="padding:4px 8px; background:#ef4444; color:#fff; border:none; border-radius:4px; cursor:pointer; font-size:0.75rem; font-weight:600;">Remover</button>`;

        tr.innerHTML = `
            <td style="text-align:center;">${rotaBadge}</td>
            <td style="text-align:center;">${index + 1}</td>
            <td>${cli.razao}</td>
            <td style="font-size:0.85rem">${cli.endereco}</td>
            <td>${cli.bairro}</td>
            <td>${cli.cidade}</td>
            <td style="text-align:center;">${statusIcon}</td>
            <td style="text-align:center;">${btnRemover}</td>
        `;
        fragment.appendChild(tr);
    });

    tbody.appendChild(fragment);

    // Listeners dos bot√µes de remover
    document.querySelectorAll('.btn-remover-rota').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const cnpj = e.target.dataset.cnpj;
            // Remove da lista de filtrados
            estadoRota.clientesFiltrados = estadoRota.clientesFiltrados.filter(c => c.cnpj !== cnpj);
            estadoRota.clientesSelecionadosIds.delete(cnpj);
            renderizarTabelaRota();
            exibirResumoRotas();
        });
    });

    // Listeners dos selects de rota
    document.querySelectorAll('.rota-nome-select').forEach(select => {
        select.addEventListener('change', async (e) => {
            const cnpj = e.target.dataset.cnpj;
            const valorSelecionado = e.target.value;

            console.log('[ROTA] Dropdown mudou!');
            console.log('[ROTA] CNPJ:', cnpj);
            console.log('[ROTA] Valor selecionado:', valorSelecionado);

            // Se selecionou "‚ûï Nova Rota...", abre modal
            if (valorSelecionado === '__NOVA__') {
                console.log('[ROTA] Detectou __NOVA__! Indo abrir modal...');
                e.target.value = ''; // Reseta o select
                await abrirModalNovaRota();
                // Ap√≥s criar a rota, n√£o precisa fazer nada aqui,
                // o usu√°rio vai selecionar a rota novamente
                console.log('[ROTA] Voltou do modal');
                return;
            }

            console.log('[ROTA] N√£o √© __NOVA__, processando rota normal...');
            const rotaId = valorSelecionado ? parseInt(valorSelecionado) : null;

            // Encontra o cliente
            const cliente = estadoRota.clientesFiltrados.find(c => c.cnpj === cnpj);
            if (!cliente) return;

            // Remove cliente de rota anterior
            if (cliente.rotaId) {
                const rotaAnterior = estadoRota.rotasGeradas.find(r => r.id === cliente.rotaId);
                if (rotaAnterior) {
                    rotaAnterior.clientes = rotaAnterior.clientes.filter(c => c.cnpj !== cnpj);
                }
            }

            // Adiciona √† nova rota
            if (rotaId) {
                const novaRota = estadoRota.rotasGeradas.find(r => r.id === rotaId);
                if (novaRota) {
                    const limitePorRota = obterLimiteClientesPorRota();

                    if (novaRota.clientes.length >= limitePorRota) {
                        await mostrarAlerta(
                            `‚ö†Ô∏è A rota ${novaRota.nome || `R${novaRota.id}`} j√° atingiu o limite de ${limitePorRota} cliente(s).\n\n` +
                            `Ajuste o par√¢metro "Clientes por rota" no Planejador ou remova um cliente antes de adicionar outro.`,
                            '‚ö†Ô∏è Limite da Rota Atingido'
                        );
                        e.target.value = cliente.rotaId || '';
                        return;
                    }

                    // Adiciona cliente √† rota
                    if (!novaRota.clientes.some(c => c.cnpj === cnpj)) {
                        novaRota.clientes.push(cliente);
                    }

                    cliente.rotaId = rotaId;
                    cliente.rotaNome = novaRota.nome || `R${rotaId}`;

                    console.log(`[ROTA] Cliente ${cliente.razao} adicionado √† rota ${cliente.rotaNome}`);
                }
            } else {
                // Removeu da rota
                cliente.rotaId = null;
                cliente.rotaNome = '';
                console.log(`[ROTA] Cliente ${cliente.razao} removido de todas as rotas`);
            }

            renderizarTabelaRota();
            exibirResumoRotas();
            atualizarFiltroRota();
        });
    });

    // Inicializa Drag and Drop com SortableJS
    if (typeof Sortable !== 'undefined') {
        new Sortable(tbody, {
            animation: 150,
            ghostClass: 'sortable-ghost',
            dragClass: 'sortable-drag',
            onEnd: function (evt) {
                // Reordena o array de clientes filtrados
                const [movedItem] = estadoRota.clientesFiltrados.splice(evt.oldIndex, 1);
                estadoRota.clientesFiltrados.splice(evt.newIndex, 0, movedItem);

                // Re-renderiza a tabela
                renderizarTabelaRota();
                console.log(`[DRAG] Cliente movido de posi√ß√£o ${evt.oldIndex + 1} para ${evt.newIndex + 1}`);
            }
        });
    }

    atualizarContadorRota();
    exibirResumoRotas(); // Mostra resumo das rotas geradas
    atualizarFiltroRota(); // Atualiza op√ß√µes do filtro por rota
}

function exibirResumoRotas() {
    const container = document.getElementById('rota-links-container');

    // Verifica se o elemento existe antes de tentar modific√°-lo
    if (!container) {
        console.warn('[ROTA] Container rota-links-container n√£o encontrado');
        return;
    }

    // SEMPRE mostra o container com t√≠tulo
    let html = '<div style="background:#f8fafc; padding:1rem; border-radius:8px; margin-bottom:1rem;">';
    html += '<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.75rem; gap:10px;">';
    html += '<h4 style="margin:0; color:#b02232; font-size:0.95rem;">üìç Rotas Criadas</h4>';
    html += '</div>';
    const limiteAtual = obterLimiteClientesPorRota();
    html += `<p style="margin:0 0 0.5rem 0; font-size:0.8rem; color:#64748b;">
           Limite configurado: <strong>${limiteAtual}</strong> cliente(s) por rota.
         </p>`;

    // Se n√£o h√° rotas, mostra mensagem
    if (estadoRota.rotasGeradas.length === 0) {
        html += '<div style="color:#94a3b8; font-style:italic; text-align:center; padding:1rem;">Nenhuma rota criada. Para criar uma rota, selecione "‚ûï Nova Rota..." no dropdown da tabela abaixo.</div>';
    } else {
        // Se h√° rotas, mostra elas
        html += '<div style="display:flex; gap:12px; flex-wrap:wrap;">';

        estadoRota.rotasGeradas.forEach(rota => {
        const nomeRota = rota.nome || `R${rota.id}`;
        const clientesValidos = rota.clientes.filter(c => c.validado);

        html += `<div style="background:#fff; border:2px solid #22c55e; padding:10px 14px; border-radius:8px; font-size:0.85rem; display:flex; align-items:center; gap:10px;">
            <strong style="color:#22c55e;">${nomeRota}</strong>: ${clientesValidos.length} cliente(s)
            <button class="btn-abrir-mapa-rota" data-rota-id="${rota.id}" style="padding:4px 10px; background:#b02232; color:#fff; border:none; border-radius:4px; cursor:pointer; font-size:0.75rem; font-weight:600;" title="Abrir rota no Google Maps">
                üó∫Ô∏è Abrir Mapa
            </button>
            <button class="btn-limpar-rota" data-rota-id="${rota.id}" style="padding:4px 10px; background:#fff; color:#b02232; border:1px solid #b02232; border-radius:4px; cursor:pointer; font-size:0.75rem; font-weight:600;" title="Limpar apenas esta rota">
                üóëÔ∏è Limpar
            </button>
        </div>`;
        });

        html += '</div>'; // Fecha div de rotas
    }

    html += '</div>'; // Fecha div principal
    container.innerHTML = html;

    // Event listeners para os bot√µes de abrir mapa
    document.querySelectorAll('.btn-abrir-mapa-rota').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const btnEl = e.currentTarget;
            const rotaId = parseInt(btnEl.dataset.rotaId, 10);
            if (!Number.isFinite(rotaId) || isNaN(rotaId)) {
                console.warn('[ROTA-MAPA] rotaId inv√°lido no bot√£o Abrir Mapa:', btnEl.dataset.rotaId);
                return;
            }
            abrirRotaNoGoogleMaps(rotaId);
        });
    });

    // Event listeners para os bot√µes de limpar rota
    document.querySelectorAll('.btn-limpar-rota').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const rotaId = parseInt(e.target.dataset.rotaId);
            mostrarConfirmacao(`Deseja limpar a rota ${estadoRota.rotasGeradas.find(r => r.id === rotaId)?.nome || `R${rotaId}`}?`, '‚ùì Limpar Rota').then(confirmado => {
                if (confirmado) {
                    limparRotaEspecifica(rotaId);
                }
            });
        });
    });

}

// ========================================
// FUN√á√ïES PARA CRIAR NOVA ROTA
// ========================================

// Fun√ß√£o para abrir modal de criar nova rota
async function abrirModalNovaRota() {
    console.log('[ROTA] abrirModalNovaRota() chamada');

    const modal = document.getElementById('rota-nova-modal');
    const inputNome = document.getElementById('rota-nova-nome');

    console.log('[ROTA] Modal:', modal ? 'encontrado' : 'N√ÉO encontrado');
    console.log('[ROTA] Input:', inputNome ? 'encontrado' : 'N√ÉO encontrado');

    if (!modal || !inputNome) {
        console.error('[ROTA] Modal ou input de nova rota n√£o encontrado');
        await mostrarAlerta('Erro: Modal n√£o encontrado. Recarregue a p√°gina.', '‚ùå Erro');
        return;
    }

    // Limpa e abre modal
    inputNome.value = '';

    // Remove atributo hidden
    modal.hidden = false;

    // FOR√áA o modal a aparecer sobrescrevendo qualquer CSS
    modal.style.display = 'flex';
    modal.style.visibility = 'visible';
    modal.style.opacity = '1';
    modal.style.zIndex = '10000';

    console.log('[ROTA] Modal aberto e for√ßado a aparecer');
    setTimeout(() => inputNome.focus(), 100);
}

// Fun√ß√£o para fechar modal de criar nova rota
function fecharModalNovaRota() {
    const modal = document.getElementById('rota-nova-modal');
    if (modal) {
        modal.hidden = true;
        // Remove estilos inline que podem ter sido aplicados
        modal.style.display = '';
        modal.style.visibility = '';
        modal.style.opacity = '';
        modal.style.zIndex = '';
    }
}

// Event listeners do modal de criar nova rota
const btnRotaNovaFechar = document.getElementById('rota-nova-modal-fechar');
const btnRotaNovaCancelar = document.getElementById('rota-nova-modal-cancelar');
const btnRotaNovaConfirmar = document.getElementById('rota-nova-modal-confirmar');

if (btnRotaNovaFechar) {
    btnRotaNovaFechar.addEventListener('click', fecharModalNovaRota);
}
if (btnRotaNovaCancelar) {
    btnRotaNovaCancelar.addEventListener('click', fecharModalNovaRota);
}
if (btnRotaNovaConfirmar) {
    btnRotaNovaConfirmar.addEventListener('click', async () => {
        const inputNome = document.getElementById('rota-nova-nome');
        const nomeRota = inputNome.value.trim();

        if (!nomeRota) {
            await mostrarAlerta('‚ùå Digite um nome para a rota!', '‚ùå Nome Obrigat√≥rio');
            return;
        }

        const nomeFormatado = nomeRota.toUpperCase();

        // Verifica se j√° existe rota com esse nome
        if (estadoRota.rotasGeradas.some(r => r.nome === nomeFormatado)) {
            await mostrarAlerta(`‚ùå J√° existe uma rota com o nome "${nomeFormatado}"!\n\nEscolha outro nome.`, '‚ùå Nome Duplicado');
            return;
        }

        // Cria nova rota vazia
        const novaRotaId = estadoRota.rotasGeradas.length > 0
            ? Math.max(...estadoRota.rotasGeradas.map(r => r.id)) + 1
            : 1;

        estadoRota.rotasGeradas.push({
            id: novaRotaId,
            nome: nomeFormatado,
            clientes: []
        });

        fecharModalNovaRota();
        renderizarTabelaRota(); // Atualiza tabela para mostrar nova rota nos seletores
        exibirResumoRotas();
        atualizarFiltroRota();
        await mostrarAlerta(`‚úÖ Rota "${nomeFormatado}" criada!\n\nAtribua clientes √† esta rota usando o dropdown na tabela abaixo.`, '‚úÖ Rota Criada');
    });
}

// ========================================
// FUN√á√ÉO PARA FILTRAR GRID POR ROTA
// ========================================

function atualizarFiltroRota() {
    const selectFiltro = document.getElementById('rota-filtro-select');
    const contadorFiltro = document.getElementById('rota-filtro-contador');

    if (!selectFiltro) {
        console.warn('[ROTA] Select de filtro n√£o encontrado');
        return;
    }

    // Atualiza op√ß√µes do select
    selectFiltro.innerHTML = '<option value="">Todas as Rotas</option>';

    // Adiciona rotas dispon√≠veis
    estadoRota.rotasGeradas.forEach(rota => {
        const option = document.createElement('option');
        option.value = rota.id;
        option.textContent = rota.nome || `R${rota.id}`;
        selectFiltro.appendChild(option);
    });

    // Aplica filtro se houver rota selecionada
    aplicarFiltroRota();
}

function aplicarFiltroRota() {
    const selectFiltro = document.getElementById('rota-filtro-select');
    const contadorFiltro = document.getElementById('rota-filtro-contador');
    const tbody = document.getElementById('rota-corpo');

    if (!selectFiltro || !tbody) return;

    const rotaIdFiltro = selectFiltro.value ? parseInt(selectFiltro.value) : null;

    // Mostra/esconde linhas baseado no filtro
    const rows = tbody.querySelectorAll('tr:not(.empty-state)');
    let visiveis = 0;

    rows.forEach(row => {
        if (!rotaIdFiltro) {
            // Mostra todas
            row.style.display = '';
            visiveis++;
        } else {
            // Verifica se a linha pertence √† rota filtrada
            const select = row.querySelector('.rota-nome-select');
            if (select) {
                const clienteRotaId = select.value ? parseInt(select.value) : null;
                if (clienteRotaId === rotaIdFiltro) {
                    row.style.display = '';
                    visiveis++;
                } else {
                    row.style.display = 'none';
                }
            }
        }
    });

    // Atualiza contador
    if (contadorFiltro) {
        if (rotaIdFiltro) {
            const nomeRota = estadoRota.rotasGeradas.find(r => r.id === rotaIdFiltro)?.nome || `R${rotaIdFiltro}`;
            contadorFiltro.textContent = `Exibindo ${visiveis} cliente(s) da rota ${nomeRota}`;
        } else {
            contadorFiltro.textContent = '';
        }
    }
}

// Event listener para o filtro por rota
const rotaFiltroSelect = document.getElementById('rota-filtro-select');
if (rotaFiltroSelect) {
    rotaFiltroSelect.addEventListener('change', aplicarFiltroRota);
}

function atualizarContadorRota() {
    const count = estadoRota.clientesFiltrados.filter(c => c.validado).length;
    const total = estadoRota.clientesFiltrados.length;
    document.getElementById('rota-contador').textContent = `${count} de ${total} na rota (${total - count} exclu√≠dos)`;
}

// Fun√ß√£o para abrir rota espec√≠fica no Google Maps
// SEMPRE usa localiza√ß√£o atual como origem e carro como modo de transporte
async function abrirRotaNoGoogleMaps(rotaId) {
    const rota = estadoRota.rotasGeradas.find(r => r.id === rotaId);
    if (!rota) {
        await mostrarAlerta('Rota n√£o encontrada!', '‚ùå Erro');
        return;
    }

    // Filtra apenas clientes validados COM coordenadas v√°lidas
    const clientesValidos = rota.clientes.filter(c => {
        const lat = parseFloat(c.lat);
        const lon = parseFloat(c.lon);
        const coordenadasValidas =
            c.validado &&
            c.lat && c.lon &&
            !isNaN(lat) && !isNaN(lon) &&
            Math.abs(lat) > 0.01 &&
            Math.abs(lon) > 0.01 &&
            lat >= -34 && lat <= 6 &&
            lon >= -74 && lon <= -34;

        return coordenadasValidas;
    });

    if (!Array.isArray(clientesValidos) || clientesValidos.length === 0) {
        await mostrarAlerta(
            'Nenhum cliente com endere√ßo v√°lido nesta rota.\n\n' +
            'Valide os endere√ßos antes de abrir o mapa.',
            '‚ö†Ô∏è Sem Endere√ßos V√°lidos'
        );
        return;
    }

    if (!rotaMapaModal || !document.getElementById('rota-mapa')) {
        console.error('[ROTA-MAPA] Modal ou container do mapa n√£o encontrado.');
        await mostrarAlerta('Erro ao abrir o mapa interno da rota.', '‚ùå Erro de Mapa');
        return;
    }

    const nomeRota = rota.nome || `R${rota.id}`;

    // Atualiza t√≠tulo e resumo do modal
    if (rotaMapaTitulo) {
        rotaMapaTitulo.textContent = `üó∫Ô∏è Mapa da Rota ${nomeRota}`;
    }
    if (rotaMapaResumo) {
        rotaMapaResumo.textContent =
            `${clientesValidos.length} cliente(s) com coordenadas v√°lidas ser√£o exibidos no mapa.`;
    }

    // Abre o modal
    rotaMapaModal.hidden = false;

    // Garante que o DIV esteja vis√≠vel antes de inicializar o Leaflet
    setTimeout(() => {
        const divMapa = document.getElementById('rota-mapa');
        if (!divMapa) return;

        // Cria ou reutiliza o mapa
        if (!rotaMapaInstancia) {
            rotaMapaInstancia = L.map('rota-mapa');
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; OpenStreetMap contributors &copy; CARTO'
            }).addTo(rotaMapaInstancia);
            rotaMapaCamada = L.layerGroup().addTo(rotaMapaInstancia);
        } else {
            if (rotaMapaCamada) {
                rotaMapaCamada.clearLayers();
            }
        }

        const pontos = [];

        clientesValidos.forEach((cli, idx) => {
            const lat = parseFloat(cli.lat);
            const lon = parseFloat(cli.lon);

            if (isNaN(lat) || isNaN(lon)) return;

            const label = String(idx + 1);
            const popupHtml = `
                <div style="text-align:left;">
                    <strong>${label}. ${cli.razao || cli.razao_social || 'Cliente'}</strong><br>
                    <small>${cli.endereco || ''}, ${cli.bairro || ''}</small><br>
                    <small>${cli.cidade || ''} / ${cli.uf || ''}</small><br>
                    <small>CNPJ: ${cli.cnpj || ''}</small>
                </div>
            `;

            const marker = L.marker([lat, lon], { title: `${label} - ${cli.razao || cli.razao_social || ''}` });
            marker.bindPopup(popupHtml);

            if (rotaMapaCamada) {
                rotaMapaCamada.addLayer(marker);
            }

            pontos.push([lat, lon]);
        });

        // Desenha uma polyline ligando os pontos na ordem da rota
        if (pontos.length > 1 && rotaMapaCamada) {
            const linha = L.polyline(pontos, { weight: 4, opacity: 0.7 });
            rotaMapaCamada.addLayer(linha);
        }

        // Ajusta o zoom/posi√ß√£o para enquadrar todos os pontos
        if (pontos.length > 0 && rotaMapaInstancia) {
            const bounds = L.latLngBounds(pontos);
            rotaMapaInstancia.fitBounds(bounds, { padding: [40, 40] });
            rotaMapaInstancia.invalidateSize();
        }
    }, 50);
}

// Fun√ß√£o para limpar rota espec√≠fica
function limparRotaEspecifica(rotaId) {
    // Remove a rota do array de rotas geradas
    estadoRota.rotasGeradas = estadoRota.rotasGeradas.filter(r => r.id !== rotaId);

    // Remove o rotaId e rotaNome dos clientes que pertenciam a essa rota
    estadoRota.clientesFiltrados.forEach(cli => {
        if (cli.rotaId === rotaId) {
            delete cli.rotaId;
            delete cli.rotaNome;
        }
    });

    renderizarTabelaRota();
    exibirResumoRotas();
}

// üî• NOVA FUN√á√ÉO: Verifica cache ANTES de validar (n√£o consome API!)
// Retorna estat√≠sticas: { noCache: number, precisamAPI: number, clientes: array }
async function verificarCacheEndereco() {
    try {
        // Filtra apenas clientes n√£o validados nos filtros ativos
        let naoValidados = estadoRota.clientesFiltrados.filter(c => {
            const cidadeInclusa = estadoRota.cidadesPrioridade.length === 0 ||
                                  estadoRota.cidadesPrioridade.includes(c.cidade);
            const bairroIncluso = estadoRota.bairrosPrioridade.length === 0 ||
                                  estadoRota.bairrosPrioridade.includes(c.bairro);
            return !c.validado && cidadeInclusa && bairroIncluso;
        });

        if (naoValidados.length === 0) {
            return { noCache: 0, precisamAPI: 0, clientes: [] };
        }

        // BUSCA CACHE (N√ÉO consome API!)
        const cacheResp = await fetch(API_BASE_URL + '/geocodificacao/cache/buscar', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(naoValidados.map(c => ({
                cnpj: c.cnpj,
                endereco: c.endereco
            })))
        });

        const cache = await cacheResp.json();
        let noCache = 0;
        const precisamAPI = [];

        // Aplica coordenadas do cache
        for (const cliente of naoValidados) {
            const cacheData = cache[cliente.cnpj];

            if (cacheData) {
                const latBruta = cacheData.lat;
                const lonBruta = cacheData.lon;

                const latNum = latBruta !== null && latBruta !== undefined ? parseFloat(latBruta) : NaN;
                const lonNum = lonBruta !== null && lonBruta !== undefined ? parseFloat(lonBruta) : NaN;

                const temCoordenadasValidas =
                    !Number.isNaN(latNum) &&
                    !Number.isNaN(lonNum) &&
                    Math.abs(latNum) > 0.01 &&
                    Math.abs(lonNum) > 0.01 &&
                    latNum >= -34 && latNum <= 6 &&
                    lonNum >= -74 && lonNum <= -34;

                if (temCoordenadasValidas) {
                    // Registro com coordenadas v√°lidas no banco -> usa sem consumir API
                    cliente.lat = latNum;
                    cliente.lon = lonNum;
                    cliente.validado = true;
                    noCache++;
                    console.log(`[CACHE] ‚úÖ ${cliente.razao} - Coordenadas do banco reutilizadas (${latNum.toFixed(6)}, ${lonNum.toFixed(6)})`);
                } else {
                    // Registro encontrado na tabela, por√©m SEM coordenadas v√°lidas
                    // Regra de neg√≥cio: N√ÉO chamar API para este CNPJ
                    cliente.validado = false;
                    console.log(`[CACHE] ‚ö†Ô∏è ${cliente.razao} - Registro encontrado sem coordenadas v√°lidas no banco. Mantido sem valida√ß√£o e fora da API.`);
                    // N√ÉO adicionar em 'precisamAPI'
                }
            } else {
                // N√£o existe nenhum registro na tabela para este CNPJ -> candidato a API
                precisamAPI.push(cliente);
            }
        }

        renderizarTabelaRota();

        return { noCache, precisamAPI: precisamAPI.length, clientes: precisamAPI };
    } catch (error) {
        console.error('[CACHE] Erro ao verificar cache:', error);
        return { noCache: 0, precisamAPI: 0, clientes: [] };
    }
}

// Fun√ß√£o para validar endere√ßos com Google Maps Geocoding API
// VERS√ÉO 4.0 - INTELIGENTE: Usa cache primeiro, API s√≥ se necess√°rio
// silencioso: se true, n√£o mostra alertas desnecess√°rios
// cnpjsEspecificos: array de CNPJs para validar apenas clientes espec√≠ficos
async function validarEnderecosGoogleMaps(silencioso = false, cnpjsEspecificos = null) {
    const GOOGLE_API_KEY = 'AIzaSyCf_o6dJJ0Vrd6NzJchgl8nn1wPgGMpb98'; // Usu√°rio deve configurar

    if (!GOOGLE_API_KEY || GOOGLE_API_KEY === 'SUA_CHAVE_AQUI') {
        if (!silencioso) {
            await mostrarAlerta('Configure a chave da Google Maps API para validar endere√ßos.\n\nAdicione sua chave no c√≥digo JavaScript (vari√°vel GOOGLE_API_KEY).', '‚öôÔ∏è Configura√ß√£o Necess√°ria');
        }
        return;
    }

    // Filtra clientes para validar
    let naoValidados = estadoRota.clientesFiltrados.filter(c => {
        // Se h√° CNPJs espec√≠ficos, valida apenas eles
        if (cnpjsEspecificos && cnpjsEspecificos.length > 0) {
            return !c.validado && cnpjsEspecificos.includes(c.cnpj);
        }

        // Sen√£o, verifica se est√° em uma cidade selecionada
        const cidadeInclusa = estadoRota.cidadesPrioridade.length === 0 ||
                              estadoRota.cidadesPrioridade.includes(c.cidade);

        // Verifica se est√° em um bairro selecionado (se houver filtro de bairro)
        const bairroIncluso = estadoRota.bairrosPrioridade.length === 0 ||
                              estadoRota.bairrosPrioridade.includes(c.bairro);

        // Retorna apenas os n√£o validados que est√£o inclusos nos filtros
        return !c.validado && cidadeInclusa && bairroIncluso;
    });

    console.log(`[VALIDA√á√ÉO] ${naoValidados.length} endere√ßos n√£o validados encontrados ${cnpjsEspecificos ? '(valida√ß√£o autom√°tica)' : 'nos filtros ativos'}`);

    if (naoValidados.length === 0) {
        if (!silencioso) {
            await mostrarAlerta('Todos os endere√ßos inclusos na rota j√° foram validados!', '‚úÖ Valida√ß√£o Completa');
        }
        return;
    }

    try {
        // 1. VERIFICA STATUS DA API (Limite mensal)
        const statusResp = await fetch(API_BASE_URL + '/geocodificacao/api/status');
        const statusAPI = await statusResp.json();

        console.log('[VALIDA√á√ÉO] Status API:', statusAPI);

        if (statusAPI.status_limite === 'LIMITE_ATINGIDO') {
            if (!silencioso) {
                await mostrarAlerta(`‚õî Limite de API Atingido\n\nVoc√™ j√° utilizou ${statusAPI.total_requisicoes}/${statusAPI.limite_mensal} requisi√ß√µes este m√™s.\n\nAguarde o pr√≥ximo m√™s para validar novos endere√ßos.`, '‚õî Limite Atingido');
            }
            return;
        }

        // Modo silencioso: n√£o pergunta sobre alerta, apenas valida se houver espa√ßo
        if (statusAPI.status_limite === 'ALERTA' && !silencioso) {
            const continuar = await mostrarConfirmacao(`‚ö†Ô∏è Alerta de Limite\n\nVoc√™ j√° usou ${statusAPI.total_requisicoes}/${statusAPI.limite_mensal} requisi√ß√µes (${statusAPI.percentual_uso}%).\n\nRestam apenas ${statusAPI.requisicoes_disponiveis} requisi√ß√µes.\n\nDeseja continuar?`, '‚ö†Ô∏è Alerta de Limite');
            if (!continuar) return;
        }

        // 2. BUSCA CACHE PRIMEIRO
        console.log('[VALIDA√á√ÉO] Buscando no cache para', naoValidados.length, 'clientes...');
        const cacheResp = await fetch(API_BASE_URL + '/geocodificacao/cache/buscar', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(naoValidados.map(c => ({
                cnpj: c.cnpj,
                endereco: c.endereco
            })))
        });

        if (!cacheResp.ok) {
            console.error('[CACHE] Erro ao buscar cache:', cacheResp.status, cacheResp.statusText);
        }

        const cache = await cacheResp.json();
        console.log('[CACHE] Recebeu', Object.keys(cache).length, 'registros do cache');

        let cacheados = 0;
        let validados = 0;
        let invalidos = 0;
        let requisicoesAPI = 0;
        const paraValidarAPI = [];
        const paraCache = [];

        for (const cliente of naoValidados) {
            const cacheData = cache[cliente.cnpj];

            if (cacheData) {
                const latBruta = cacheData.lat;
                const lonBruta = cacheData.lon;

                const latNum = latBruta !== null && latBruta !== undefined ? parseFloat(latBruta) : NaN;
                const lonNum = lonBruta !== null && lonBruta !== undefined ? parseFloat(lonBruta) : NaN;

                const temCoordenadasValidas =
                    !Number.isNaN(latNum) &&
                    !Number.isNaN(lonNum) &&
                    Math.abs(latNum) > 0.01 &&
                    Math.abs(lonNum) > 0.01 &&
                    latNum >= -34 && latNum <= 6 &&
                    lonNum >= -74 && lonNum <= -34;

                if (temCoordenadasValidas) {
                    cliente.lat = latNum;
                    cliente.lon = lonNum;
                    cliente.validado = true;
                    cacheados++;
                    validados++;
                    console.log(`[CACHE] ‚úÖ ${cliente.razao} - Coordenadas do banco reutilizadas (${latNum.toFixed(6)}, ${lonNum.toFixed(6)})`);
                } else {
                    // Registro com entrada na tabela mas sem coordenadas v√°lidas
                    cliente.validado = false;
                    invalidos++;
                    console.log(`[CACHE] ‚õî ${cliente.razao} - Registro sem coordenadas v√°lidas. N√£o ser√° enviado √† API por regra de neg√≥cio.`);
                    // N√ÉO incluir em paraValidarAPI
                }
            } else {
                // N√£o tem registro algum -> candidato a API
                paraValidarAPI.push(cliente);
            }
        }

        console.log(`[CACHE] Resumo: ${cacheados} validados com cache, ${invalidos} sem coordenadas v√°lidas, ${paraValidarAPI.length} candidatos √† API.`);

        // 3. VALIDA OS QUE N√ÉO EST√ÉO NO CACHE
        if (paraValidarAPI.length > 0) {
            // Verifica se tem requisi√ß√µes dispon√≠veis suficientes
            const requisitasDisponiveis = statusAPI.requisicoes_disponiveis || 1000;

            if (paraValidarAPI.length > requisitasDisponiveis) {
                if (!silencioso) {
                    const continuar = await mostrarConfirmacao(`‚ö†Ô∏è Aten√ß√£o\n\nVoc√™ tem ${paraValidarAPI.length} endere√ßos para validar, mas apenas ${requisitasDisponiveis} requisi√ß√µes dispon√≠veis.\n\n‚ùå ${paraValidarAPI.length - requisitasDisponiveis} endere√ßos N√ÉO ser√£o validados este m√™s.\n\nDeseja continuar validando apenas ${requisitasDisponiveis} endere√ßos?`, '‚ö†Ô∏è Limite de Requisi√ß√µes');

                    if (!continuar) {
                        renderizarTabelaRota();
                        return;
                    }
                }

                // Limita ao dispon√≠vel
                paraValidarAPI.splice(requisitasDisponiveis);
            }

            console.log(`[VALIDA√á√ÉO] Validando ${paraValidarAPI.length} endere√ßos via API...`);

            for (const cliente of paraValidarAPI) {
                try {
                    const endereco = encodeURIComponent(cliente.endereco);
                    const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${endereco}&key=${GOOGLE_API_KEY}`;

                    const response = await fetch(url);
                    const data = await response.json();

                    requisicoesAPI++;
                    let sucesso = false;

                    // VALIDA√á√ÉO RIGOROSA: S√≥ aceita se Google Maps encontrou o endere√ßo
                    if (data.status === 'OK' && data.results.length > 0) {
                        const result = data.results[0];
                        const location = result.geometry.location;
                        const locationType = result.geometry.location_type;

                        // Verifica se as coordenadas s√£o v√°lidas (n√£o-zero e n√£o-nulas)
                        const coordenadasValidas = location.lat && location.lng &&
                                                    Math.abs(location.lat) > 0.01 &&
                                                    Math.abs(location.lng) > 0.01 &&
                                                    !isNaN(location.lat) &&
                                                    !isNaN(location.lng) &&
                                                    location.lat >= -90 && location.lat <= 90 &&
                                                    location.lng >= -180 && location.lng <= 180;

                        // S√≥ valida se as coordenadas forem precisas (ROOFTOP ou RANGE_INTERPOLATED)
                        // Rejeita GEOMETRIC_CENTER e APPROXIMATE que s√£o muito imprecisos
                        const precisaoAceitavel = ['ROOFTOP', 'RANGE_INTERPOLATED'].includes(locationType);

                        // Valida que o endere√ßo encontrado est√° no Brasil (aproximadamente)
                        const noBrasil = location.lat >= -34 && location.lat <= 6 &&
                                        location.lng >= -74 && location.lng <= -34;

                        if (coordenadasValidas && precisaoAceitavel && noBrasil) {
                            cliente.lat = location.lat;
                            cliente.lon = location.lng;
                            cliente.validado = true;
                            validados++;
                            sucesso = true;
                            console.log(`[API] ‚úÖ ${cliente.razao} [${locationType}] (${location.lat}, ${location.lng})`);
                        } else {
                            cliente.validado = false;
                            invalidos++;
                            const motivo = !coordenadasValidas ? 'coordenadas inv√°lidas' :
                                          !precisaoAceitavel ? `localiza√ß√£o imprecisa [${locationType}]` :
                                          !noBrasil ? 'fora do Brasil' : 'desconhecido';
                            console.log(`[API] ‚ùå ${cliente.razao} - ${motivo}`);
                        }
                    } else {
                        cliente.validado = false;
                        invalidos++;
                        console.log(`[API] ‚ùå ${cliente.razao} - N√£o encontrado [${data.status}]`);
                    }

                    // Registra uso da API
                    await fetch(API_BASE_URL + '/geocodificacao/api/registrar', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ sucesso })
                    });

                    // Salva no cache
                    paraCache.push({
                        cnpj: cliente.cnpj,
                        endereco: cliente.endereco,
                        logradouro: cliente.logradouro,
                        numero: cliente.numero,
                        bairro: cliente.bairro,
                        cidade: cliente.cidade,
                        uf: cliente.uf,
                        cep: cliente.cep,
                        lat: cliente.lat || null,
                        lon: cliente.lon || null
                    });

                    // Delay para respeitar rate limit da API
                    await new Promise(resolve => setTimeout(resolve, 200));

                } catch (error) {
                    console.error(`[API] Erro ao validar ${cliente.razao}:`, error);
                    cliente.validado = false;
                    invalidos++;
                }
            }

            // 4. SALVA TUDO NO CACHE
            if (paraCache.length > 0) {
                await fetch(API_BASE_URL + '/geocodificacao/cache/salvar', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(paraCache)
                });
                console.log(`[CACHE] Salvou ${paraCache.length} coordenadas no cache`);
            }
        }

        // 5. MOSTRA RESULTADO
        // Modo silencioso: apenas loga no console, n√£o mostra alerta
        if (!silencioso) {
            let mensagem = `‚úÖ Valida√ß√£o conclu√≠da!\n\n`;
            mensagem += `üìä Estat√≠sticas:\n`;
            mensagem += `‚Ä¢ ${validados} endere√ßos validados\n`;
            if (cacheados > 0) {
                mensagem += `  ‚îî‚îÄ ${cacheados} do cache (economia de API)\n`;
                mensagem += `  ‚îî‚îÄ ${requisicoesAPI} via Google API\n`;
            }
            if (invalidos > 0) {
                mensagem += `‚Ä¢ ${invalidos} endere√ßos n√£o encontrados\n\n`;
            }
            mensagem += `\nüî¢ Uso da API este m√™s:\n`;
            mensagem += `‚Ä¢ Total usado: ${statusAPI.total_requisicoes + requisicoesAPI}/${statusAPI.limite_mensal}\n`;
            mensagem += `‚Ä¢ Dispon√≠veis: ${statusAPI.requisicoes_disponiveis - requisicoesAPI}`;

            await mostrarAlerta(mensagem, '‚úÖ Valida√ß√£o Conclu√≠da');
        } else {
            console.log(`[AUTO-VALIDA√á√ÉO] ‚úÖ ${validados} validados, ${invalidos} n√£o encontrados. API: ${requisicoesAPI} usadas, ${statusAPI.requisicoes_disponiveis - requisicoesAPI} dispon√≠veis`);
        }

        // Remove clientes n√£o validados (N√ÉO remove mais automaticamente - usu√°rio decide)
        // estadoRota.clientesFiltrados = estadoRota.clientesFiltrados.filter(c => c.validado);

        renderizarTabelaRota();

    } catch (error) {
        console.error('[VALIDA√á√ÉO] Erro cr√≠tico:', error);
        await mostrarAlerta('‚ùå Erro ao validar endere√ßos.\n\nVerifique o console para mais detalhes.', '‚ùå Erro');
    }
}

// 7. Event Listeners Globais da Rota
if (rotaInputsFonte) {
    rotaInputsFonte.forEach(r => r.addEventListener('change', () => {
        atualizarAbaRota();
    }));
}
if (rotaCheckAtendidos) rotaCheckAtendidos.addEventListener('change', aplicarFiltrosGerais);
if (rotaCheckNaoAtendidos) rotaCheckNaoAtendidos.addEventListener('change', aplicarFiltrosGerais);


// 8. Bot√£o Gerar Rotas Otimizadas (FLUXO INTELIGENTE - Cache primeiro, API s√≥ se necess√°rio)
rotaGerarBtn.addEventListener('click', async () => {
    // Verifica se cidade ou bairro foi selecionado (pelo menos um)
    if (estadoRota.cidadesPrioridade.length === 0 && estadoRota.bairrosPrioridade.length === 0) {
        await mostrarAlerta('‚ùå Selecione pelo menos uma CIDADE ou BAIRRO antes de validar endere√ßos.', '‚ùå Filtro Obrigat√≥rio');
        return;
    }

    if (estadoRota.clientesFiltrados.length === 0) {
        await mostrarAlerta('Nenhum cliente dispon√≠vel para validar!', '‚ö†Ô∏è Sem Clientes');
        return;
    }

    // üî• ETAPA 1: VERIFICA CACHE PRIMEIRO (N√ÉO consome API!)
    rotaGerarBtn.disabled = true;
    rotaGerarBtn.textContent = 'üîç Verificando cache...';

    const cacheInfo = await verificarCacheEndereco();

    rotaGerarBtn.disabled = false;
    rotaGerarBtn.textContent = 'üìç Validar Endere√ßos';

    // üî• ETAPA 2: Se houver clientes que PRECISAM de API, PERGUNTA ao usu√°rio
    if (cacheInfo.precisamAPI > 0) {
        let mensagem = `üìä An√°lise de Valida√ß√£o:\n\n`;

        if (cacheInfo.noCache > 0) {
            mensagem += `‚úÖ ${cacheInfo.noCache} cliente(s) j√° validado(s) anteriormente (cache)\n`;
        }

        mensagem += `‚ö†Ô∏è ${cacheInfo.precisamAPI} cliente(s) PRECISAM de valida√ß√£o via Google API\n\n`;
        mensagem += `üí∞ ATEN√á√ÉO: Isso consumir√° ${cacheInfo.precisamAPI} requisi√ß√£o(√µes) da API!\n\n`;
        mensagem += `Deseja validar agora via Google Maps?\n\n`;
        mensagem += `‚úÖ SIM: Valida e gera rotas\n`;
        mensagem += `‚ùå N√ÉO: Gera rotas apenas com clientes j√° validados`;

        const validar = await mostrarConfirmacao(mensagem, 'üí∞ Validar e Consumir API?');

        if (validar) {
            rotaGerarBtn.disabled = true;
            rotaGerarBtn.textContent = `‚è≥ Validando ${cacheInfo.precisamAPI} endere√ßo(s) via API...`;

            await validarEnderecosGoogleMaps(false); // Modo N√ÉO silencioso para mostrar resultado

            rotaGerarBtn.disabled = false;
            rotaGerarBtn.textContent = 'üìç Validar Endere√ßos';
        } else {
            console.log('[ROTAS] Usu√°rio optou por n√£o validar. Gerando rotas apenas com clientes j√° validados.');
        }
    } else if (cacheInfo.noCache > 0) {
        // Todos foram validados pelo cache
        await mostrarAlerta(`‚úÖ ${cacheInfo.noCache} cliente(s) validado(s) via cache!\n\nüí∞ Nenhuma requisi√ß√£o de API necess√°ria.`, '‚úÖ Cache Aplicado');
    }

    // üî• ETAPA 3: Verifica se h√° clientes validados para gerar rota
    // L√ìGICA CORRIGIDA: Cidade OU Bairro (n√£o E)
    const validados = estadoRota.clientesFiltrados.filter(c => {
        // Se n√£o h√° filtros, inclui todos validados
        if (estadoRota.cidadesPrioridade.length === 0 && estadoRota.bairrosPrioridade.length === 0) {
            return c.validado;
        }

        const cidadeInclusa = estadoRota.cidadesPrioridade.length === 0 || estadoRota.cidadesPrioridade.includes(c.cidade);
        const bairroIncluso = estadoRota.bairrosPrioridade.length === 0 || estadoRota.bairrosPrioridade.includes(c.bairro);

        // Cidade OU Bairro (se ambos estiverem vazios, inclui tudo)
        return c.validado && (cidadeInclusa && bairroIncluso);
    });

    if (validados.length === 0) {
        await mostrarAlerta('‚ùå Nenhum cliente validado encontrado.\n\nValide os endere√ßos primeiro ou verifique os filtros.', '‚ö†Ô∏è Sem Endere√ßos V√°lidos');
        return;
    }

    // üî• ETAPA 4: GERA AS ROTAS
    gerarRotasInteligentes();
    renderizarTabelaRota();
    exibirResumoRotas();

    await mostrarAlerta(`‚úÖ Rotas criadas!\n\n${estadoRota.rotasGeradas.length} rotas com ${validados.length} clientes validados.`, '‚úÖ Sucesso');
});

// 10. Exportar Configura√ß√£o JSON
rotaExportBtn.addEventListener('click', async () => {
    if (estadoRota.cidadesPrioridade.length === 0 && estadoRota.rotasGeradas.length === 0) {
        await mostrarAlerta('Configure as rotas antes de exportar!', '‚ö†Ô∏è Configura√ß√£o Necess√°ria');
        return;
    }

    // Exporta estado completo
    const exportData = {
        versao: '2.0',
        dataExportacao: new Date().toISOString(),
        configuracao: {
            cidadesPrioridade: estadoRota.cidadesPrioridade,
            bairrosPrioridade: estadoRota.bairrosPrioridade,
            fonte: Array.from(rotaInputsFonte).find(r => r.checked)?.value || 'pesquisa'
        },
        rotas: estadoRota.rotasGeradas.map(rota => ({
            id: rota.id,
            nome: rota.nome || `R${rota.id}`,
            clientes: rota.clientes.map(c => ({
                cnpj: c.cnpj,
                razao: c.razao,
                endereco: c.endereco,
                bairro: c.bairro,
                cidade: c.cidade,
                lat: c.lat,
                lon: c.lon,
                validado: c.validado
            }))
        })),
        totalClientes: estadoRota.clientesFiltrados.length,
        clientesValidos: estadoRota.clientesFiltrados.filter(c => c.validado).length
    };

    const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `rotas_gf2_${new Date().toISOString().slice(0,10)}_${new Date().getTime()}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    await mostrarAlerta(`‚úÖ Configura√ß√£o exportada!\n\nüì¶ ${exportData.rotas.length} rotas\nüë• ${exportData.totalClientes} clientes\n‚úîÔ∏è ${exportData.clientesValidos} validados`, '‚úÖ Exporta√ß√£o Conclu√≠da');
});

// 11. Importar Configura√ß√£o JSON
if(rotaImportFile) {
    rotaImportFile.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if(!file) return;

        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                const data = JSON.parse(ev.target.result);

                if (!data.versao || !data.configuracao) {
                    mostrarAlerta('Arquivo de configura√ß√£o inv√°lido ou vers√£o antiga!', '‚ùå Arquivo Inv√°lido');
                    return;
                }

                // Restaura configura√ß√£o
                estadoRota.cidadesPrioridade = data.configuracao.cidadesPrioridade || [];
                estadoRota.bairrosPrioridade = data.configuracao.bairrosPrioridade || [];

                // Restaura rotas
                estadoRota.rotasGeradas = data.rotas || [];

                // Reconstr√≥i clientesFiltrados a partir das rotas
                const todosClientes = [];
                data.rotas.forEach(rota => {
                    rota.clientes.forEach(cliente => {
                        cliente.rotaId = rota.id;
                        cliente.rotaNome = rota.nome;
                        todosClientes.push(cliente);
                    });
                });

                estadoRota.clientesFiltrados = todosClientes;
                estadoRota.dadosOriginais = [...todosClientes];

                // Atualiza UI
                renderizarTagsCidades();
                popularSelectBairros();
                renderizarTagsBairros();
                renderizarTabelaRota();
                exibirResumoRotas();

                alert(`‚úÖ Configura√ß√£o importada!\n\nüì¶ ${data.rotas.length} rotas\nüë• ${data.totalClientes} clientes\n‚úîÔ∏è ${data.clientesValidos} validados`);

                rotaImportFile.value = ""; // Limpa para permitir reimportar
            } catch(err) {
                alert("‚ùå Erro ao importar arquivo!\n\nVerifique se o arquivo est√° correto.");
                console.error('Erro na importa√ß√£o:', err);
            }
        };
        reader.readAsText(file);
    });
}

// ===========================================================
// 12. Modal de Adicionar Clientes Manualmente
// ===========================================================

function verificarExportar() {
    // Garante que o bot√£o de exporta√ß√£o s√≥ fique habilitado quando houver algo salvo
    if (!rotaExportBtn) return;

    const temRotasSalvas =
        estadoRota &&
        estadoRota.rotasSalvas &&
        Object.keys(estadoRota.rotasSalvas).length > 0;

    rotaExportBtn.disabled = !temRotasSalvas;
}
setInterval(verificarExportar, 1000); // Check simples peri√≥dico
// ===========================================================
// GERA√á√ÉO DE LINKS E GEST√ÉO (Salvar/Exportar)
// ===========================================================
// Event listener duplicado removido - funcionalidade movida para exibirResumoRotas()

// Event listeners duplicados - j√° existem em outras partes do c√≥digo com verifica√ß√£o
// Removidos para evitar duplica√ß√£o e erros

// --- FUN√á√ïES GERADORAS DE URL ---

 // Usa s√≥ o endere√ßo ‚Äúpuro‚Äù (rua, n√∫mero, cidade - UF)
function montarEnderecoTexto(item) {
    // Rua / logradouro vindo do resultado ou do endere√ßo completo
    let rua = String(item.logradouro_raw || item.endereco || "").trim();
    let num = String(item.numero_raw || "").trim().toUpperCase();

    // Normaliza n√∫mero "sem n√∫mero"
    if (['SN', 'S/N', '0', ''].includes(num.replace(/[^A-Z0-9]/g, ''))) {
        num = "";
    }

    // Se o logradouro vier com v√≠rgula, pega s√≥ a primeira parte
    if (rua.includes(",")) {
        rua = rua.split(",")[0];
    }

    const cidadeUf = `${String(item.cidade).trim()} - ${String(item.uf).trim()}`;

    const partes = [
        rua,
        num,
        cidadeUf
    ].filter(p => p && p !== "");

    return partes.join(', ');
}



// GOOGLE
/* * Fun√ß√£o: gerarUrlGoogle (Otimizada - Usa COORDENADAS ao inv√©s de endere√ßos)
 * Benef√≠cios:
 * - Coordenadas s√£o muito mais curtas que endere√ßos (~20 chars vs ~100+ chars)
 * - Permite at√© 25 waypoints sem estourar limite de URL
 * - Mais preciso: vai exatamente para o ponto validado pela API
 * - N√£o precisa encodar (coordenadas n√£o t√™m caracteres especiais)
 */
/* * SEMPRE usa localiza√ß√£o atual como origem e carro como modo de transporte */
function gerarUrlGoogle(lista, latUser, lonUser) {
    // Usa COORDENADAS ao inv√©s de endere√ßos completos!
    // Formato: "-29.123456,-51.234567"
    const coordenadas = lista.map(item => `${item.lat},${item.lon}`);
    const destinations = coordenadas.join('/');

    // SEMPRE usa localiza√ß√£o atual como origem
    let originParam = 'Current+Location';
    if (latUser && lonUser) {
        originParam = `${latUser},${lonUser}`;
    }

    // Formato: google.com/maps/dir/Origem/Lat1,Lon1/Lat2,Lon2/
    // Par√¢metro travelmode=driving for√ßa o modo de transporte como CARRO
    return `https://www.google.com/maps/dir/${originParam}/${destinations}?travelmode=driving`;
}


    // Fun√ß√£o gerarUrlBing removida - Sistema usa apenas Google Maps

    function criarContainerLinks() {
        const div = document.createElement('div');
        div.id = 'rota-links-container';
        div.style.marginTop = '1rem';
        div.style.display = 'flex';
        div.style.flexWrap = 'wrap';
        div.style.gap = '10px';
        // Insere logo ap√≥s o header da rota
        const header = document.querySelector('#tab-rota .card-header-row');
        header.after(div);
        return div;
    }

// [L√ìGICA MATEM√ÅTICA] Calcula dist√¢ncia aproximada entre dois pontos
    function calcularDistanciaSimples(lat1, lon1, lat2, lon2) {
        const R = 6371; // Raio da Terra em km
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = 
            Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c; // Dist√¢ncia em KM
    }

/* * Fun√ß√£o: ordenarPorProximidade
 * Descri√ß√£o: Ordena a lista de clientes. 
 * Regra: 
 * 1. Respeita a 'ordemManual' definida pelo usu√°rio.
 * 2. Os itens restantes s√£o organizados pelo vizinho mais pr√≥ximo (Greedy),
 * partindo do √∫ltimo ponto manual (ou do primeiro da lista, se n√£o houver manuais).
 */
function ordenarPorProximidade(listaDesordenada) {
    // 1. Separa√ß√£o: Manuais vs Autom√°ticos
    // Verifica se existe a propriedade ordemManual e se √© um n√∫mero inteiro
    const manuais = listaDesordenada.filter(i => 
        i.ordemManual !== undefined && 
        i.ordemManual !== null && 
        i.ordemManual !== "" &&
        Number.isInteger(Number(i.ordemManual))
    );
    
    // O restante s√£o os autom√°ticos
    const automaticos = listaDesordenada.filter(i => 
        i.ordemManual === undefined || 
        i.ordemManual === null || 
        i.ordemManual === "" ||
        !Number.isInteger(Number(i.ordemManual))
    );

    // 2. Ordena√ß√£o dos Manuais (Crescente: 1, 2, 3...)
    manuais.sort((a, b) => Number(a.ordemManual) - Number(b.ordemManual));

    // 3. Otimiza√ß√£o dos Autom√°ticos (Vizinho mais pr√≥ximo)
    
    // Separa os autom√°ticos em quem tem Geo (lat/lon) e quem n√£o tem
    let comGeo = automaticos.filter(i => i.lat && i.lon && parseFloat(i.lat) !== 0);
    let semGeo = automaticos.filter(i => !i.lat || !i.lon || parseFloat(i.lat) === 0);

    // Define o ponto de refer√™ncia inicial:
    // Se tivermos manuais, o algoritmo come√ßa do √öLTIMO manual (para dar continuidade).
    // Se n√£o, come√ßa null (o algoritmo pegar√° o primeiro da lista).
    let pontoReferencia = manuais.length > 0 ? manuais[manuais.length - 1] : null;

    let automaticosOrdenados = [];

    while (comGeo.length > 0) {
        let indiceMaisProximo = -1;
        let menorDistancia = Infinity;

        // Se n√£o temos refer√™ncia (ex: nenhum manual foi preenchido), 
        // pegamos o primeiro da lista autom√°tica para come√ßar a tra√ßar a rota.
        if (!pontoReferencia) {
            pontoReferencia = comGeo.shift();
            automaticosOrdenados.push(pontoReferencia);
            continue;
        }

        // Busca qual dos pontos restantes est√° mais perto da refer√™ncia
        for (let i = 0; i < comGeo.length; i++) {
            const distancia = calcularDistanciaSimples(
                pontoReferencia.lat, pontoReferencia.lon, 
                comGeo[i].lat, comGeo[i].lon
            );
            
            if (distancia < menorDistancia) {
                menorDistancia = distancia;
                indiceMaisProximo = i;
            }
        }

        if (indiceMaisProximo !== -1) {
            // Adiciona o mais pr√≥ximo na lista final
            const vizinho = comGeo[indiceMaisProximo];
            automaticosOrdenados.push(vizinho);
            
            // Remove da lista de pendentes
            comGeo.splice(indiceMaisProximo, 1);
            
            // O vizinho vira a nova refer√™ncia
            pontoReferencia = vizinho;
        } else {
            // Break de seguran√ßa
            break; 
        }
    }

    // 4. Retorno Unificado: [Manuais] -> [Otimizados] -> [Sem Coordenada]
    return [...manuais, ...automaticosOrdenados, ...semGeo];
}

// C√°lculo matem√°tico da dist√¢ncia (Haversine simplificado para performance)
function calcularDistanciaSimples(lat1, lon1, lat2, lon2) {
    const R = 6371; // Raio da Terra em km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c; 
}


  // ===========================================================
  // [FRONTEND-GF2] M√ìDULO ESTAT√çSTICA (IBGE + SEGMENTOS)
  // ===========================================================

  function limparTabelaEstatistica(mensagem) {
    if (!estatisticaCorpo) return;
    estatisticaCorpo.innerHTML = `
      <tr class="empty-state">
        <td colspan="5">${mensagem || 'Nenhum dado dispon√≠vel.'}</td>
      </tr>
    `;
  }

  function montarContextoEstatistica() {
    const uf = ufSelect ? ufSelect.value : '';
    const setorTexto =
      setorSelect && setorSelect.value
        ? setorSelect.options[setorSelect.selectedIndex].textContent
        : 'Todos os grandes setores';
    const segmentoTexto =
      segmentoSelect && segmentoSelect.value
        ? segmentoSelect.options[segmentoSelect.selectedIndex].textContent
        : 'Todos os segmentos';

    const qtdMunicipiosFiltro = selectedMunicipios ? selectedMunicipios.size : 0;
    const trechoMun =
      qtdMunicipiosFiltro > 0
        ? ` | Foco em ${qtdMunicipiosFiltro} munic√≠pio${qtdMunicipiosFiltro === 1 ? '' : 's'} selecionado${qtdMunicipiosFiltro === 1 ? '' : 's'}`
        : ' | Todos os munic√≠pios da UF';

    return `UF ${uf || '‚Äî'} ‚Ä¢ ${setorTexto} ‚Ä¢ ${segmentoTexto}${trechoMun}`;
  }

  async function carregarIbgeUf(uf, anoPreferido) {
    if (!uf) return null;
    const chaveCache = `${uf}|${anoPreferido || 'LAST'}`;
    if (estatisticaCacheIbge.has(chaveCache)) {
      return estatisticaCacheIbge.get(chaveCache);
    }

    const params = new URLSearchParams();
    params.append('uf', uf);
    if (anoPreferido) {
      params.append('ano', String(anoPreferido));
    }

    estatisticaStatus.textContent = 'Consultando indicadores municipais do IBGE...';

    const resp = await apiFetch('/ibge/indicadores', {
      parametros: params,
      cache: 'no-store'
    });

    if (!resp.ok) {
      throw new Error('Falha ao carregar indicadores IBGE.');
    }

    const dados = await resp.json();
    estatisticaCacheIbge.set(chaveCache, dados);
    return dados;
  }

  function atualizarComboAnoIbge(dadosIbge) {
    if (!estatisticaAnoSelect || !dadosIbge) return;

    const { anos_disponiveis = [], ano_referencia } = dadosIbge;
    const valorAtual = estatisticaAnoSelect.value;

    estatisticaAnoSelect.innerHTML = '';

    if (!anos_disponiveis.length) {
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = 'Sem ano dispon√≠vel (IBGE n√£o carregado)';
      estatisticaAnoSelect.append(opt);
      estatisticaAnoSelect.disabled = true;
      return;
    }

    const optPadrao = document.createElement('option');
    optPadrao.value = '';
    optPadrao.textContent = `Ano mais recente (${ano_referencia})`;
    estatisticaAnoSelect.append(optPadrao);

    anos_disponiveis.forEach(ano => {
      const opt = document.createElement('option');
      opt.value = String(ano);
      opt.textContent = String(ano);
      estatisticaAnoSelect.append(opt);
    });

    if (valorAtual && anos_disponiveis.includes(Number(valorAtual))) {
      estatisticaAnoSelect.value = valorAtual;
    } else {
      estatisticaAnoSelect.value = '';
    }

    estatisticaAnoSelect.disabled = anos_disponiveis.length <= 1;
  }

  function consolidarEmpresasPorMunicipio() {
    if (!Array.isArray(ultimoResultado) || !ultimoResultado.length) {
      return [];
    }

    const mapa = new Map();

    ultimoResultado.forEach(item => {
      const uf = String(item.uf || '').trim().toUpperCase();
      const cod = String(item.municipio_codigo || '').trim();
      const nome =
        String(item.municipio_nome || item.municipio || '')
          .trim() || '(Sem munic√≠pio)';

      if (!uf) return;

      const chave = `${uf}|${cod || nome.toUpperCase()}`;
      let atual = mapa.get(chave);

      if (!atual) {
        atual = {
          uf,
          municipio_codigo: cod || null,
          municipio_nome: nome,
          qtd_empresas: 0
        };
        mapa.set(chave, atual);
      }

      atual.qtd_empresas += 1;
    });

    return Array.from(mapa.values()).sort((a, b) => {
      if (b.qtd_empresas !== a.qtd_empresas) {
        return b.qtd_empresas - a.qtd_empresas;
      }
      return a.municipio_nome.localeCompare(b.municipio_nome);
    });
  }

  function combinarComIbge(empresasPorMunicipio, dadosIbge) {
    if (!dadosIbge) return empresasPorMunicipio;

    const mapaIbge = new Map();
    (dadosIbge.indicadores || []).forEach(item => {
      const codigo = String(item.municipio_codigo || '');
      if (!codigo) return;
      mapaIbge.set(codigo, item);
    });

    const anoRef = dadosIbge.ano_referencia || null;

    return empresasPorMunicipio.map(row => {
      const cod = row.municipio_codigo ? String(row.municipio_codigo) : '';
      const ibg = cod ? mapaIbge.get(cod) : null;

      const pop =
        ibg && ibg.populacao_total != null
          ? Number(ibg.populacao_total)
          : null;

      const densidade =
        pop && pop > 0
          ? (row.qtd_empresas / pop) * 10000
          : null;

      return {
        ...row,
        ano_ibge: ibg ? ibg.ano : anoRef,
        populacao_total: pop,
        empresas_por_10k_hab: densidade
      };
    });
  }

  function renderizarTabelaEstatistica(linhas) {
    if (!estatisticaCorpo) return;

    if (!linhas || !linhas.length) {
      limparTabelaEstatistica('Nenhuma empresa encontrada no contexto atual.');
      if (estatisticaResumo) estatisticaResumo.textContent = '';
      return;
    }

    const totalEmpresas = linhas.reduce(
      (acc, row) => acc + (row.qtd_empresas || 0),
      0
    );
    const totalPop = linhas.reduce(
      (acc, row) => acc + (row.populacao_total || 0),
      0
    );

    if (estatisticaResumo) {
      estatisticaResumo.textContent =
        `Cobertura em ${linhas.length} munic√≠pios ‚Ä¢ ` +
        `${totalEmpresas.toLocaleString('pt-BR')} empresas na amostra atual` +
        (totalPop
          ? ` ‚Ä¢ Popula√ß√£o somada: ${totalPop.toLocaleString('pt-BR')}`
          : '');
    }

    estatisticaCorpo.innerHTML = '';
    const fragment = document.createDocumentFragment();

    linhas.forEach(row => {
      const densidadeFmt =
        row.empresas_por_10k_hab != null
          ? row.empresas_por_10k_hab.toLocaleString('pt-BR', {
              maximumFractionDigits: 2
            })
          : '‚Äî';
      const popFmt =
        row.populacao_total != null
          ? row.populacao_total.toLocaleString('pt-BR')
          : '‚Äî';

      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${row.municipio_nome}</td>
        <td>${row.uf}</td>
        <td>${popFmt}</td>
        <td>${row.qtd_empresas.toLocaleString('pt-BR')}</td>
        <td>${densidadeFmt}</td>
      `;
      fragment.append(tr);
    });

    estatisticaCorpo.append(fragment);
  }

  async function atualizarAbaEstatistica() {
    if (!tabEstatisticaBtn) return;

    const temPesquisa = Array.isArray(ultimoResultado) && ultimoResultado.length > 0;

    // Habilita/desabilita o bot√£o da aba
    tabEstatisticaBtn.disabled = !temPesquisa;
    tabEstatisticaBtn.setAttribute('aria-disabled', temPesquisa ? 'false' : 'true');

    if (!temPesquisa) {
      if (estatisticaStatus) {
        estatisticaStatus.textContent =
          'Realize uma pesquisa na aba "Lista CNPJ" para habilitar as estat√≠sticas.';
      }
      limparTabelaEstatistica('Aguardando pesquisa para calcular estat√≠sticas.');
      if (estatisticaResumo) estatisticaResumo.textContent = '';
      return;
    }

    const uf = ufSelect ? ufSelect.value : '';
    estatisticaUfAtual = uf || null;

    if (estatisticaStatus) {
      estatisticaStatus.textContent = 'Consolidando empresas por munic√≠pio...';
    }
    if (estatisticaContexto) {
      estatisticaContexto.textContent = montarContextoEstatistica();
    }

    const empresasPorMunicipio = consolidarEmpresasPorMunicipio();
    if (!empresasPorMunicipio.length) {
      if (estatisticaStatus) {
        estatisticaStatus.textContent =
          'Nenhuma empresa com munic√≠pio definido na sele√ß√£o atual.';
      }
      limparTabelaEstatistica('Nenhuma empresa com munic√≠pio definido.');
      if (estatisticaResumo) estatisticaResumo.textContent = '';
      return;
    }

    try {
      const anoPreferido =
        estatisticaAnoSelect && estatisticaAnoSelect.value
          ? Number(estatisticaAnoSelect.value)
          : null;

      const dadosIbge = uf ? await carregarIbgeUf(uf, anoPreferido) : null;
      if (dadosIbge) {
        atualizarComboAnoIbge(dadosIbge);
      }
      const linhasComIbge = combinarComIbge(empresasPorMunicipio, dadosIbge);
      if (estatisticaStatus) {
        estatisticaStatus.textContent = 'Estat√≠sticas consolidadas com sucesso.';
      }
      renderizarTabelaEstatistica(linhasComIbge);
    } catch (error) {
      console.error('[ESTAT√çSTICA] Erro ao carregar IBGE:', error);
      if (estatisticaStatus) {
        estatisticaStatus.textContent =
          'Estat√≠sticas calculadas apenas com base na base CNPJ (sem IBGE).';
      }
      const linhasSimples = combinarComIbge(empresasPorMunicipio, null);
      renderizarTabelaEstatistica(linhasSimples);
    }
  }

  // Listener espec√≠fico da aba Estat√≠stica
  if (tabEstatisticaBtn) {
    tabEstatisticaBtn.addEventListener('click', () => {
      if (
        tabEstatisticaBtn.disabled ||
        tabEstatisticaBtn.getAttribute('aria-disabled') === 'true'
      ) {
        return;
      }
      atualizarAbaEstatistica();
    });
  }

  // Troca de ano IBGE ‚Üí recalcula com outro ano
  if (estatisticaAnoSelect) {
    estatisticaAnoSelect.addEventListener('change', () => {
      if (!estatisticaUfAtual) return;
      atualizarAbaEstatistica();
    });
  }


// --- Vari√°veis globais para armazenar a localiza√ß√£o do usu√°rio ---
// Usamos 'var' para evitar problemas de TDZ (temporal dead zone) ao chamar fun√ß√µes
// que utilizam essas vari√°veis antes da linha de declara√ß√£o.
var usuarioLat = null;
var usuarioLon = null;

/* * Fun√ß√£o: obterLocalizacaoUsuario
 * Descri√ß√£o: Promessa que retorna a lat/lon do navegador
 */
function obterLocalizacaoUsuario() {
    return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
            reject(new Error("Geolocaliza√ß√£o n√£o suportada pelo navegador."));
            return;
        }
        navigator.geolocation.getCurrentPosition(
            (pos) => {
                usuarioLat = pos.coords.latitude;
                usuarioLon = pos.coords.longitude;
                resolve({ lat: usuarioLat, lon: usuarioLon });
            },
            (err) => {
                console.warn("Permiss√£o de localiza√ß√£o negada ou erro.", err);
                resolve(null); // Resolve como null para n√£o travar o fluxo, usa fallback
            },
            { enableHighAccuracy: true, timeout: 5000 }
        );
    });
}

/* * Fun√ß√£o: ordenarPorProximidadeComPontoPartida
 * Descri√ß√£o: Ordena usando o algoritmo Vizinho Mais Pr√≥ximo, considerando a posi√ß√£o atual do usu√°rio.
 */
function ordenarPorProximidadeComPontoPartida(lista, pontoPartidaLat, pontoPartidaLon) {
    // 1. Separa quem tem ordem manual definida
    const manuais = lista.filter(i => 
        i.ordemManual !== undefined && i.ordemManual !== null && i.ordemManual !== ""
    );
    const automaticos = lista.filter(i => 
        i.ordemManual === undefined || i.ordemManual === null || i.ordemManual === ""
    );

    // Ordena manuais
    manuais.sort((a, b) => Number(a.ordemManual) - Number(b.ordemManual));

    // 2. Prepara lista de autom√°ticos com coordenadas
    let comGeo = automaticos.filter(i => i.lat && i.lon && parseFloat(i.lat) !== 0);
    let semGeo = automaticos.filter(i => !i.lat || !i.lon || parseFloat(i.lat) === 0);

    // 3. Define ponto de refer√™ncia inicial
    // Se houver manuais, o √∫ltimo manual √© a refer√™ncia.
    // Se n√£o, usa a Geolocaliza√ß√£o do Usu√°rio.
    // Se n√£o tiver Geo do usu√°rio, usa o primeiro cliente da lista.
    let refLat, refLon;

    if (manuais.length > 0) {
        const ultimo = manuais[manuais.length - 1];
        refLat = ultimo.lat;
        refLon = ultimo.lon;
    } else if (pontoPartidaLat && pontoPartidaLon) {
        refLat = pontoPartidaLat;
        refLon = pontoPartidaLon;
    } else if (comGeo.length > 0) {
        // Fallback: sem usu√°rio e sem manual, pega o primeiro da lista
        const primeiro = comGeo.shift();
        manuais.push(primeiro); // Trata como se fosse o primeiro manual
        refLat = primeiro.lat;
        refLon = primeiro.lon;
    }

    let automaticosOrdenados = [];

    // 4. Loop Guloso (Greedy)
    while (comGeo.length > 0) {
        let indiceMaisProximo = -1;
        let menorDistancia = Infinity;

        // Se por algum motivo perdemos a refer√™ncia (ex: item manual sem lat/lon), pegamos o pr√≥ximo dispon√≠vel
        if (!refLat || !refLon) {
             const fallback = comGeo.shift();
             automaticosOrdenados.push(fallback);
             refLat = fallback.lat;
             refLon = fallback.lon;
             continue;
        }

        for (let i = 0; i < comGeo.length; i++) {
            const dist = calcularDistanciaSimples(refLat, refLon, comGeo[i].lat, comGeo[i].lon);
            if (dist < menorDistancia) {
                menorDistancia = dist;
                indiceMaisProximo = i;
            }
        }

        if (indiceMaisProximo !== -1) {
            const vizinho = comGeo[indiceMaisProximo];
            automaticosOrdenados.push(vizinho);
            comGeo.splice(indiceMaisProximo, 1);
            refLat = vizinho.lat;
            refLon = vizinho.lon;
        } else {
            break;
        }
    }

    return [...manuais, ...automaticosOrdenados, ...semGeo];
}

const btnProcessar = document.getElementById('rota-gerar-btn');
const painelGestao = document.getElementById('painel-gestao-rotas');
const selectRotas = document.getElementById('select-rotas-geradas');
const resumoInfo = document.getElementById('resumo-rotas-info');

if (btnProcessar) {
    btnProcessar.addEventListener('click', async () => {
        const btnTexto = btnProcessar.textContent;
        btnProcessar.textContent = "Processando...";
        btnProcessar.disabled = true;

        try {
            // 1. Geolocaliza√ß√£o
            const coords = await obterLocalizacaoUsuario();
            const latOrigem = coords ? coords.lat : null;
            const lonOrigem = coords ? coords.lon : null;

            // 2. Ordena√ß√£o Hier√°rquica (Todos os dados, n√£o s√≥ os selecionados checkbox)
            // O usu√°rio pediu "ordenar pelo bairro... com todos os resultados"
            let listaOrdenada = ordenarHierarquico(estadoRota.clientesFiltrados, latOrigem, lonOrigem);

            if (listaOrdenada.length === 0) {
                throw new Error("Nenhum cliente com geolocaliza√ß√£o v√°lida encontrado.");
            }

            // 3. Batching (Divis√£o em Lotes)
            const limite = 10; // Google Maps - limite fixo
            
            // Limpa rotas anteriores
            rotasArmazenadas.clear();
            
            // L√≥gica de corte
            let contadorRota = 1;
            for (let i = 0; i < listaOrdenada.length; i += limite) {
                const lote = listaOrdenada.slice(i, i + limite);
                // Atribui ID da rota aos objetos
                lote.forEach(item => item.idRotaAtribuida = contadorRota);
                rotasArmazenadas.set(contadorRota, lote);
                contadorRota++;
            }

            // 4. Atualiza UI
            atualizarSelectRotas();
            renderizarTabelaRota(); // Re-renderiza tudo para mostrar status
            
            painelGestao.style.display = 'block';
            resumoInfo.textContent = `${listaOrdenada.length} clientes distribu√≠dos em ${rotasArmazenadas.size} rotas.`;

        } catch (e) {
            await mostrarAlerta(e.message, '‚ùå Erro ao Processar Rota');
        } finally {
            btnProcessar.textContent = btnTexto;
            btnProcessar.disabled = false;
        }
    });
}

function atualizarSelectRotas() {
    selectRotas.innerHTML = '';
    rotasArmazenadas.forEach((clientes, numero) => {
        // Pega o bairro predominante na rota para exibir no nome
        const bairroPredominante = clientes[0].bairro || "Diversos";
        const option = document.createElement('option');
        option.value = numero;
        option.textContent = `Rota ${numero.toString().padStart(2, '0')} (${clientes.length} clientes) - In√≠cio: ${bairroPredominante}`;
        selectRotas.appendChild(option);
    });
}


let bairrosDisponiveis = [];
let rotasArmazenadas = new Map(); // Armazena as rotas geradas: Key=NumeroRota, Value=ArrayClientes

// Adicione esta chamada dentro da sua fun√ß√£o atualizarAbaRota() existente
function carregarSequenciadorBairros() {
    const container = document.getElementById('container-sequencia-bairros');
    if (!container) return;
    container.innerHTML = '';

    // Extrai bairros √∫nicos dos dados filtrados
    const setBairros = new Set();
    estadoRota.clientesFiltrados.forEach(item => {
        if (item.bairro && item.bairro.trim() !== '') {
            setBairros.add(item.bairro.trim().toUpperCase());
        } else {
            setBairros.add("OUTROS");
        }
    });
    
    bairrosDisponiveis = Array.from(setBairros).sort();

    if (bairrosDisponiveis.length === 0) {
        container.innerHTML = '<span class="helper-text">Nenhum bairro identificado.</span>';
        return;
    }

    // Cria os inputs de ordem
    bairrosDisponiveis.forEach(bairro => {
        const div = document.createElement('div');
        div.className = 'btn-chip'; // Reutilizando estilo chip
        div.style.display = 'flex';
        div.style.alignItems = 'center';
        div.style.gap = '8px';
        div.style.background = '#fff';
        div.style.cursor = 'default';

        const label = document.createElement('span');
        label.textContent = bairro;
        label.style.fontSize = '0.8rem';
        label.style.fontWeight = '600';

        const input = document.createElement('input');
        input.type = 'number';
        input.className = 'input-sequencia-bairro';
        input.dataset.bairro = bairro;
        input.placeholder = 'N¬∫';
        input.min = '1';
        input.style.width = '40px';
        input.style.padding = '2px 4px';
        input.style.border = '1px solid #ccc';
        input.style.borderRadius = '4px';

        div.appendChild(input);
        div.appendChild(label);
        container.appendChild(div);
    });
}

/* * Fun√ß√£o: ordenarHierarquico
 * Descri√ß√£o: 
 * 1. Filtra inv√°lidos (sem geo).
 * 2. Agrupa por Bairro seguindo a ordem definida pelo usu√°rio.
 * 3. Otimiza proximidade dentro de cada grupo de bairro.
 * 4. Tenta manter coes√£o de lotes.
 */
function ordenarHierarquico(listaTodos, latOrigem, lonOrigem) {
    // 1. Filtragem de Seguran√ßa RIGOROSA (Remove quem n√£o tem coordenada v√°lida)
    const validos = listaTodos.filter(i => {
        // Verifica se tem coordenadas E se s√£o v√°lidas (n√£o-zero e n√£o muito pr√≥ximas de zero)
        const lat = parseFloat(i.lat);
        const lon = parseFloat(i.lon);
        return i.lat && i.lon &&
               !isNaN(lat) && !isNaN(lon) &&
               Math.abs(lat) > 0.01 &&
               Math.abs(lon) > 0.01 &&
               lat >= -34 && lat <= 6 &&
               lon >= -74 && lon <= -34;
    });

    // 2. Leitura da Sequ√™ncia de Bairros
    const inputs = document.querySelectorAll('.input-sequencia-bairro');
    const mapaPrioridade = new Map();
    let maxOrdem = 9999;

    inputs.forEach(inp => {
        const val = parseInt(inp.value);
        const bairro = inp.dataset.bairro;
        if (!isNaN(val) && val > 0) {
            mapaPrioridade.set(bairro, val);
        } else {
            // Bairros sem n√∫mero v√£o para o final
            mapaPrioridade.set(bairro, maxOrdem);
        }
    });

    // 3. Agrupamento
    // Ordena a lista inteira baseada na prioridade do bairro
    validos.sort((a, b) => {
        const pA = mapaPrioridade.get(a.bairro || "OUTROS") || maxOrdem;
        const pB = mapaPrioridade.get(b.bairro || "OUTROS") || maxOrdem;
        return pA - pB;
    });

    // 4. Otimiza√ß√£o Intra-Bairro (Vizinho Mais Pr√≥ximo dentro do grupo)
    // O algoritmo percorre a lista j√° ordenada por bairro. 
    // Quando muda o bairro, ele reseta o ponto de refer√™ncia para o in√≠cio do novo bairro (ou mant√©m o fluxo).
    // Para simplificar e manter fluxo cont√≠nuo, vamos aplicar o Greedy globalmente, 
    // mas RESTRITO aos blocos de prioridade.
    
    let listaFinal = [];
    
    // Pega bairros √∫nicos ordenados pela prioridade
    const bairrosOrdenados = [...new Set(validos.map(i => i.bairro || "OUTROS"))];
    
    // Ponto de partida inicial
    let refLat = latOrigem; 
    let refLon = lonOrigem;

    bairrosOrdenados.forEach(bairroAtual => {
        // Pega todos os clientes deste bairro
        let clientesBairro = validos.filter(i => (i.bairro || "OUTROS") === bairroAtual);
        
        // Se houver clientes no bairro, ordena eles por proximidade entre si
        // Come√ßando do ponto onde a rota anterior parou (refLat)
        let ordenadosBairro = [];
        
        while (clientesBairro.length > 0) {
            let idxMaisProximo = -1;
            let menorDist = Infinity;

            for(let i=0; i < clientesBairro.length; i++) {
                // Se n√£o tiver ref (ex: geo falhou), pega o primeiro
                if (!refLat) {
                    idxMaisProximo = 0; 
                    break;
                }
                const d = calcularDistanciaSimples(refLat, refLon, clientesBairro[i].lat, clientesBairro[i].lon);
                if (d < menorDist) {
                    menorDist = d;
                    idxMaisProximo = i;
                }
            }
            
            if (idxMaisProximo > -1) {
                const proximo = clientesBairro[idxMaisProximo];
                ordenadosBairro.push(proximo);
                // Atualiza a refer√™ncia para o pr√≥ximo passo
                refLat = proximo.lat;
                refLon = proximo.lon;
                clientesBairro.splice(idxMaisProximo, 1);
            } else {
                // Fallback
                const resto = clientesBairro.shift();
                ordenadosBairro.push(resto);
            }
        }

        // Adiciona o bloco otimizado do bairro na lista final
        listaFinal = [...listaFinal, ...ordenadosBairro];
    });

    return listaFinal;
}

// ABRIR NO MAPA
const btnAbrirRotaMapa = document.getElementById('btn-abrir-rota-mapa');
if (btnAbrirRotaMapa) {
  btnAbrirRotaMapa.addEventListener('click', async () => {
    const rotaId = parseInt(selectRotas.value);
    if (!rotaId || !rotasArmazenadas.has(rotaId)) return;

    const lote = rotasArmazenadas.get(rotaId);

    // Pega localiza√ß√£o para inicio da rota
    const coords = await obterLocalizacaoUsuario(); // Reutiliza a fun√ß√£o
    const latUser = coords ? coords.lat : null;
    const lonUser = coords ? coords.lon : null;

    // Usa sempre Google Maps
    const url = gerarUrlGoogle(lote, latUser, lonUser);

    window.open(url, '_blank');
  });
}

// LIMPAR ROTA ESPEC√çFICA
const btnLimparRotaSelecionada = document.getElementById('btn-limpar-rota-selecionada');
if (btnLimparRotaSelecionada) {
  btnLimparRotaSelecionada.addEventListener('click', () => {
    const rotaId = parseInt(selectRotas.value);
    if (!rotaId || !rotasArmazenadas.has(rotaId)) return;

    // 1. Remove atribui√ß√£o dos objetos
    const lote = rotasArmazenadas.get(rotaId);
    lote.forEach(item => {
        delete item.idRotaAtribuida;
    });

    // 2. Remove da lista de rotas
    rotasArmazenadas.delete(rotaId);

    // 3. Atualiza UI
    atualizarSelectRotas();
    renderizarTabelaRota();
    
    // Se n√£o sobrar rotas, esconde o painel
    if (rotasArmazenadas.size === 0) {
        painelGestao.style.display = 'none';
    }
  });
}

// ===========================================================
// [MOD-ROTA] GEST√ÉO DE ROTAS (PERSIST√äNCIA E ARQUIVOS)
// ===========================================================

// Inicializa√ß√£o: Tenta carregar do LocalStorage ao abrir a p√°gina
function carregarRotasDoLocalStorage() {
    try {
        const salvos = localStorage.getItem('gf2_rotas_salvas');
        if (salvos) {
            estadoRota.rotasSalvas = JSON.parse(salvos);
            atualizarSelectRotasSalvas();
        }
    } catch (e) {
        console.error("Erro ao ler LocalStorage", e);
    }
}
// Chame isso uma vez ao iniciar o script (logo ap√≥s popularUFs, por exemplo)
carregarRotasDoLocalStorage(); 


// 1. SALVAR (No Navegador - LocalStorage)
if(rotaSaveBtn) {
    rotaSaveBtn.addEventListener('click', () => {
        // Valida√ß√£o b√°sica
        if (estadoRota.cidadesSelecionadas.size === 0) {
            alert("Selecione ao menos uma cidade para salvar a configura√ß√£o.");
            return;
        }

        const nome = prompt("D√™ um nome para esta configura√ß√£o de rota (ex: Segunda Feira - Zona Sul):");
        if(!nome) return;

        // Cria o snapshot do estado atual
        // Convertemos Map e Set para Array para poder salvar em JSON
        const snapshot = {
            dataCriacao: new Date().toISOString(),
            cidades: Array.from(estadoRota.cidadesSelecionadas),
            prioridades: Array.from(estadoRota.bairrosPrioridade.entries()),
            selecionados: Array.from(estadoRota.clientesSelecionadosIds),
            fonte: document.querySelector('input[name="rota-fonte"]:checked').value
        };
        
        estadoRota.rotasSalvas[nome] = snapshot;
        
        // Persiste no navegador
        localStorage.setItem('gf2_rotas_salvas', JSON.stringify(estadoRota.rotasSalvas));
        
        atualizarSelectRotasSalvas();
        alert(`Configura√ß√£o "${nome}" salva no navegador com sucesso!`);
        
        // Habilita exporta√ß√£o agora que temos algo salvo
        if(rotaExportBtn) rotaExportBtn.disabled = false;
    });
}

function atualizarSelectRotasSalvas() {
    if(!rotaSavedSelect) return;
    rotaSavedSelect.innerHTML = '<option value="">Minhas Rotas Salvas...</option>';
    
    const nomes = Object.keys(estadoRota.rotasSalvas);
    nomes.forEach(nome => {
        const opt = document.createElement('option');
        opt.value = nome;
        opt.textContent = nome;
        rotaSavedSelect.appendChild(opt);
    });

    // Controla estado do bot√£o Exportar
    if(rotaExportBtn) {
        rotaExportBtn.disabled = nomes.length === 0;
    }
}

// Carregar Configura√ß√£o ao Selecionar no Dropdown
if(rotaSavedSelect) {
    rotaSavedSelect.addEventListener('change', () => {
        const nome = rotaSavedSelect.value;
        if (!nome) return;
        
        const salvo = estadoRota.rotasSalvas[nome];
        if (salvo) {
            // 1. Restaura Fonte
            if (salvo.fonte) {
                const radio = document.querySelector(`input[name="rota-fonte"][value="${salvo.fonte}"]`);
                if(radio) {
                    radio.checked = true;
                    // For√ßa recarga dos dados da fonte correta
                    atualizarAbaRota(); 
                }
            }

            // 2. Restaura Estado
            estadoRota.cidadesSelecionadas = new Set(salvo.cidades);
            estadoRota.bairrosPrioridade = new Map(salvo.prioridades);
            estadoRota.clientesSelecionadosIds = new Set(salvo.selecionados);
            
            // 3. Atualiza Interface
            // Marca checkboxes de cidade
            const chksCidade = document.querySelectorAll('.rota-chk-cidade');
            chksCidade.forEach(c => c.checked = estadoRota.cidadesSelecionadas.has(c.value));
            
            // Renderiza Bairros e Tabela
            atualizarBairrosEGrid();
            
            alert(`Configura√ß√£o "${nome}" carregada.`);
        }
    });
}

// 2. EXPORTAR (Arquivo .JSON)
if(rotaExportBtn) {
    rotaExportBtn.addEventListener('click', () => {
        if (Object.keys(estadoRota.rotasSalvas).length === 0) {
            alert("N√£o h√° rotas salvas para exportar.");
            return;
        }

        const nomeArquivo = `planejamento_rotas_${new Date().toISOString().slice(0,10)}.json`;
        const dataStr = JSON.stringify(estadoRota.rotasSalvas, null, 2); // Identa√ß√£o bonita
        const blob = new Blob([dataStr], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        
        const link = document.createElement('a');
        link.href = url;
        link.download = nomeArquivo;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    });
}

// 3. IMPORTAR (Ler Arquivo .JSON)
// Trigger visual para o input file escondido
if(document.getElementById('rota-btn-importar-trigger')) {
    document.getElementById('rota-btn-importar-trigger').addEventListener('click', () => {
        if(rotaImportFile) rotaImportFile.click();
    });
}

if(rotaImportFile) {
    rotaImportFile.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(event) {
            try {
                const importado = JSON.parse(event.target.result);
                
                // Mescla as rotas importadas com as existentes
                estadoRota.rotasSalvas = { ...estadoRota.rotasSalvas, ...importado };
                
                // Salva tamb√©m no LocalStorage para n√£o perder ao recarregar
                localStorage.setItem('gf2_rotas_salvas', JSON.stringify(estadoRota.rotasSalvas));
                
                atualizarSelectRotasSalvas();
                alert("Arquivo importado com sucesso! As rotas est√£o dispon√≠veis no menu 'Minhas Rotas Salvas'.");
                
                // Limpa o input para permitir importar o mesmo arquivo novamente se necess√°rio
                rotaImportFile.value = '';
            } catch(err) {
                console.error(err);
                alert("Erro ao ler o arquivo. Verifique se √© um JSON v√°lido exportado por este sistema.");
            }
        };
        reader.readAsText(file);
    });
}

</script>


</body>
</html>